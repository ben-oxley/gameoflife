
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

080000c0 <Reset_Handler>:
 80000c0:	b672      	cpsid	i
 80000c2:	4822      	ldr	r0, [pc, #136]	; (800014c <endfiniloop+0x4>)
 80000c4:	f380 8809 	msr	PSP, r0
 80000c8:	2002      	movs	r0, #2
 80000ca:	f380 8814 	msr	CONTROL, r0
 80000ce:	f3bf 8f6f 	isb	sy
 80000d2:	f001 fae5 	bl	80016a0 <__core_init>
 80000d6:	f000 fb0b 	bl	80006f0 <__early_init>
 80000da:	481d      	ldr	r0, [pc, #116]	; (8000150 <endfiniloop+0x8>)
 80000dc:	491d      	ldr	r1, [pc, #116]	; (8000154 <endfiniloop+0xc>)
 80000de:	4a1e      	ldr	r2, [pc, #120]	; (8000158 <endfiniloop+0x10>)

080000e0 <msloop>:
 80000e0:	4291      	cmp	r1, r2
 80000e2:	da02      	bge.n	80000ea <endmsloop>
 80000e4:	6008      	str	r0, [r1, #0]
 80000e6:	3104      	adds	r1, #4
 80000e8:	e7fa      	b.n	80000e0 <msloop>

080000ea <endmsloop>:
 80000ea:	491c      	ldr	r1, [pc, #112]	; (800015c <endfiniloop+0x14>)
 80000ec:	4a17      	ldr	r2, [pc, #92]	; (800014c <endfiniloop+0x4>)

080000ee <psloop>:
 80000ee:	4291      	cmp	r1, r2
 80000f0:	da02      	bge.n	80000f8 <endpsloop>
 80000f2:	6008      	str	r0, [r1, #0]
 80000f4:	3104      	adds	r1, #4
 80000f6:	e7fa      	b.n	80000ee <psloop>

080000f8 <endpsloop>:
 80000f8:	4919      	ldr	r1, [pc, #100]	; (8000160 <endfiniloop+0x18>)
 80000fa:	4a1a      	ldr	r2, [pc, #104]	; (8000164 <endfiniloop+0x1c>)
 80000fc:	4b1a      	ldr	r3, [pc, #104]	; (8000168 <endfiniloop+0x20>)

080000fe <dloop>:
 80000fe:	429a      	cmp	r2, r3
 8000100:	da04      	bge.n	800010c <enddloop>
 8000102:	6808      	ldr	r0, [r1, #0]
 8000104:	6010      	str	r0, [r2, #0]
 8000106:	3104      	adds	r1, #4
 8000108:	3204      	adds	r2, #4
 800010a:	e7f8      	b.n	80000fe <dloop>

0800010c <enddloop>:
 800010c:	2000      	movs	r0, #0
 800010e:	4917      	ldr	r1, [pc, #92]	; (800016c <endfiniloop+0x24>)
 8000110:	4a17      	ldr	r2, [pc, #92]	; (8000170 <endfiniloop+0x28>)

08000112 <bloop>:
 8000112:	4291      	cmp	r1, r2
 8000114:	da02      	bge.n	800011c <endbloop>
 8000116:	6008      	str	r0, [r1, #0]
 8000118:	3104      	adds	r1, #4
 800011a:	e7fa      	b.n	8000112 <bloop>

0800011c <endbloop>:
 800011c:	f001 fa80 	bl	8001620 <__init_ram_areas>
 8000120:	f001 fab6 	bl	8001690 <__late_init>
 8000124:	4c13      	ldr	r4, [pc, #76]	; (8000174 <endfiniloop+0x2c>)
 8000126:	4d14      	ldr	r5, [pc, #80]	; (8000178 <endfiniloop+0x30>)

08000128 <initloop>:
 8000128:	42ac      	cmp	r4, r5
 800012a:	da03      	bge.n	8000134 <endinitloop>
 800012c:	6821      	ldr	r1, [r4, #0]
 800012e:	4788      	blx	r1
 8000130:	3404      	adds	r4, #4
 8000132:	e7f9      	b.n	8000128 <initloop>

08000134 <endinitloop>:
 8000134:	f001 fe5c 	bl	8001df0 <main>
 8000138:	4c10      	ldr	r4, [pc, #64]	; (800017c <endfiniloop+0x34>)
 800013a:	4d11      	ldr	r5, [pc, #68]	; (8000180 <endfiniloop+0x38>)

0800013c <finiloop>:
 800013c:	42ac      	cmp	r4, r5
 800013e:	da03      	bge.n	8000148 <endfiniloop>
 8000140:	6821      	ldr	r1, [r4, #0]
 8000142:	4788      	blx	r1
 8000144:	3404      	adds	r4, #4
 8000146:	e7f9      	b.n	800013c <finiloop>

08000148 <endfiniloop>:
 8000148:	490e      	ldr	r1, [pc, #56]	; (8000184 <endfiniloop+0x3c>)
 800014a:	4708      	bx	r1
 800014c:	20000600 	.word	0x20000600
 8000150:	55555555 	.word	0x55555555
 8000154:	20000000 	.word	0x20000000
 8000158:	20000400 	.word	0x20000400
 800015c:	20000400 	.word	0x20000400
 8000160:	08006530 	.word	0x08006530
 8000164:	20000600 	.word	0x20000600
 8000168:	200006b8 	.word	0x200006b8
 800016c:	200006b8 	.word	0x200006b8
 8000170:	200012c0 	.word	0x200012c0
 8000174:	080000c0 	.word	0x080000c0
 8000178:	080000c0 	.word	0x080000c0
 800017c:	080000c0 	.word	0x080000c0
 8000180:	080000c0 	.word	0x080000c0
 8000184:	08001681 	.word	0x08001681
	...

08000190 <_port_switch>:
 8000190:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000192:	4644      	mov	r4, r8
 8000194:	464d      	mov	r5, r9
 8000196:	4656      	mov	r6, sl
 8000198:	465f      	mov	r7, fp
 800019a:	b4f0      	push	{r4, r5, r6, r7}
 800019c:	466b      	mov	r3, sp
 800019e:	60cb      	str	r3, [r1, #12]
 80001a0:	68c3      	ldr	r3, [r0, #12]
 80001a2:	469d      	mov	sp, r3
 80001a4:	bcf0      	pop	{r4, r5, r6, r7}
 80001a6:	46a0      	mov	r8, r4
 80001a8:	46a9      	mov	r9, r5
 80001aa:	46b2      	mov	sl, r6
 80001ac:	46bb      	mov	fp, r7
 80001ae:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b0 <_port_thread_start>:
 80001b0:	b662      	cpsie	i
 80001b2:	1c28      	adds	r0, r5, #0
 80001b4:	47a0      	blx	r4
 80001b6:	2000      	movs	r0, #0
 80001b8:	f000 ffb2 	bl	8001120 <chThdExit>

080001bc <_port_switch_from_isr>:
 80001bc:	f000 fb38 	bl	8000830 <chSchDoReschedule>

080001c0 <_port_exit_from_isr>:
 80001c0:	4a01      	ldr	r2, [pc, #4]	; (80001c8 <_port_exit_from_isr+0x8>)
 80001c2:	4b02      	ldr	r3, [pc, #8]	; (80001cc <_port_exit_from_isr+0xc>)
 80001c4:	6013      	str	r3, [r2, #0]
 80001c6:	e7fe      	b.n	80001c6 <_port_exit_from_isr+0x6>
 80001c8:	e000ed04 	.word	0xe000ed04
 80001cc:	80000000 	.word	0x80000000

080001d0 <__aeabi_uidiv>:
 80001d0:	2200      	movs	r2, #0
 80001d2:	0843      	lsrs	r3, r0, #1
 80001d4:	428b      	cmp	r3, r1
 80001d6:	d374      	bcc.n	80002c2 <__aeabi_uidiv+0xf2>
 80001d8:	0903      	lsrs	r3, r0, #4
 80001da:	428b      	cmp	r3, r1
 80001dc:	d35f      	bcc.n	800029e <__aeabi_uidiv+0xce>
 80001de:	0a03      	lsrs	r3, r0, #8
 80001e0:	428b      	cmp	r3, r1
 80001e2:	d344      	bcc.n	800026e <__aeabi_uidiv+0x9e>
 80001e4:	0b03      	lsrs	r3, r0, #12
 80001e6:	428b      	cmp	r3, r1
 80001e8:	d328      	bcc.n	800023c <__aeabi_uidiv+0x6c>
 80001ea:	0c03      	lsrs	r3, r0, #16
 80001ec:	428b      	cmp	r3, r1
 80001ee:	d30d      	bcc.n	800020c <__aeabi_uidiv+0x3c>
 80001f0:	22ff      	movs	r2, #255	; 0xff
 80001f2:	0209      	lsls	r1, r1, #8
 80001f4:	ba12      	rev	r2, r2
 80001f6:	0c03      	lsrs	r3, r0, #16
 80001f8:	428b      	cmp	r3, r1
 80001fa:	d302      	bcc.n	8000202 <__aeabi_uidiv+0x32>
 80001fc:	1212      	asrs	r2, r2, #8
 80001fe:	0209      	lsls	r1, r1, #8
 8000200:	d065      	beq.n	80002ce <__aeabi_uidiv+0xfe>
 8000202:	0b03      	lsrs	r3, r0, #12
 8000204:	428b      	cmp	r3, r1
 8000206:	d319      	bcc.n	800023c <__aeabi_uidiv+0x6c>
 8000208:	e000      	b.n	800020c <__aeabi_uidiv+0x3c>
 800020a:	0a09      	lsrs	r1, r1, #8
 800020c:	0bc3      	lsrs	r3, r0, #15
 800020e:	428b      	cmp	r3, r1
 8000210:	d301      	bcc.n	8000216 <__aeabi_uidiv+0x46>
 8000212:	03cb      	lsls	r3, r1, #15
 8000214:	1ac0      	subs	r0, r0, r3
 8000216:	4152      	adcs	r2, r2
 8000218:	0b83      	lsrs	r3, r0, #14
 800021a:	428b      	cmp	r3, r1
 800021c:	d301      	bcc.n	8000222 <__aeabi_uidiv+0x52>
 800021e:	038b      	lsls	r3, r1, #14
 8000220:	1ac0      	subs	r0, r0, r3
 8000222:	4152      	adcs	r2, r2
 8000224:	0b43      	lsrs	r3, r0, #13
 8000226:	428b      	cmp	r3, r1
 8000228:	d301      	bcc.n	800022e <__aeabi_uidiv+0x5e>
 800022a:	034b      	lsls	r3, r1, #13
 800022c:	1ac0      	subs	r0, r0, r3
 800022e:	4152      	adcs	r2, r2
 8000230:	0b03      	lsrs	r3, r0, #12
 8000232:	428b      	cmp	r3, r1
 8000234:	d301      	bcc.n	800023a <__aeabi_uidiv+0x6a>
 8000236:	030b      	lsls	r3, r1, #12
 8000238:	1ac0      	subs	r0, r0, r3
 800023a:	4152      	adcs	r2, r2
 800023c:	0ac3      	lsrs	r3, r0, #11
 800023e:	428b      	cmp	r3, r1
 8000240:	d301      	bcc.n	8000246 <__aeabi_uidiv+0x76>
 8000242:	02cb      	lsls	r3, r1, #11
 8000244:	1ac0      	subs	r0, r0, r3
 8000246:	4152      	adcs	r2, r2
 8000248:	0a83      	lsrs	r3, r0, #10
 800024a:	428b      	cmp	r3, r1
 800024c:	d301      	bcc.n	8000252 <__aeabi_uidiv+0x82>
 800024e:	028b      	lsls	r3, r1, #10
 8000250:	1ac0      	subs	r0, r0, r3
 8000252:	4152      	adcs	r2, r2
 8000254:	0a43      	lsrs	r3, r0, #9
 8000256:	428b      	cmp	r3, r1
 8000258:	d301      	bcc.n	800025e <__aeabi_uidiv+0x8e>
 800025a:	024b      	lsls	r3, r1, #9
 800025c:	1ac0      	subs	r0, r0, r3
 800025e:	4152      	adcs	r2, r2
 8000260:	0a03      	lsrs	r3, r0, #8
 8000262:	428b      	cmp	r3, r1
 8000264:	d301      	bcc.n	800026a <__aeabi_uidiv+0x9a>
 8000266:	020b      	lsls	r3, r1, #8
 8000268:	1ac0      	subs	r0, r0, r3
 800026a:	4152      	adcs	r2, r2
 800026c:	d2cd      	bcs.n	800020a <__aeabi_uidiv+0x3a>
 800026e:	09c3      	lsrs	r3, r0, #7
 8000270:	428b      	cmp	r3, r1
 8000272:	d301      	bcc.n	8000278 <__aeabi_uidiv+0xa8>
 8000274:	01cb      	lsls	r3, r1, #7
 8000276:	1ac0      	subs	r0, r0, r3
 8000278:	4152      	adcs	r2, r2
 800027a:	0983      	lsrs	r3, r0, #6
 800027c:	428b      	cmp	r3, r1
 800027e:	d301      	bcc.n	8000284 <__aeabi_uidiv+0xb4>
 8000280:	018b      	lsls	r3, r1, #6
 8000282:	1ac0      	subs	r0, r0, r3
 8000284:	4152      	adcs	r2, r2
 8000286:	0943      	lsrs	r3, r0, #5
 8000288:	428b      	cmp	r3, r1
 800028a:	d301      	bcc.n	8000290 <__aeabi_uidiv+0xc0>
 800028c:	014b      	lsls	r3, r1, #5
 800028e:	1ac0      	subs	r0, r0, r3
 8000290:	4152      	adcs	r2, r2
 8000292:	0903      	lsrs	r3, r0, #4
 8000294:	428b      	cmp	r3, r1
 8000296:	d301      	bcc.n	800029c <__aeabi_uidiv+0xcc>
 8000298:	010b      	lsls	r3, r1, #4
 800029a:	1ac0      	subs	r0, r0, r3
 800029c:	4152      	adcs	r2, r2
 800029e:	08c3      	lsrs	r3, r0, #3
 80002a0:	428b      	cmp	r3, r1
 80002a2:	d301      	bcc.n	80002a8 <__aeabi_uidiv+0xd8>
 80002a4:	00cb      	lsls	r3, r1, #3
 80002a6:	1ac0      	subs	r0, r0, r3
 80002a8:	4152      	adcs	r2, r2
 80002aa:	0883      	lsrs	r3, r0, #2
 80002ac:	428b      	cmp	r3, r1
 80002ae:	d301      	bcc.n	80002b4 <__aeabi_uidiv+0xe4>
 80002b0:	008b      	lsls	r3, r1, #2
 80002b2:	1ac0      	subs	r0, r0, r3
 80002b4:	4152      	adcs	r2, r2
 80002b6:	0843      	lsrs	r3, r0, #1
 80002b8:	428b      	cmp	r3, r1
 80002ba:	d301      	bcc.n	80002c0 <__aeabi_uidiv+0xf0>
 80002bc:	004b      	lsls	r3, r1, #1
 80002be:	1ac0      	subs	r0, r0, r3
 80002c0:	4152      	adcs	r2, r2
 80002c2:	1a41      	subs	r1, r0, r1
 80002c4:	d200      	bcs.n	80002c8 <__aeabi_uidiv+0xf8>
 80002c6:	4601      	mov	r1, r0
 80002c8:	4152      	adcs	r2, r2
 80002ca:	4610      	mov	r0, r2
 80002cc:	4770      	bx	lr
 80002ce:	e7ff      	b.n	80002d0 <__aeabi_uidiv+0x100>
 80002d0:	b501      	push	{r0, lr}
 80002d2:	2000      	movs	r0, #0
 80002d4:	f000 f80c 	bl	80002f0 <__aeabi_idiv0>
 80002d8:	bd02      	pop	{r1, pc}
 80002da:	46c0      	nop			; (mov r8, r8)

080002dc <__aeabi_uidivmod>:
 80002dc:	2900      	cmp	r1, #0
 80002de:	d0f7      	beq.n	80002d0 <__aeabi_uidiv+0x100>
 80002e0:	e776      	b.n	80001d0 <__aeabi_uidiv>
 80002e2:	4770      	bx	lr
	...

080002f0 <__aeabi_idiv0>:
 80002f0:	4770      	bx	lr
 80002f2:	46c0      	nop			; (mov r8, r8)
	...

08000300 <notify1.lto_priv.60>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000300:	2380      	movs	r3, #128	; 0x80
 8000302:	4a02      	ldr	r2, [pc, #8]	; (800030c <notify1.lto_priv.60+0xc>)
 8000304:	6811      	ldr	r1, [r2, #0]
 8000306:	430b      	orrs	r3, r1
 8000308:	6013      	str	r3, [r2, #0]
}
 800030a:	4770      	bx	lr
 800030c:	40013800 	.word	0x40013800

08000310 <_port_irq_epilogue>:
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8000310:	300f      	adds	r0, #15
 8000312:	d011      	beq.n	8000338 <_port_irq_epilogue+0x28>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000314:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000316:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800031a:	3b20      	subs	r3, #32
 800031c:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000320:	2280      	movs	r2, #128	; 0x80
 8000322:	0452      	lsls	r2, r2, #17
 8000324:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000326:	4a06      	ldr	r2, [pc, #24]	; (8000340 <_port_irq_epilogue+0x30>)
 8000328:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800032a:	6992      	ldr	r2, [r2, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800032c:	6889      	ldr	r1, [r1, #8]
 800032e:	6892      	ldr	r2, [r2, #8]
 8000330:	4291      	cmp	r1, r2
 8000332:	d802      	bhi.n	800033a <_port_irq_epilogue+0x2a>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8000334:	4a03      	ldr	r2, [pc, #12]	; (8000344 <_port_irq_epilogue+0x34>)
 8000336:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
  }
}
 8000338:	4770      	bx	lr

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800033a:	4a03      	ldr	r2, [pc, #12]	; (8000348 <_port_irq_epilogue+0x38>)
 800033c:	619a      	str	r2, [r3, #24]
 800033e:	e7fb      	b.n	8000338 <_port_irq_epilogue+0x28>
 8000340:	20000ac0 	.word	0x20000ac0
 8000344:	080001c0 	.word	0x080001c0
 8000348:	080001bd 	.word	0x080001bd
 800034c:	00000000 	.word	0x00000000

08000350 <NMI_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000350:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000354:	3320      	adds	r3, #32
 8000356:	f383 8809 	msr	PSP, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800035a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800035c:	4770      	bx	lr
 800035e:	46c0      	nop			; (mov r8, r8)

08000360 <chCoreAlloc>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000360:	b672      	cpsid	i
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000362:	2207      	movs	r2, #7
 8000364:	1dc3      	adds	r3, r0, #7
 8000366:	4393      	bics	r3, r2
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000368:	4906      	ldr	r1, [pc, #24]	; (8000384 <chCoreAlloc+0x24>)
 800036a:	4a07      	ldr	r2, [pc, #28]	; (8000388 <chCoreAlloc+0x28>)
 800036c:	6808      	ldr	r0, [r1, #0]
 800036e:	6812      	ldr	r2, [r2, #0]
 8000370:	1a12      	subs	r2, r2, r0
 8000372:	4293      	cmp	r3, r2
 8000374:	d803      	bhi.n	800037e <chCoreAlloc+0x1e>
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8000376:	18c3      	adds	r3, r0, r3
 8000378:	600b      	str	r3, [r1, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800037a:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800037c:	4770      	bx	lr

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 800037e:	2000      	movs	r0, #0
 8000380:	e7fb      	b.n	800037a <chCoreAlloc+0x1a>
 8000382:	46c0      	nop			; (mov r8, r8)
 8000384:	20000a50 	.word	0x20000a50
 8000388:	20000970 	.word	0x20000970
 800038c:	00000000 	.word	0x00000000

08000390 <wakeup.lto_priv.135>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000390:	b672      	cpsid	i
 */
static void wakeup(void *p) {
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000392:	7f03      	ldrb	r3, [r0, #28]
 8000394:	2b07      	cmp	r3, #7
 8000396:	d80c      	bhi.n	80003b2 <wakeup.lto_priv.135+0x22>
 8000398:	4a11      	ldr	r2, [pc, #68]	; (80003e0 <wakeup.lto_priv.135+0x50>)
 800039a:	009b      	lsls	r3, r3, #2
 800039c:	58d3      	ldr	r3, [r2, r3]
 800039e:	469f      	mov	pc, r3
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80003a0:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 80003a2:	6893      	ldr	r3, [r2, #8]
 80003a4:	3301      	adds	r3, #1
 80003a6:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80003a8:	6802      	ldr	r2, [r0, #0]
 80003aa:	6843      	ldr	r3, [r0, #4]
 80003ac:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 80003ae:	6802      	ldr	r2, [r0, #0]
 80003b0:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 80003b2:	2301      	movs	r3, #1
 80003b4:	425b      	negs	r3, r3
 80003b6:	6203      	str	r3, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80003b8:	2300      	movs	r3, #0
 80003ba:	6882      	ldr	r2, [r0, #8]
 80003bc:	7703      	strb	r3, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80003be:	4b09      	ldr	r3, [pc, #36]	; (80003e4 <wakeup.lto_priv.135+0x54>)
  do {
    cp = cp->p_next;
 80003c0:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80003c2:	6899      	ldr	r1, [r3, #8]
 80003c4:	4291      	cmp	r1, r2
 80003c6:	d2fb      	bcs.n	80003c0 <wakeup.lto_priv.135+0x30>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80003c8:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80003ca:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80003cc:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 80003ce:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80003d0:	6058      	str	r0, [r3, #4]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80003d2:	b662      	cpsie	i
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80003d4:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80003d6:	2200      	movs	r2, #0
 80003d8:	6a03      	ldr	r3, [r0, #32]
 80003da:	601a      	str	r2, [r3, #0]
 80003dc:	e7e9      	b.n	80003b2 <wakeup.lto_priv.135+0x22>
 80003de:	46c0      	nop			; (mov r8, r8)
 80003e0:	080057b0 	.word	0x080057b0
 80003e4:	20000ac0 	.word	0x20000ac0
	...

080003f0 <_idle_thread.lto_priv.59>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80003f0:	e7fe      	b.n	80003f0 <_idle_thread.lto_priv.59>
 80003f2:	46c0      	nop			; (mov r8, r8)
	...

08000400 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000400:	e7fe      	b.n	8000400 <BusFault_Handler>
 8000402:	46c0      	nop			; (mov r8, r8)
	...

08000410 <Vector7C>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000410:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000412:	4646      	mov	r6, r8
 8000414:	464f      	mov	r7, r9
 8000416:	b4c0      	push	{r6, r7}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000418:	2680      	movs	r6, #128	; 0x80
 800041a:	05f6      	lsls	r6, r6, #23
 800041c:	6933      	ldr	r3, [r6, #16]
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 800041e:	46f0      	mov	r8, lr

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000420:	079b      	lsls	r3, r3, #30
 8000422:	d406      	bmi.n	8000432 <Vector7C+0x22>
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000424:	4640      	mov	r0, r8
 8000426:	f7ff ff73 	bl	8000310 <_port_irq_epilogue>
}
 800042a:	bc0c      	pop	{r2, r3}
 800042c:	4690      	mov	r8, r2
 800042e:	4699      	mov	r9, r3
 8000430:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8000432:	2300      	movs	r3, #0
 8000434:	6133      	str	r3, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000436:	b672      	cpsid	i
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8000438:	4c19      	ldr	r4, [pc, #100]	; (80004a0 <Vector7C+0x90>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800043a:	6a70      	ldr	r0, [r6, #36]	; 0x24
 800043c:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800043e:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000440:	689a      	ldr	r2, [r3, #8]
 8000442:	1a45      	subs	r5, r0, r1
 8000444:	4295      	cmp	r5, r2
 8000446:	d318      	bcc.n	800047a <Vector7C+0x6a>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000448:	0025      	movs	r5, r4
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800044a:	2700      	movs	r7, #0
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800044c:	46b1      	mov	r9, r6
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800044e:	351c      	adds	r5, #28
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000450:	188a      	adds	r2, r1, r2
 8000452:	62a2      	str	r2, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000454:	681a      	ldr	r2, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000456:	68d9      	ldr	r1, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000458:	6055      	str	r5, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800045a:	61e2      	str	r2, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800045c:	60df      	str	r7, [r3, #12]

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800045e:	42aa      	cmp	r2, r5
 8000460:	d018      	beq.n	8000494 <Vector7C+0x84>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000462:	b662      	cpsie	i
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8000464:	6918      	ldr	r0, [r3, #16]
 8000466:	4788      	blx	r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000468:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800046a:	464a      	mov	r2, r9
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 800046c:	69e3      	ldr	r3, [r4, #28]
 800046e:	6a50      	ldr	r0, [r2, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000470:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8000472:	689a      	ldr	r2, [r3, #8]
 8000474:	1a46      	subs	r6, r0, r1
 8000476:	42b2      	cmp	r2, r6
 8000478:	d9ea      	bls.n	8000450 <Vector7C+0x40>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 800047a:	4c0a      	ldr	r4, [pc, #40]	; (80004a4 <Vector7C+0x94>)
 800047c:	42a3      	cmp	r3, r4
 800047e:	d007      	beq.n	8000490 <Vector7C+0x80>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8000480:	1852      	adds	r2, r2, r1
 8000482:	1a12      	subs	r2, r2, r0
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8000484:	2a01      	cmp	r2, #1
 8000486:	d908      	bls.n	800049a <Vector7C+0x8a>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000488:	2380      	movs	r3, #128	; 0x80
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }
  port_timer_set_alarm(now + delta);
 800048a:	1812      	adds	r2, r2, r0
 800048c:	05db      	lsls	r3, r3, #23
 800048e:	635a      	str	r2, [r3, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000490:	b662      	cpsie	i
 8000492:	e7c7      	b.n	8000424 <Vector7C+0x14>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000494:	464a      	mov	r2, r9
 8000496:	60d7      	str	r7, [r2, #12]
 8000498:	e7e3      	b.n	8000462 <Vector7C+0x52>
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800049a:	2202      	movs	r2, #2
 800049c:	e7f4      	b.n	8000488 <Vector7C+0x78>
 800049e:	46c0      	nop			; (mov r8, r8)
 80004a0:	20000ac0 	.word	0x20000ac0
 80004a4:	20000adc 	.word	0x20000adc
	...

080004b0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80004b0:	4a0c      	ldr	r2, [pc, #48]	; (80004e4 <chSchDoRescheduleAhead+0x34>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80004b2:	b510      	push	{r4, lr}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80004b4:	6810      	ldr	r0, [r2, #0]
  thread_t *otp, *cp;

  otp = currp;
 80004b6:	6991      	ldr	r1, [r2, #24]

  tqp->p_next = tp->p_next;
 80004b8:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80004ba:	605a      	str	r2, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80004bc:	6013      	str	r3, [r2, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80004be:	6190      	str	r0, [r2, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80004c0:	2201      	movs	r2, #1
 80004c2:	7702      	strb	r2, [r0, #28]

  otp->p_state = CH_STATE_READY;
 80004c4:	2200      	movs	r2, #0
 80004c6:	770a      	strb	r2, [r1, #28]
 80004c8:	688a      	ldr	r2, [r1, #8]
 80004ca:	e000      	b.n	80004ce <chSchDoRescheduleAhead+0x1e>
 80004cc:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 80004ce:	689c      	ldr	r4, [r3, #8]
 80004d0:	4294      	cmp	r4, r2
 80004d2:	d8fb      	bhi.n	80004cc <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80004d4:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80004d6:	600b      	str	r3, [r1, #0]
  otp->p_prev = cp->p_prev;
 80004d8:	604a      	str	r2, [r1, #4]
  otp->p_prev->p_next = otp;
 80004da:	6011      	str	r1, [r2, #0]
  cp->p_prev = otp;
 80004dc:	6059      	str	r1, [r3, #4]

  chSysSwitch(currp, otp);
 80004de:	f7ff fe57 	bl	8000190 <_port_switch>
}
 80004e2:	bd10      	pop	{r4, pc}
 80004e4:	20000ac0 	.word	0x20000ac0
	...

080004f0 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 80004f0:	b510      	push	{r4, lr}
 80004f2:	2300      	movs	r3, #0
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->p_flags |= CH_FLAG_TERMINATE;
 80004f4:	2404      	movs	r4, #4
 80004f6:	4806      	ldr	r0, [pc, #24]	; (8000510 <test_terminate_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 80004f8:	58c2      	ldr	r2, [r0, r3]
 80004fa:	2a00      	cmp	r2, #0
 80004fc:	d004      	beq.n	8000508 <test_terminate_threads+0x18>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004fe:	b672      	cpsid	i
 8000500:	7f51      	ldrb	r1, [r2, #29]
 8000502:	4321      	orrs	r1, r4
 8000504:	7751      	strb	r1, [r2, #29]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000506:	b662      	cpsie	i
 8000508:	3304      	adds	r3, #4
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800050a:	2b14      	cmp	r3, #20
 800050c:	d1f4      	bne.n	80004f8 <test_terminate_threads+0x8>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800050e:	bd10      	pop	{r4, pc}
 8000510:	20000a28 	.word	0x20000a28
	...

08000520 <_test_assert_time_window>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000520:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000522:	2380      	movs	r3, #128	; 0x80
 8000524:	05db      	lsls	r3, r3, #23
 8000526:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000528:	b662      	cpsie	i
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 800052a:	1a5b      	subs	r3, r3, r1
 800052c:	1a52      	subs	r2, r2, r1
    return _test_fail(point);
  return FALSE;
 800052e:	2100      	movs	r1, #0
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 8000530:	4293      	cmp	r3, r2
 8000532:	d307      	bcc.n	8000544 <_test_assert_time_window+0x24>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000534:	2301      	movs	r3, #1
 8000536:	4a04      	ldr	r2, [pc, #16]	; (8000548 <_test_assert_time_window+0x28>)
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
 8000538:	3101      	adds	r1, #1
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 800053a:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 800053c:	4a03      	ldr	r2, [pc, #12]	; (800054c <_test_assert_time_window+0x2c>)
 800053e:	7013      	strb	r3, [r2, #0]
  failpoint = point;
 8000540:	4b03      	ldr	r3, [pc, #12]	; (8000550 <_test_assert_time_window+0x30>)
 8000542:	6018      	str	r0, [r3, #0]
}

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
}
 8000544:	0008      	movs	r0, r1
 8000546:	4770      	bx	lr
 8000548:	20000988 	.word	0x20000988
 800054c:	20000989 	.word	0x20000989
 8000550:	200006b8 	.word	0x200006b8
	...

08000560 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(point);
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
 8000560:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000562:	4684      	mov	ip, r0
 8000564:	4f0f      	ldr	r7, [pc, #60]	; (80005a4 <_test_assert_sequence+0x44>)
 8000566:	4810      	ldr	r0, [pc, #64]	; (80005a8 <_test_assert_sequence+0x48>)
 8000568:	683e      	ldr	r6, [r7, #0]
 800056a:	0003      	movs	r3, r0
 800056c:	e005      	b.n	800057a <_test_assert_sequence+0x1a>
  char *cp = tokens_buffer;
  while (cp < tokp) {
    if (*cp++ != *expected++)
 800056e:	7815      	ldrb	r5, [r2, #0]
 8000570:	7822      	ldrb	r2, [r4, #0]
 8000572:	3101      	adds	r1, #1
 8000574:	3301      	adds	r3, #1
 8000576:	4295      	cmp	r5, r2
 8000578:	d109      	bne.n	800058e <_test_assert_sequence+0x2e>
 800057a:	000c      	movs	r4, r1
 800057c:	001a      	movs	r2, r3
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 800057e:	429e      	cmp	r6, r3
 8000580:	d8f5      	bhi.n	800056e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 8000582:	780b      	ldrb	r3, [r1, #0]
 8000584:	2b00      	cmp	r3, #0
 8000586:	d102      	bne.n	800058e <_test_assert_sequence+0x2e>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8000588:	6038      	str	r0, [r7, #0]
     return _test_fail(point);
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
 800058a:	2000      	movs	r0, #0
 800058c:	e008      	b.n	80005a0 <_test_assert_sequence+0x40>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 800058e:	2301      	movs	r3, #1
 8000590:	4a06      	ldr	r2, [pc, #24]	; (80005ac <_test_assert_sequence+0x4c>)

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
    if (*cp++ != *expected++)
     return _test_fail(point);
 8000592:	2001      	movs	r0, #1
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 8000594:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 8000596:	4a06      	ldr	r2, [pc, #24]	; (80005b0 <_test_assert_sequence+0x50>)
 8000598:	7013      	strb	r3, [r2, #0]
  failpoint = point;
 800059a:	4662      	mov	r2, ip
 800059c:	4b05      	ldr	r3, [pc, #20]	; (80005b4 <_test_assert_sequence+0x54>)
 800059e:	601a      	str	r2, [r3, #0]
  }
  if (*expected)
    return _test_fail(point);
  clear_tokens();
  return FALSE;
}
 80005a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80005a2:	46c0      	nop			; (mov r8, r8)
 80005a4:	20000a3c 	.word	0x20000a3c
 80005a8:	20000a40 	.word	0x20000a40
 80005ac:	20000988 	.word	0x20000988
 80005b0:	20000989 	.word	0x20000989
 80005b4:	200006b8 	.word	0x200006b8
	...

080005c0 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
  return FALSE;
 80005c0:	2300      	movs	r3, #0
  return TRUE;
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
 80005c2:	2900      	cmp	r1, #0
 80005c4:	d107      	bne.n	80005d6 <_test_assert+0x16>
/*
 * Assertions.
 */
bool _test_fail(unsigned point) {

  test_global_fail = TRUE;
 80005c6:	4a05      	ldr	r2, [pc, #20]	; (80005dc <_test_assert+0x1c>)
 80005c8:	3301      	adds	r3, #1
 80005ca:	7013      	strb	r3, [r2, #0]
  local_fail = TRUE;
 80005cc:	4a04      	ldr	r2, [pc, #16]	; (80005e0 <_test_assert+0x20>)
 80005ce:	7013      	strb	r3, [r2, #0]
  failpoint = point;
 80005d0:	4b04      	ldr	r3, [pc, #16]	; (80005e4 <_test_assert+0x24>)
 80005d2:	6018      	str	r0, [r3, #0]
}

bool _test_assert(unsigned point, bool condition) {

  if (!condition)
    return _test_fail(point);
 80005d4:	2301      	movs	r3, #1
  return FALSE;
}
 80005d6:	0018      	movs	r0, r3
 80005d8:	4770      	bx	lr
 80005da:	46c0      	nop			; (mov r8, r8)
 80005dc:	20000988 	.word	0x20000988
 80005e0:	20000989 	.word	0x20000989
 80005e4:	200006b8 	.word	0x200006b8
	...

080005f0 <test_emit_token>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80005f0:	b672      	cpsid	i
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {

  chSysLock();
  *tokp++ = token;
 80005f2:	4a03      	ldr	r2, [pc, #12]	; (8000600 <test_emit_token+0x10>)
 80005f4:	6813      	ldr	r3, [r2, #0]
 80005f6:	1c59      	adds	r1, r3, #1
 80005f8:	6011      	str	r1, [r2, #0]
 80005fa:	7018      	strb	r0, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80005fc:	b662      	cpsie	i
  chSysUnlock();
}
 80005fe:	4770      	bx	lr
 8000600:	20000a3c 	.word	0x20000a3c
	...

08000610 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000610:	b570      	push	{r4, r5, r6, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000612:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000614:	0004      	movs	r4, r0
 8000616:	4d09      	ldr	r5, [pc, #36]	; (800063c <test_println+0x2c>)
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000618:	2900      	cmp	r1, #0
 800061a:	d007      	beq.n	800062c <test_println+0x1c>
    chSequentialStreamPut(chp, *msgp++);
 800061c:	6828      	ldr	r0, [r5, #0]
 800061e:	3401      	adds	r4, #1
 8000620:	6803      	ldr	r3, [r0, #0]
 8000622:	689b      	ldr	r3, [r3, #8]
 8000624:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000626:	7821      	ldrb	r1, [r4, #0]
 8000628:	2900      	cmp	r1, #0
 800062a:	d1f7      	bne.n	800061c <test_println+0xc>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800062c:	6828      	ldr	r0, [r5, #0]
 800062e:	2202      	movs	r2, #2
 8000630:	6803      	ldr	r3, [r0, #0]
 8000632:	4903      	ldr	r1, [pc, #12]	; (8000640 <test_println+0x30>)
 8000634:	681b      	ldr	r3, [r3, #0]
 8000636:	4798      	blx	r3
}
 8000638:	bd70      	pop	{r4, r5, r6, pc}
 800063a:	46c0      	nop			; (mov r8, r8)
 800063c:	200006bc 	.word	0x200006bc
 8000640:	080057d0 	.word	0x080057d0
	...

08000650 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8000650:	b570      	push	{r4, r5, r6, lr}

  while (*msgp)
 8000652:	7801      	ldrb	r1, [r0, #0]
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 8000654:	0004      	movs	r4, r0

  while (*msgp)
 8000656:	2900      	cmp	r1, #0
 8000658:	d008      	beq.n	800066c <test_print+0x1c>
 800065a:	4d05      	ldr	r5, [pc, #20]	; (8000670 <test_print+0x20>)
    chSequentialStreamPut(chp, *msgp++);
 800065c:	6828      	ldr	r0, [r5, #0]
 800065e:	3401      	adds	r4, #1
 8000660:	6803      	ldr	r3, [r0, #0]
 8000662:	689b      	ldr	r3, [r3, #8]
 8000664:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000666:	7821      	ldrb	r1, [r4, #0]
 8000668:	2900      	cmp	r1, #0
 800066a:	d1f7      	bne.n	800065c <test_print+0xc>
    chSequentialStreamPut(chp, *msgp++);
}
 800066c:	bd70      	pop	{r4, r5, r6, pc}
 800066e:	46c0      	nop			; (mov r8, r8)
 8000670:	200006bc 	.word	0x200006bc
	...

08000680 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 8000680:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000682:	4647      	mov	r7, r8
 8000684:	b480      	push	{r7}
 8000686:	0006      	movs	r6, r0
 8000688:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 800068a:	2800      	cmp	r0, #0
 800068c:	d023      	beq.n	80006d6 <test_printn+0x56>
 800068e:	46e8      	mov	r8, sp
 8000690:	466f      	mov	r7, sp
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8000692:	0030      	movs	r0, r6
 8000694:	210a      	movs	r1, #10
 8000696:	f7ff fe21 	bl	80002dc <__aeabi_uidivmod>
 800069a:	3701      	adds	r7, #1
 800069c:	3130      	adds	r1, #48	; 0x30
 800069e:	b2cc      	uxtb	r4, r1
 80006a0:	1e7d      	subs	r5, r7, #1
 80006a2:	0030      	movs	r0, r6
 80006a4:	702c      	strb	r4, [r5, #0]
 80006a6:	210a      	movs	r1, #10
 80006a8:	f7ff fd92 	bl	80001d0 <__aeabi_uidiv>
 80006ac:	1e06      	subs	r6, r0, #0

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 80006ae:	d1f0      	bne.n	8000692 <test_printn+0x12>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80006b0:	4547      	cmp	r7, r8
 80006b2:	d90c      	bls.n	80006ce <test_printn+0x4e>
 80006b4:	466b      	mov	r3, sp
 80006b6:	4e0b      	ldr	r6, [pc, #44]	; (80006e4 <test_printn+0x64>)
 80006b8:	1e5f      	subs	r7, r3, #1
 80006ba:	e000      	b.n	80006be <test_printn+0x3e>
 80006bc:	782c      	ldrb	r4, [r5, #0]
      chSequentialStreamPut(chp, *--p);
 80006be:	6830      	ldr	r0, [r6, #0]
 80006c0:	0021      	movs	r1, r4
 80006c2:	6803      	ldr	r3, [r0, #0]
 80006c4:	3d01      	subs	r5, #1
 80006c6:	689b      	ldr	r3, [r3, #8]
 80006c8:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80006ca:	42bd      	cmp	r5, r7
 80006cc:	d1f6      	bne.n	80006bc <test_printn+0x3c>
      chSequentialStreamPut(chp, *--p);
  }
}
 80006ce:	b004      	add	sp, #16
 80006d0:	bc04      	pop	{r2}
 80006d2:	4690      	mov	r8, r2
 80006d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 80006d6:	4b03      	ldr	r3, [pc, #12]	; (80006e4 <test_printn+0x64>)
 80006d8:	2130      	movs	r1, #48	; 0x30
 80006da:	6818      	ldr	r0, [r3, #0]
 80006dc:	6803      	ldr	r3, [r0, #0]
 80006de:	689b      	ldr	r3, [r3, #8]
 80006e0:	4798      	blx	r3
 80006e2:	e7f4      	b.n	80006ce <test_printn+0x4e>
 80006e4:	200006bc 	.word	0x200006bc
	...

080006f0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80006f0:	2301      	movs	r3, #1
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80006f2:	2002      	movs	r0, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80006f4:	4927      	ldr	r1, [pc, #156]	; (8000794 <__early_init+0xa4>)
 80006f6:	680a      	ldr	r2, [r1, #0]
 80006f8:	4313      	orrs	r3, r2
 80006fa:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80006fc:	680a      	ldr	r2, [r1, #0]
 80006fe:	4b25      	ldr	r3, [pc, #148]	; (8000794 <__early_init+0xa4>)
 8000700:	4210      	tst	r0, r2
 8000702:	d0fb      	beq.n	80006fc <__early_init+0xc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8000704:	2103      	movs	r1, #3
 8000706:	685a      	ldr	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000708:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800070a:	438a      	bics	r2, r1
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800070c:	0019      	movs	r1, r3
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 800070e:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8000710:	685a      	ldr	r2, [r3, #4]
 8000712:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8000714:	684b      	ldr	r3, [r1, #4]
 8000716:	4a1f      	ldr	r2, [pc, #124]	; (8000794 <__early_init+0xa4>)
 8000718:	4003      	ands	r3, r0
 800071a:	d1fb      	bne.n	8000714 <__early_init+0x24>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800071c:	20f9      	movs	r0, #249	; 0xf9
 800071e:	6811      	ldr	r1, [r2, #0]
 8000720:	4001      	ands	r1, r0
 8000722:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000724:	6053      	str	r3, [r2, #4]
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8000726:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000728:	3301      	adds	r3, #1
 800072a:	430b      	orrs	r3, r1
 800072c:	6353      	str	r3, [r2, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 800072e:	38f7      	subs	r0, #247	; 0xf7
 8000730:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8000732:	4b18      	ldr	r3, [pc, #96]	; (8000794 <__early_init+0xa4>)
 8000734:	4208      	tst	r0, r1
 8000736:	d0fb      	beq.n	8000730 <__early_init+0x40>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000738:	2201      	movs	r2, #1
 800073a:	6a59      	ldr	r1, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800073c:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800073e:	430a      	orrs	r2, r1
 8000740:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000742:	001a      	movs	r2, r3
 8000744:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8000746:	4b13      	ldr	r3, [pc, #76]	; (8000794 <__early_init+0xa4>)
 8000748:	4208      	tst	r0, r1
 800074a:	d0fb      	beq.n	8000744 <__early_init+0x54>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 800074c:	22a0      	movs	r2, #160	; 0xa0
 800074e:	0392      	lsls	r2, r2, #14
 8000750:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8000752:	2200      	movs	r2, #0
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8000754:	2180      	movs	r1, #128	; 0x80
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000756:	2080      	movs	r0, #128	; 0x80
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE;
  RCC->CFGR2 = STM32_PREDIV;
 8000758:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
#else
  RCC->CFGR3 = STM32_USBSW  | STM32_CECSW  | STM32_I2C1SW | STM32_USART1SW;
 800075a:	631a      	str	r2, [r3, #48]	; 0x30
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 800075c:	681a      	ldr	r2, [r3, #0]
 800075e:	0449      	lsls	r1, r1, #17
 8000760:	430a      	orrs	r2, r1
 8000762:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8000764:	0480      	lsls	r0, r0, #18
 8000766:	6819      	ldr	r1, [r3, #0]
 8000768:	4a0a      	ldr	r2, [pc, #40]	; (8000794 <__early_init+0xa4>)
 800076a:	4201      	tst	r1, r0
 800076c:	d0fb      	beq.n	8000766 <__early_init+0x76>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 800076e:	2111      	movs	r1, #17
 8000770:	4b09      	ldr	r3, [pc, #36]	; (8000798 <__early_init+0xa8>)

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000772:	200c      	movs	r0, #12
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8000774:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8000776:	2302      	movs	r3, #2
 8000778:	6851      	ldr	r1, [r2, #4]
 800077a:	430b      	orrs	r3, r1
 800077c:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800077e:	6853      	ldr	r3, [r2, #4]
 8000780:	4904      	ldr	r1, [pc, #16]	; (8000794 <__early_init+0xa4>)
 8000782:	4003      	ands	r3, r0
 8000784:	2b08      	cmp	r3, #8
 8000786:	d1fa      	bne.n	800077e <__early_init+0x8e>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000788:	698a      	ldr	r2, [r1, #24]
 800078a:	3b07      	subs	r3, #7
 800078c:	4313      	orrs	r3, r2
 800078e:	618b      	str	r3, [r1, #24]
 *          and before any other initialization.
 */
void __early_init(void) {

  stm32_clock_init();
}
 8000790:	4770      	bx	lr
 8000792:	46c0      	nop			; (mov r8, r8)
 8000794:	40021000 	.word	0x40021000
 8000798:	40022000 	.word	0x40022000
 800079c:	00000000 	.word	0x00000000

080007a0 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 80007a0:	b510      	push	{r4, lr}
 80007a2:	0003      	movs	r3, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007a4:	b672      	cpsid	i
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 80007a6:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80007a8:	2800      	cmp	r0, #0
 80007aa:	d003      	beq.n	80007b4 <chPoolAlloc+0x14>
    mp->mp_next = mp->mp_next->ph_next;
 80007ac:	6802      	ldr	r2, [r0, #0]
 80007ae:	601a      	str	r2, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80007b0:	b662      	cpsie	i
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 80007b2:	bd10      	pop	{r4, pc}
  objp = mp->mp_next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->mp_next = mp->mp_next->ph_next;
  }
  else if (mp->mp_provider != NULL) {
 80007b4:	689a      	ldr	r2, [r3, #8]
 80007b6:	2a00      	cmp	r2, #0
 80007b8:	d0fa      	beq.n	80007b0 <chPoolAlloc+0x10>
    objp = mp->mp_provider(mp->mp_object_size);
 80007ba:	6858      	ldr	r0, [r3, #4]
 80007bc:	4790      	blx	r2
 80007be:	e7f7      	b.n	80007b0 <chPoolAlloc+0x10>

080007c0 <chEvtUnregister>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007c0:	b672      	cpsid	i
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80007c2:	0002      	movs	r2, r0
 80007c4:	e002      	b.n	80007cc <chEvtUnregister+0xc>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
 80007c6:	428b      	cmp	r3, r1
 80007c8:	d005      	beq.n	80007d6 <chEvtUnregister+0x16>
 80007ca:	001a      	movs	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80007cc:	6813      	ldr	r3, [r2, #0]
 80007ce:	4298      	cmp	r0, r3
 80007d0:	d1f9      	bne.n	80007c6 <chEvtUnregister+0x6>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80007d2:	b662      	cpsie	i
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
}
 80007d4:	4770      	bx	lr
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->el_next == elp) {
      p->el_next = elp->el_next;
 80007d6:	680b      	ldr	r3, [r1, #0]
 80007d8:	6013      	str	r3, [r2, #0]
 80007da:	e7fa      	b.n	80007d2 <chEvtUnregister+0x12>
 80007dc:	0000      	movs	r0, r0
	...

080007e0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 80007e0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80007e2:	b672      	cpsid	i
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 80007e4:	4c0e      	ldr	r4, [pc, #56]	; (8000820 <chThdYield+0x40>)
 80007e6:	6820      	ldr	r0, [r4, #0]
 80007e8:	69a1      	ldr	r1, [r4, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 80007ea:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 80007ec:	688a      	ldr	r2, [r1, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 80007ee:	4293      	cmp	r3, r2
 80007f0:	d201      	bcs.n	80007f6 <chThdYield+0x16>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80007f2:	b662      	cpsie	i

  chSysLock();
  chSchDoYieldS();
  chSysUnlock();
}
 80007f4:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80007f6:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80007f8:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80007fa:	6023      	str	r3, [r4, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80007fc:	61a0      	str	r0, [r4, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80007fe:	2401      	movs	r4, #1
 8000800:	7704      	strb	r4, [r0, #28]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000802:	2400      	movs	r4, #0
 8000804:	770c      	strb	r4, [r1, #28]
 8000806:	e000      	b.n	800080a <chThdYield+0x2a>
 8000808:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 800080a:	689c      	ldr	r4, [r3, #8]
 800080c:	42a2      	cmp	r2, r4
 800080e:	d9fb      	bls.n	8000808 <chThdYield+0x28>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000810:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000812:	600b      	str	r3, [r1, #0]
  tp->p_prev = cp->p_prev;
 8000814:	604a      	str	r2, [r1, #4]
  tp->p_prev->p_next = tp;
 8000816:	6011      	str	r1, [r2, #0]
  cp->p_prev = tp;
 8000818:	6059      	str	r1, [r3, #4]
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 800081a:	f7ff fcb9 	bl	8000190 <_port_switch>
 800081e:	e7e8      	b.n	80007f2 <chThdYield+0x12>
 8000820:	20000ac0 	.word	0x20000ac0
	...

08000830 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000830:	b510      	push	{r4, lr}
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 8000832:	f7ff fe3d 	bl	80004b0 <chSchDoRescheduleAhead>
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000836:	bd10      	pop	{r4, pc}
	...

08000840 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000840:	4b05      	ldr	r3, [pc, #20]	; (8000858 <chSchRescheduleS+0x18>)
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000842:	b510      	push	{r4, lr}
 8000844:	681a      	ldr	r2, [r3, #0]
 8000846:	699b      	ldr	r3, [r3, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000848:	6892      	ldr	r2, [r2, #8]
 800084a:	689b      	ldr	r3, [r3, #8]
 800084c:	429a      	cmp	r2, r3
 800084e:	d901      	bls.n	8000854 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
 8000850:	f7ff fe2e 	bl	80004b0 <chSchDoRescheduleAhead>
  }
}
 8000854:	bd10      	pop	{r4, pc}
 8000856:	46c0      	nop			; (mov r8, r8)
 8000858:	20000ac0 	.word	0x20000ac0
 800085c:	00000000 	.word	0x00000000

08000860 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8000860:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000862:	b672      	cpsid	i

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 8000864:	4b07      	ldr	r3, [pc, #28]	; (8000884 <chThdSetPriority+0x24>)
 8000866:	699b      	ldr	r3, [r3, #24]
 8000868:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 800086a:	689a      	ldr	r2, [r3, #8]
 800086c:	4294      	cmp	r4, r2
 800086e:	d001      	beq.n	8000874 <chThdSetPriority+0x14>
 8000870:	4282      	cmp	r2, r0
 8000872:	d200      	bcs.n	8000876 <chThdSetPriority+0x16>
    currp->p_prio = newprio;
 8000874:	6098      	str	r0, [r3, #8]
  }
  currp->p_realprio = newprio;
 8000876:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 8000878:	f7ff ffe2 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800087c:	b662      	cpsie	i
  chSysUnlock();

  return oldprio;
}
 800087e:	0020      	movs	r0, r4
 8000880:	bd10      	pop	{r4, pc}
 8000882:	46c0      	nop			; (mov r8, r8)
 8000884:	20000ac0 	.word	0x20000ac0
	...

08000890 <chSchWakeupS>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000890:	4b12      	ldr	r3, [pc, #72]	; (80008dc <chSchWakeupS+0x4c>)
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000892:	6201      	str	r1, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000894:	6999      	ldr	r1, [r3, #24]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000896:	b570      	push	{r4, r5, r6, lr}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000898:	6882      	ldr	r2, [r0, #8]
 800089a:	688c      	ldr	r4, [r1, #8]
 800089c:	42a2      	cmp	r2, r4
 800089e:	d80b      	bhi.n	80008b8 <chSchWakeupS+0x28>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80008a0:	2100      	movs	r1, #0
 80008a2:	7701      	strb	r1, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80008a4:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80008a6:	6899      	ldr	r1, [r3, #8]
 80008a8:	428a      	cmp	r2, r1
 80008aa:	d9fb      	bls.n	80008a4 <chSchWakeupS+0x14>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80008ac:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80008ae:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80008b0:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 80008b2:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80008b4:	6058      	str	r0, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80008b6:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80008b8:	2200      	movs	r2, #0
 80008ba:	770a      	strb	r2, [r1, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80008bc:	001a      	movs	r2, r3
  do {
    cp = cp->p_next;
 80008be:	6812      	ldr	r2, [r2, #0]
  } while (cp->p_prio >= tp->p_prio);
 80008c0:	6895      	ldr	r5, [r2, #8]
 80008c2:	42ac      	cmp	r4, r5
 80008c4:	d9fb      	bls.n	80008be <chSchWakeupS+0x2e>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80008c6:	6854      	ldr	r4, [r2, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80008c8:	600a      	str	r2, [r1, #0]
  tp->p_prev = cp->p_prev;
 80008ca:	604c      	str	r4, [r1, #4]
  tp->p_prev->p_next = tp;
 80008cc:	6021      	str	r1, [r4, #0]
  cp->p_prev = tp;
 80008ce:	6051      	str	r1, [r2, #4]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80008d0:	6198      	str	r0, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80008d2:	2301      	movs	r3, #1
 80008d4:	7703      	strb	r3, [r0, #28]
    chSysSwitch(ntp, otp);
 80008d6:	f7ff fc5b 	bl	8000190 <_port_switch>
 80008da:	e7ec      	b.n	80008b6 <chSchWakeupS+0x26>
 80008dc:	20000ac0 	.word	0x20000ac0

080008e0 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 80008e0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80008e2:	b672      	cpsid	i
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
 80008e4:	6883      	ldr	r3, [r0, #8]
 80008e6:	3301      	adds	r3, #1
 80008e8:	6083      	str	r3, [r0, #8]
 80008ea:	2b00      	cmp	r3, #0
 80008ec:	dd01      	ble.n	80008f2 <chSemSignal+0x12>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80008ee:	b662      	cpsie	i
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
  }
  chSysUnlock();
}
 80008f0:	bd10      	pop	{r4, pc}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80008f2:	6803      	ldr	r3, [r0, #0]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->s_cnt <= (cnt_t)0) {
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 80008f4:	2100      	movs	r1, #0

  tqp->p_next = tp->p_next;
 80008f6:	681a      	ldr	r2, [r3, #0]
 80008f8:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80008fa:	6050      	str	r0, [r2, #4]
 80008fc:	0018      	movs	r0, r3
 80008fe:	f7ff ffc7 	bl	8000890 <chSchWakeupS>
 8000902:	e7f4      	b.n	80008ee <chSemSignal+0xe>
	...

08000910 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 8000910:	b510      	push	{r4, lr}
 8000912:	0004      	movs	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000914:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000916:	3924      	subs	r1, #36	; 0x24
 8000918:	1841      	adds	r1, r0, r1
 800091a:	60c1      	str	r1, [r0, #12]
 800091c:	610b      	str	r3, [r1, #16]
 800091e:	9b02      	ldr	r3, [sp, #8]
 8000920:	614b      	str	r3, [r1, #20]
 8000922:	4b0f      	ldr	r3, [pc, #60]	; (8000960 <chThdCreateStatic+0x50>)
 8000924:	620b      	str	r3, [r1, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000926:	2302      	movs	r3, #2
 8000928:	7703      	strb	r3, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800092a:	2300      	movs	r3, #0
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800092c:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 800092e:	63c2      	str	r2, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000930:	2201      	movs	r2, #1
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000932:	7743      	strb	r3, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000934:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8000936:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8000938:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 800093a:	4b0a      	ldr	r3, [pc, #40]	; (8000964 <chThdCreateStatic+0x54>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800093c:	7782      	strb	r2, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800093e:	695a      	ldr	r2, [r3, #20]
 8000940:	6103      	str	r3, [r0, #16]
 8000942:	6142      	str	r2, [r0, #20]
 8000944:	6110      	str	r0, [r2, #16]
 8000946:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8000948:	0003      	movs	r3, r0
 800094a:	3324      	adds	r3, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800094c:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800094e:	3304      	adds	r3, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000950:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8000952:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 8000954:	2100      	movs	r1, #0
 8000956:	f7ff ff9b 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800095a:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800095c:	0020      	movs	r0, r4
 800095e:	bd10      	pop	{r4, pc}
 8000960:	080001b1 	.word	0x080001b1
 8000964:	20000ac0 	.word	0x20000ac0
	...

08000970 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000970:	4b06      	ldr	r3, [pc, #24]	; (800098c <chSchGoSleepS+0x1c>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000972:	b510      	push	{r4, lr}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000974:	6999      	ldr	r1, [r3, #24]
  otp->p_state = newstate;
 8000976:	7708      	strb	r0, [r1, #28]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000978:	6818      	ldr	r0, [r3, #0]

  tqp->p_next = tp->p_next;
 800097a:	6802      	ldr	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800097c:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800097e:	601a      	str	r2, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000980:	6198      	str	r0, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000982:	2301      	movs	r3, #1
 8000984:	7703      	strb	r3, [r0, #28]
  chSysSwitch(currp, otp);
 8000986:	f7ff fc03 	bl	8000190 <_port_switch>
}
 800098a:	bd10      	pop	{r4, pc}
 800098c:	20000ac0 	.word	0x20000ac0

08000990 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8000990:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000992:	b672      	cpsid	i
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 8000994:	4c0a      	ldr	r4, [pc, #40]	; (80009c0 <chMsgWait+0x30>)
 8000996:	69a3      	ldr	r3, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8000998:	001a      	movs	r2, r3
 800099a:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800099c:	3228      	adds	r2, #40	; 0x28
 800099e:	4290      	cmp	r0, r2
 80009a0:	d006      	beq.n	80009b0 <chMsgWait+0x20>
 80009a2:	6801      	ldr	r1, [r0, #0]
 80009a4:	6299      	str	r1, [r3, #40]	; 0x28
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
  tp->p_state = CH_STATE_SNDMSG;
 80009a6:	230d      	movs	r3, #13
  tqp->p_next->p_prev = (thread_t *)tqp;
 80009a8:	604a      	str	r2, [r1, #4]
 80009aa:	7703      	strb	r3, [r0, #28]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009ac:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 80009ae:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 80009b0:	200e      	movs	r0, #14
 80009b2:	f7ff ffdd 	bl	8000970 <chSchGoSleepS>
 80009b6:	69a3      	ldr	r3, [r4, #24]
 80009b8:	001a      	movs	r2, r3
 80009ba:	6a98      	ldr	r0, [r3, #40]	; 0x28
 80009bc:	3228      	adds	r2, #40	; 0x28
 80009be:	e7f0      	b.n	80009a2 <chMsgWait+0x12>
 80009c0:	20000ac0 	.word	0x20000ac0
	...

080009d0 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 80009d0:	b510      	push	{r4, lr}
 80009d2:	0002      	movs	r2, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80009d4:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80009d6:	6883      	ldr	r3, [r0, #8]
 80009d8:	3b01      	subs	r3, #1
 80009da:	6083      	str	r3, [r0, #8]
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->p_u.rdymsg;
  }

  return MSG_OK;
 80009dc:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80009de:	2b00      	cmp	r3, #0
 80009e0:	db01      	blt.n	80009e6 <chSemWait+0x16>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80009e2:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 80009e4:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 80009e6:	4c07      	ldr	r4, [pc, #28]	; (8000a04 <chSemWait+0x34>)
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 80009e8:	3005      	adds	r0, #5
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    currp->p_u.wtsemp = sp;
 80009ea:	69a3      	ldr	r3, [r4, #24]
 80009ec:	621a      	str	r2, [r3, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80009ee:	6851      	ldr	r1, [r2, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80009f0:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80009f2:	6059      	str	r1, [r3, #4]
  tp->p_prev->p_next = tp;
 80009f4:	600b      	str	r3, [r1, #0]
  tqp->p_prev = tp;
 80009f6:	6053      	str	r3, [r2, #4]
    sem_insert(currp, &sp->s_queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 80009f8:	f7ff ffba 	bl	8000970 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 80009fc:	69a3      	ldr	r3, [r4, #24]
 80009fe:	6a18      	ldr	r0, [r3, #32]
 8000a00:	e7ef      	b.n	80009e2 <chSemWait+0x12>
 8000a02:	46c0      	nop			; (mov r8, r8)
 8000a04:	20000ac0 	.word	0x20000ac0
	...

08000a10 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000a10:	2300      	movs	r3, #0
 8000a12:	6882      	ldr	r2, [r0, #8]
 8000a14:	7703      	strb	r3, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000a16:	4b05      	ldr	r3, [pc, #20]	; (8000a2c <chSchReadyI+0x1c>)
  do {
    cp = cp->p_next;
 8000a18:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000a1a:	6899      	ldr	r1, [r3, #8]
 8000a1c:	4291      	cmp	r1, r2
 8000a1e:	d2fb      	bcs.n	8000a18 <chSchReadyI+0x8>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000a20:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000a22:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000a24:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 8000a26:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8000a28:	6058      	str	r0, [r3, #4]

  return tp;
}
 8000a2a:	4770      	bx	lr
 8000a2c:	20000ac0 	.word	0x20000ac0

08000a30 <chIQPutI>:
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000a30:	6943      	ldr	r3, [r0, #20]
 8000a32:	6982      	ldr	r2, [r0, #24]
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8000a34:	b510      	push	{r4, lr}
 8000a36:	4293      	cmp	r3, r2
 8000a38:	d01d      	beq.n	8000a76 <chIQPutI+0x46>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000a3a:	6882      	ldr	r2, [r0, #8]
 8000a3c:	3201      	adds	r2, #1
 8000a3e:	6082      	str	r2, [r0, #8]
  *iqp->q_wrptr++ = b;
 8000a40:	1c5a      	adds	r2, r3, #1
 8000a42:	6142      	str	r2, [r0, #20]
 8000a44:	7019      	strb	r1, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000a46:	6943      	ldr	r3, [r0, #20]
 8000a48:	6902      	ldr	r2, [r0, #16]
 8000a4a:	4293      	cmp	r3, r2
 8000a4c:	d20c      	bcs.n	8000a68 <chIQPutI+0x38>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000a4e:	6803      	ldr	r3, [r0, #0]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000a50:	4298      	cmp	r0, r3
 8000a52:	d00e      	beq.n	8000a72 <chIQPutI+0x42>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000a54:	681a      	ldr	r2, [r3, #0]
 8000a56:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000a58:	6050      	str	r0, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000a5a:	2200      	movs	r2, #0
  (void) chSchReadyI(tp);
 8000a5c:	0018      	movs	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000a5e:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000a60:	f7ff ffd6 	bl	8000a10 <chSchReadyI>
    iqp->q_wrptr = iqp->q_buffer;
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8000a64:	2000      	movs	r0, #0
}
 8000a66:	bd10      	pop	{r4, pc}
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 8000a68:	68c3      	ldr	r3, [r0, #12]
 8000a6a:	6143      	str	r3, [r0, #20]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000a6c:	6803      	ldr	r3, [r0, #0]
 8000a6e:	4298      	cmp	r0, r3
 8000a70:	d1f0      	bne.n	8000a54 <chIQPutI+0x24>
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);

  return Q_OK;
 8000a72:	2000      	movs	r0, #0
 8000a74:	e7f7      	b.n	8000a66 <chIQPutI+0x36>
 8000a76:	6882      	ldr	r2, [r0, #8]
 8000a78:	2a00      	cmp	r2, #0
 8000a7a:	d0de      	beq.n	8000a3a <chIQPutI+0xa>
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
 8000a7c:	2004      	movs	r0, #4
 8000a7e:	4240      	negs	r0, r0
 8000a80:	e7f1      	b.n	8000a66 <chIQPutI+0x36>
 8000a82:	46c0      	nop			; (mov r8, r8)
	...

08000a90 <chOQGetI>:
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000a90:	6983      	ldr	r3, [r0, #24]
 8000a92:	6942      	ldr	r2, [r0, #20]
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 8000a94:	b510      	push	{r4, lr}
 8000a96:	429a      	cmp	r2, r3
 8000a98:	d018      	beq.n	8000acc <chOQGetI+0x3c>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000a9a:	6882      	ldr	r2, [r0, #8]
 8000a9c:	3201      	adds	r2, #1
 8000a9e:	6082      	str	r2, [r0, #8]
  b = *oqp->q_rdptr++;
 8000aa0:	1c5a      	adds	r2, r3, #1
 8000aa2:	6182      	str	r2, [r0, #24]
 8000aa4:	781c      	ldrb	r4, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 8000aa6:	6903      	ldr	r3, [r0, #16]
 8000aa8:	429a      	cmp	r2, r3
 8000aaa:	d20c      	bcs.n	8000ac6 <chOQGetI+0x36>
 8000aac:	6803      	ldr	r3, [r0, #0]
 8000aae:	4298      	cmp	r0, r3
 8000ab0:	d007      	beq.n	8000ac2 <chOQGetI+0x32>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000ab2:	681a      	ldr	r2, [r3, #0]
 8000ab4:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ab6:	6050      	str	r0, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000ab8:	2200      	movs	r2, #0
  (void) chSchReadyI(tp);
 8000aba:	0018      	movs	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000abc:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000abe:	f7ff ffa7 	bl	8000a10 <chSchReadyI>
    oqp->q_rdptr = oqp->q_buffer;
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);

  return (msg_t)b;
 8000ac2:	0020      	movs	r0, r4
}
 8000ac4:	bd10      	pop	{r4, pc}
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
    oqp->q_rdptr = oqp->q_buffer;
 8000ac6:	68c3      	ldr	r3, [r0, #12]
 8000ac8:	6183      	str	r3, [r0, #24]
 8000aca:	e7ef      	b.n	8000aac <chOQGetI+0x1c>
 8000acc:	6882      	ldr	r2, [r0, #8]
 8000ace:	2a00      	cmp	r2, #0
 8000ad0:	d0e3      	beq.n	8000a9a <chOQGetI+0xa>
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
 8000ad2:	2003      	movs	r0, #3
 8000ad4:	4240      	negs	r0, r0
 8000ad6:	e7f5      	b.n	8000ac4 <chOQGetI+0x34>
	...

08000ae0 <chMsgSend>:
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
  thread_t *ctp = currp;
 8000ae0:	4b0c      	ldr	r3, [pc, #48]	; (8000b14 <chMsgSend+0x34>)
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8000ae2:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 8000ae4:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ae6:	b672      	cpsid	i

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8000ae8:	0003      	movs	r3, r0
 8000aea:	3328      	adds	r3, #40	; 0x28
 8000aec:	6223      	str	r3, [r4, #32]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8000aee:	6023      	str	r3, [r4, #0]
  tp->p_prev = tqp->p_prev;
 8000af0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  thread_t *ctp = currp;

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->p_msg = msg;
 8000af2:	6321      	str	r1, [r4, #48]	; 0x30
 8000af4:	6063      	str	r3, [r4, #4]
  tp->p_prev->p_next = tp;
 8000af6:	601c      	str	r4, [r3, #0]
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
 8000af8:	7f03      	ldrb	r3, [r0, #28]
  tqp->p_prev = tp;
 8000afa:	62c4      	str	r4, [r0, #44]	; 0x2c
 8000afc:	2b0e      	cmp	r3, #14
 8000afe:	d005      	beq.n	8000b0c <chMsgSend+0x2c>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8000b00:	200c      	movs	r0, #12
 8000b02:	f7ff ff35 	bl	8000970 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8000b06:	6a20      	ldr	r0, [r4, #32]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b08:	b662      	cpsie	i
  chSysUnlock();

  return msg;
}
 8000b0a:	bd10      	pop	{r4, pc}
  chSysLock();
  ctp->p_msg = msg;
  ctp->p_u.wtobjp = &tp->p_msgqueue;
  msg_insert(ctp, &tp->p_msgqueue);
  if (tp->p_state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8000b0c:	f7ff ff80 	bl	8000a10 <chSchReadyI>
 8000b10:	e7f6      	b.n	8000b00 <chMsgSend+0x20>
 8000b12:	46c0      	nop			; (mov r8, r8)
 8000b14:	20000ac0 	.word	0x20000ac0
	...

08000b20 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8000b20:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000b22:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8000b24:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000b26:	7f03      	ldrb	r3, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000b28:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000b2a:	2b0a      	cmp	r3, #10
 8000b2c:	d00b      	beq.n	8000b46 <chEvtSignalI+0x26>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000b2e:	2b0b      	cmp	r3, #11
 8000b30:	d000      	beq.n	8000b34 <chEvtSignalI+0x14>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 8000b32:	bd10      	pop	{r4, pc}
  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000b34:	6a03      	ldr	r3, [r0, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000b36:	4019      	ands	r1, r3
 8000b38:	428b      	cmp	r3, r1
 8000b3a:	d1fa      	bne.n	8000b32 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000b3c:	2300      	movs	r3, #0
 8000b3e:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8000b40:	f7ff ff66 	bl	8000a10 <chSchReadyI>
 8000b44:	e7f5      	b.n	8000b32 <chEvtSignalI+0x12>
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000b46:	6a03      	ldr	r3, [r0, #32]
 8000b48:	420b      	tst	r3, r1
 8000b4a:	d0f2      	beq.n	8000b32 <chEvtSignalI+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000b4c:	2300      	movs	r3, #0
 8000b4e:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8000b50:	f7ff ff5e 	bl	8000a10 <chSchReadyI>
 8000b54:	e7ed      	b.n	8000b32 <chEvtSignalI+0x12>
 8000b56:	46c0      	nop			; (mov r8, r8)
	...

08000b60 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000b60:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000b62:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000b64:	0006      	movs	r6, r0
 8000b66:	000d      	movs	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000b68:	42a0      	cmp	r0, r4
 8000b6a:	d00e      	beq.n	8000b8a <chEvtBroadcastFlagsI+0x2a>
  /*lint -restore*/
    elp->el_flags |= flags;
 8000b6c:	68e3      	ldr	r3, [r4, #12]
 8000b6e:	432b      	orrs	r3, r5
 8000b70:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000b72:	2d00      	cmp	r5, #0
 8000b74:	d002      	beq.n	8000b7c <chEvtBroadcastFlagsI+0x1c>
 8000b76:	6922      	ldr	r2, [r4, #16]
 8000b78:	421a      	tst	r2, r3
 8000b7a:	d003      	beq.n	8000b84 <chEvtBroadcastFlagsI+0x24>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000b7c:	68a1      	ldr	r1, [r4, #8]
 8000b7e:	6860      	ldr	r0, [r4, #4]
 8000b80:	f7ff ffce 	bl	8000b20 <chEvtSignalI>
    }
    elp = elp->el_next;
 8000b84:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000b86:	42a6      	cmp	r6, r4
 8000b88:	d1f0      	bne.n	8000b6c <chEvtBroadcastFlagsI+0xc>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 8000b8a:	bd70      	pop	{r4, r5, r6, pc}
 8000b8c:	0000      	movs	r0, r0
	...

08000b90 <VectorAC>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000b90:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b92:	4645      	mov	r5, r8
 8000b94:	4657      	mov	r7, sl
 8000b96:	464e      	mov	r6, r9
 8000b98:	b4e0      	push	{r5, r6, r7}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000b9a:	4e3f      	ldr	r6, [pc, #252]	; (8000c98 <VectorAC+0x108>)
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {

  OSAL_IRQ_PROLOGUE();
 8000b9c:	46f0      	mov	r8, lr
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000b9e:	6f75      	ldr	r5, [r6, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 8000ba0:	682f      	ldr	r7, [r5, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 8000ba2:	69ec      	ldr	r4, [r5, #28]
  u->ICR = isr;
 8000ba4:	622c      	str	r4, [r5, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 8000ba6:	0723      	lsls	r3, r4, #28
 8000ba8:	d134      	bne.n	8000c14 <VectorAC+0x84>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8000baa:	05e3      	lsls	r3, r4, #23
 8000bac:	d42a      	bmi.n	8000c04 <VectorAC+0x74>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8000bae:	06a3      	lsls	r3, r4, #26
 8000bb0:	d417      	bmi.n	8000be2 <VectorAC+0x52>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8000bb2:	2380      	movs	r3, #128	; 0x80
 8000bb4:	423b      	tst	r3, r7
 8000bb6:	d001      	beq.n	8000bbc <VectorAC+0x2c>
 8000bb8:	4223      	tst	r3, r4
 8000bba:	d141      	bne.n	8000c40 <VectorAC+0xb0>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8000bbc:	0663      	lsls	r3, r4, #25
 8000bbe:	d508      	bpl.n	8000bd2 <VectorAC+0x42>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000bc0:	b672      	cpsid	i
 8000bc2:	6c73      	ldr	r3, [r6, #68]	; 0x44
 8000bc4:	6cb2      	ldr	r2, [r6, #72]	; 0x48
 8000bc6:	4293      	cmp	r3, r2
 8000bc8:	d046      	beq.n	8000c58 <VectorAC+0xc8>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000bca:	2340      	movs	r3, #64	; 0x40
 8000bcc:	439f      	bics	r7, r3
 8000bce:	602f      	str	r7, [r5, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000bd0:	b662      	cpsie	i

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8000bd2:	4640      	mov	r0, r8
 8000bd4:	f7ff fb9c 	bl	8000310 <_port_irq_epilogue>
}
 8000bd8:	bc1c      	pop	{r2, r3, r4}
 8000bda:	4690      	mov	r8, r2
 8000bdc:	4699      	mov	r9, r3
 8000bde:	46a2      	mov	sl, r4
 8000be0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000be2:	b672      	cpsid	i
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 8000be4:	8cab      	ldrh	r3, [r5, #36]	; 0x24
 8000be6:	b2db      	uxtb	r3, r3
 8000be8:	4699      	mov	r9, r3
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000bea:	6973      	ldr	r3, [r6, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000bec:	2b00      	cmp	r3, #0
 8000bee:	d03b      	beq.n	8000c68 <VectorAC+0xd8>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 8000bf0:	4b2a      	ldr	r3, [pc, #168]	; (8000c9c <VectorAC+0x10c>)
 8000bf2:	4649      	mov	r1, r9
 8000bf4:	0018      	movs	r0, r3
 8000bf6:	469a      	mov	sl, r3
 8000bf8:	f7ff ff1a 	bl	8000a30 <chIQPutI>
 8000bfc:	2800      	cmp	r0, #0
 8000bfe:	db38      	blt.n	8000c72 <VectorAC+0xe2>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c00:	b662      	cpsie	i
 8000c02:	e7d6      	b.n	8000bb2 <VectorAC+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c04:	b672      	cpsid	i
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000c06:	2180      	movs	r1, #128	; 0x80
 8000c08:	4825      	ldr	r0, [pc, #148]	; (8000ca0 <VectorAC+0x110>)
 8000c0a:	0089      	lsls	r1, r1, #2
 8000c0c:	f7ff ffa8 	bl	8000b60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c10:	b662      	cpsie	i
 8000c12:	e7cc      	b.n	8000bae <VectorAC+0x1e>
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
 8000c14:	0721      	lsls	r1, r4, #28
    sts |= SD_OVERRUN_ERROR;
 8000c16:	0fc9      	lsrs	r1, r1, #31
 8000c18:	01c9      	lsls	r1, r1, #7
  if (isr & USART_ISR_PE)
 8000c1a:	07e3      	lsls	r3, r4, #31
 8000c1c:	d501      	bpl.n	8000c22 <VectorAC+0x92>
    sts |= SD_PARITY_ERROR;
 8000c1e:	2320      	movs	r3, #32
 8000c20:	4319      	orrs	r1, r3
  if (isr & USART_ISR_FE)
 8000c22:	07a3      	lsls	r3, r4, #30
 8000c24:	d501      	bpl.n	8000c2a <VectorAC+0x9a>
    sts |= SD_FRAMING_ERROR;
 8000c26:	2340      	movs	r3, #64	; 0x40
 8000c28:	4319      	orrs	r1, r3
  if (isr & USART_ISR_NE)
 8000c2a:	0763      	lsls	r3, r4, #29
 8000c2c:	d502      	bpl.n	8000c34 <VectorAC+0xa4>
    sts |= SD_NOISE_ERROR;
 8000c2e:	2380      	movs	r3, #128	; 0x80
 8000c30:	005b      	lsls	r3, r3, #1
 8000c32:	4319      	orrs	r1, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c34:	b672      	cpsid	i
 8000c36:	481a      	ldr	r0, [pc, #104]	; (8000ca0 <VectorAC+0x110>)
 8000c38:	f7ff ff92 	bl	8000b60 <chEvtBroadcastFlagsI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c3c:	b662      	cpsie	i
 8000c3e:	e7b4      	b.n	8000baa <VectorAC+0x1a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c40:	b672      	cpsid	i

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
 8000c42:	4b18      	ldr	r3, [pc, #96]	; (8000ca4 <VectorAC+0x114>)
 8000c44:	0018      	movs	r0, r3
 8000c46:	4699      	mov	r9, r3
 8000c48:	f7ff ff22 	bl	8000a90 <chOQGetI>
    if (b < Q_OK) {
 8000c4c:	2800      	cmp	r0, #0
 8000c4e:	db16      	blt.n	8000c7e <VectorAC+0xee>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8000c50:	b280      	uxth	r0, r0
 8000c52:	8528      	strh	r0, [r5, #40]	; 0x28
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c54:	b662      	cpsie	i
 8000c56:	e7b1      	b.n	8000bbc <VectorAC+0x2c>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000c58:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8000c5a:	2b00      	cmp	r3, #0
 8000c5c:	d0b5      	beq.n	8000bca <VectorAC+0x3a>
 8000c5e:	1d30      	adds	r0, r6, #4
 8000c60:	2110      	movs	r1, #16
 8000c62:	f7ff ff7d 	bl	8000b60 <chEvtBroadcastFlagsI>
 8000c66:	e7b0      	b.n	8000bca <VectorAC+0x3a>
 8000c68:	1d30      	adds	r0, r6, #4
 8000c6a:	2104      	movs	r1, #4
 8000c6c:	f7ff ff78 	bl	8000b60 <chEvtBroadcastFlagsI>
 8000c70:	e7be      	b.n	8000bf0 <VectorAC+0x60>
 8000c72:	4650      	mov	r0, sl
 8000c74:	2180      	movs	r1, #128	; 0x80
 8000c76:	3808      	subs	r0, #8
 8000c78:	f7ff ff72 	bl	8000b60 <chEvtBroadcastFlagsI>
 8000c7c:	e7c0      	b.n	8000c00 <VectorAC+0x70>
 8000c7e:	4648      	mov	r0, r9
 8000c80:	2108      	movs	r1, #8
 8000c82:	382c      	subs	r0, #44	; 0x2c
 8000c84:	f7ff ff6c 	bl	8000b60 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000c88:	23c0      	movs	r3, #192	; 0xc0
 8000c8a:	003a      	movs	r2, r7
 8000c8c:	439a      	bics	r2, r3
 8000c8e:	3b80      	subs	r3, #128	; 0x80
 8000c90:	4313      	orrs	r3, r2
 8000c92:	602b      	str	r3, [r5, #0]
 8000c94:	e7de      	b.n	8000c54 <VectorAC+0xc4>
 8000c96:	46c0      	nop			; (mov r8, r8)
 8000c98:	2000098c 	.word	0x2000098c
 8000c9c:	20000998 	.word	0x20000998
 8000ca0:	20000990 	.word	0x20000990
 8000ca4:	200009bc 	.word	0x200009bc
	...

08000cb0 <chMtxUnlockAll>:
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8000cb0:	4b11      	ldr	r3, [pc, #68]	; (8000cf8 <chMtxUnlockAll+0x48>)
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 8000cb2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000cb4:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000cb6:	b672      	cpsid	i

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
 8000cb8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000cba:	2b00      	cmp	r3, #0
 8000cbc:	d01a      	beq.n	8000cf4 <chMtxUnlockAll+0x44>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8000cbe:	2500      	movs	r5, #0
 8000cc0:	e00b      	b.n	8000cda <chMtxUnlockAll+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000cc2:	6802      	ldr	r2, [r0, #0]
 8000cc4:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000cc6:	6053      	str	r3, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
        mp->m_next = tp->p_mtxlist;
 8000cc8:	6b82      	ldr	r2, [r0, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
        mp->m_owner = tp;
 8000cca:	6098      	str	r0, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 8000ccc:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 8000cce:	6383      	str	r3, [r0, #56]	; 0x38
        (void) chSchReadyI(tp);
 8000cd0:	f7ff fe9e 	bl	8000a10 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
      }
    } while (ctp->p_mtxlist != NULL);
 8000cd4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000cd6:	2b00      	cmp	r3, #0
 8000cd8:	d008      	beq.n	8000cec <chMtxUnlockAll+0x3c>

  chSysLock();
  if (ctp->p_mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->p_mtxlist;
      ctp->p_mtxlist = mp->m_next;
 8000cda:	68da      	ldr	r2, [r3, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000cdc:	6818      	ldr	r0, [r3, #0]
 8000cde:	63a2      	str	r2, [r4, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8000ce0:	4283      	cmp	r3, r0
 8000ce2:	d1ee      	bne.n	8000cc2 <chMtxUnlockAll+0x12>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8000ce4:	609d      	str	r5, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 8000ce6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8000ce8:	2b00      	cmp	r3, #0
 8000cea:	d1f6      	bne.n	8000cda <chMtxUnlockAll+0x2a>
    ctp->p_prio = ctp->p_realprio;
 8000cec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000cee:	60a3      	str	r3, [r4, #8]
    chSchRescheduleS();
 8000cf0:	f7ff fda6 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000cf4:	b662      	cpsie	i
  }
  chSysUnlock();
}
 8000cf6:	bd70      	pop	{r4, r5, r6, pc}
 8000cf8:	20000ac0 	.word	0x20000ac0
 8000cfc:	00000000 	.word	0x00000000

08000d00 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000d00:	4b11      	ldr	r3, [pc, #68]	; (8000d48 <chMtxUnlockS+0x48>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8000d02:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000d04:	699d      	ldr	r5, [r3, #24]
 8000d06:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000d08:	68c3      	ldr	r3, [r0, #12]
 8000d0a:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000d0c:	4284      	cmp	r4, r0
 8000d0e:	d018      	beq.n	8000d42 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000d10:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000d12:	2b00      	cmp	r3, #0
 8000d14:	d009      	beq.n	8000d2a <chMtxUnlockS+0x2a>
 8000d16:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000d18:	4293      	cmp	r3, r2
 8000d1a:	d003      	beq.n	8000d24 <chMtxUnlockS+0x24>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8000d1c:	6892      	ldr	r2, [r2, #8]
 8000d1e:	4291      	cmp	r1, r2
 8000d20:	d200      	bcs.n	8000d24 <chMtxUnlockS+0x24>
 8000d22:	0011      	movs	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000d24:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000d26:	2b00      	cmp	r3, #0
 8000d28:	d1f5      	bne.n	8000d16 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000d2a:	6823      	ldr	r3, [r4, #0]
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8000d2c:	60a9      	str	r1, [r5, #8]
 8000d2e:	6003      	str	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000d30:	6058      	str	r0, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000d32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000d34:	6084      	str	r4, [r0, #8]
      mp->m_next = tp->p_mtxlist;
 8000d36:	60c3      	str	r3, [r0, #12]
      tp->p_mtxlist = mp;
 8000d38:	63a0      	str	r0, [r4, #56]	; 0x38
      (void) chSchReadyI(tp);
 8000d3a:	0020      	movs	r0, r4
 8000d3c:	f7ff fe68 	bl	8000a10 <chSchReadyI>
      mp->m_owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8000d40:	bd70      	pop	{r4, r5, r6, pc}
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
      (void) chSchReadyI(tp);
    }
    else {
      mp->m_owner = NULL;
 8000d42:	2300      	movs	r3, #0
 8000d44:	60a3      	str	r3, [r4, #8]
 8000d46:	e7fb      	b.n	8000d40 <chMtxUnlockS+0x40>
 8000d48:	20000ac0 	.word	0x20000ac0
 8000d4c:	00000000 	.word	0x00000000

08000d50 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8000d50:	4b13      	ldr	r3, [pc, #76]	; (8000da0 <chMtxUnlock+0x50>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000d52:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000d54:	699d      	ldr	r5, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000d56:	b672      	cpsid	i
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000d58:	68c3      	ldr	r3, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000d5a:	6804      	ldr	r4, [r0, #0]
 8000d5c:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000d5e:	4284      	cmp	r4, r0
 8000d60:	d01b      	beq.n	8000d9a <chMtxUnlock+0x4a>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000d62:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000d64:	2b00      	cmp	r3, #0
 8000d66:	d009      	beq.n	8000d7c <chMtxUnlock+0x2c>
 8000d68:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000d6a:	4293      	cmp	r3, r2
 8000d6c:	d003      	beq.n	8000d76 <chMtxUnlock+0x26>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8000d6e:	6892      	ldr	r2, [r2, #8]
 8000d70:	4291      	cmp	r1, r2
 8000d72:	d200      	bcs.n	8000d76 <chMtxUnlock+0x26>
 8000d74:	0011      	movs	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000d76:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000d78:	2b00      	cmp	r3, #0
 8000d7a:	d1f5      	bne.n	8000d68 <chMtxUnlock+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000d7c:	6823      	ldr	r3, [r4, #0]
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8000d7e:	60a9      	str	r1, [r5, #8]
 8000d80:	6003      	str	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000d82:	6058      	str	r0, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000d84:	6ba3      	ldr	r3, [r4, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000d86:	6084      	str	r4, [r0, #8]
      mp->m_next = tp->p_mtxlist;
 8000d88:	60c3      	str	r3, [r0, #12]
      tp->p_mtxlist = mp;
 8000d8a:	63a0      	str	r0, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000d8c:	0020      	movs	r0, r4
 8000d8e:	f7ff fe3f 	bl	8000a10 <chSchReadyI>
      chSchRescheduleS();
 8000d92:	f7ff fd55 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d96:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 8000d98:	bd70      	pop	{r4, r5, r6, pc}
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->m_owner = NULL;
 8000d9a:	2300      	movs	r3, #0
 8000d9c:	60a3      	str	r3, [r4, #8]
 8000d9e:	e7fa      	b.n	8000d96 <chMtxUnlock+0x46>
 8000da0:	20000ac0 	.word	0x20000ac0
	...

08000db0 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000db0:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000db2:	4b2f      	ldr	r3, [pc, #188]	; (8000e70 <chMtxLockS+0xc0>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8000db4:	0005      	movs	r5, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000db6:	6880      	ldr	r0, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000db8:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000dba:	2800      	cmp	r0, #0
 8000dbc:	d053      	beq.n	8000e66 <chMtxLockS+0xb6>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000dbe:	68a2      	ldr	r2, [r4, #8]
 8000dc0:	6883      	ldr	r3, [r0, #8]
 8000dc2:	429a      	cmp	r2, r3
 8000dc4:	d907      	bls.n	8000dd6 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000dc6:	7f03      	ldrb	r3, [r0, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8000dc8:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000dca:	2b06      	cmp	r3, #6
 8000dcc:	d032      	beq.n	8000e34 <chMtxLockS+0x84>
 8000dce:	2b07      	cmp	r3, #7
 8000dd0:	d01c      	beq.n	8000e0c <chMtxLockS+0x5c>
 8000dd2:	2b00      	cmp	r3, #0
 8000dd4:	d012      	beq.n	8000dfc <chMtxLockS+0x4c>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000dd6:	002b      	movs	r3, r5
 8000dd8:	e003      	b.n	8000de2 <chMtxLockS+0x32>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000dda:	689a      	ldr	r2, [r3, #8]
 8000ddc:	68a1      	ldr	r1, [r4, #8]
 8000dde:	428a      	cmp	r2, r1
 8000de0:	d302      	bcc.n	8000de8 <chMtxLockS+0x38>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000de2:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000de4:	429d      	cmp	r5, r3
 8000de6:	d1f8      	bne.n	8000dda <chMtxLockS+0x2a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000de8:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000dea:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8000dec:	6062      	str	r2, [r4, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 8000dee:	2006      	movs	r0, #6
  tp->p_prev->p_next = tp;
 8000df0:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8000df2:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8000df4:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8000df6:	f7ff fdbb 	bl	8000970 <chSchGoSleepS>
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8000dfa:	bd70      	pop	{r4, r5, r6, pc}
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000dfc:	6843      	ldr	r3, [r0, #4]
 8000dfe:	6802      	ldr	r2, [r0, #0]
 8000e00:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000e02:	6802      	ldr	r2, [r0, #0]
 8000e04:	6053      	str	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8000e06:	f7ff fe03 	bl	8000a10 <chSchReadyI>
 8000e0a:	e7e4      	b.n	8000dd6 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000e0c:	6843      	ldr	r3, [r0, #4]
 8000e0e:	6801      	ldr	r1, [r0, #0]
 8000e10:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000e12:	6801      	ldr	r1, [r0, #0]
 8000e14:	604b      	str	r3, [r1, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000e16:	6a01      	ldr	r1, [r0, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000e18:	000b      	movs	r3, r1
 8000e1a:	e002      	b.n	8000e22 <chMtxLockS+0x72>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e1c:	689e      	ldr	r6, [r3, #8]
 8000e1e:	42b2      	cmp	r2, r6
 8000e20:	d802      	bhi.n	8000e28 <chMtxLockS+0x78>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000e22:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e24:	4299      	cmp	r1, r3
 8000e26:	d1f9      	bne.n	8000e1c <chMtxLockS+0x6c>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000e28:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000e2a:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000e2c:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 8000e2e:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8000e30:	6058      	str	r0, [r3, #4]
 8000e32:	e7d0      	b.n	8000dd6 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000e34:	6843      	ldr	r3, [r0, #4]
 8000e36:	6801      	ldr	r1, [r0, #0]
 8000e38:	6019      	str	r1, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000e3a:	6801      	ldr	r1, [r0, #0]
 8000e3c:	604b      	str	r3, [r1, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8000e3e:	6a01      	ldr	r1, [r0, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8000e40:	000b      	movs	r3, r1
 8000e42:	e002      	b.n	8000e4a <chMtxLockS+0x9a>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e44:	689e      	ldr	r6, [r3, #8]
 8000e46:	42b2      	cmp	r2, r6
 8000e48:	d802      	bhi.n	8000e50 <chMtxLockS+0xa0>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8000e4a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8000e4c:	4299      	cmp	r1, r3
 8000e4e:	d1f9      	bne.n	8000e44 <chMtxLockS+0x94>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000e50:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8000e52:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000e54:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 8000e56:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8000e58:	6058      	str	r0, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 8000e5a:	6888      	ldr	r0, [r1, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000e5c:	68a2      	ldr	r2, [r4, #8]
 8000e5e:	6883      	ldr	r3, [r0, #8]
 8000e60:	4293      	cmp	r3, r2
 8000e62:	d3b0      	bcc.n	8000dc6 <chMtxLockS+0x16>
 8000e64:	e7b7      	b.n	8000dd6 <chMtxLockS+0x26>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8000e66:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8000e68:	60ac      	str	r4, [r5, #8]
    mp->m_next = ctp->p_mtxlist;
 8000e6a:	60eb      	str	r3, [r5, #12]
    ctp->p_mtxlist = mp;
 8000e6c:	63a5      	str	r5, [r4, #56]	; 0x38
 8000e6e:	e7c4      	b.n	8000dfa <chMtxLockS+0x4a>
 8000e70:	20000ac0 	.word	0x20000ac0
	...

08000e80 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8000e80:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e82:	b672      	cpsid	i

  chSysLock();
  chMtxLockS(mp);
 8000e84:	f7ff ff94 	bl	8000db0 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e88:	b662      	cpsie	i
  chSysUnlock();
}
 8000e8a:	bd10      	pop	{r4, pc}
 8000e8c:	0000      	movs	r0, r0
	...

08000e90 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8000e90:	b570      	push	{r4, r5, r6, lr}
 8000e92:	0004      	movs	r4, r0
 8000e94:	000e      	movs	r6, r1
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8000e96:	2800      	cmp	r0, #0
 8000e98:	d018      	beq.n	8000ecc <chHeapStatus+0x3c>
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8000e9a:	0025      	movs	r5, r4
 8000e9c:	3510      	adds	r5, #16
 8000e9e:	0028      	movs	r0, r5
 8000ea0:	f7ff ffee 	bl	8000e80 <chMtxLock>
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8000ea4:	68a3      	ldr	r3, [r4, #8]
 8000ea6:	2200      	movs	r2, #0
 8000ea8:	2400      	movs	r4, #0
 8000eaa:	2b00      	cmp	r3, #0
 8000eac:	d006      	beq.n	8000ebc <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
 8000eae:	6859      	ldr	r1, [r3, #4]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8000eb0:	681b      	ldr	r3, [r3, #0]
    sz += qp->h.u.next->h.size;
 8000eb2:	468c      	mov	ip, r1
    n++;
 8000eb4:	3401      	adds	r4, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8000eb6:	4462      	add	r2, ip

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8000eb8:	2b00      	cmp	r3, #0
 8000eba:	d1f8      	bne.n	8000eae <chHeapStatus+0x1e>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 8000ebc:	2e00      	cmp	r6, #0
 8000ebe:	d000      	beq.n	8000ec2 <chHeapStatus+0x32>
    *sizep = sz;
 8000ec0:	6032      	str	r2, [r6, #0]
  }
  H_UNLOCK(heapp);
 8000ec2:	0028      	movs	r0, r5
 8000ec4:	f7ff ff44 	bl	8000d50 <chMtxUnlock>

  return n;
}
 8000ec8:	0020      	movs	r0, r4
 8000eca:	bd70      	pop	{r4, r5, r6, pc}
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
    heapp = &default_heap;
 8000ecc:	4c00      	ldr	r4, [pc, #0]	; (8000ed0 <chHeapStatus+0x40>)
 8000ece:	e7e4      	b.n	8000e9a <chHeapStatus+0xa>
 8000ed0:	20000a08 	.word	0x20000a08
	...

08000ee0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8000ee0:	b570      	push	{r4, r5, r6, lr}
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8000ee2:	3808      	subs	r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8000ee4:	6806      	ldr	r6, [r0, #0]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8000ee6:	0004      	movs	r4, r0
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000ee8:	0035      	movs	r5, r6

  H_LOCK(heapp);
 8000eea:	3610      	adds	r6, #16

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000eec:	3508      	adds	r5, #8

  H_LOCK(heapp);
 8000eee:	0030      	movs	r0, r6
 8000ef0:	f7ff ffc6 	bl	8000e80 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8000ef4:	002b      	movs	r3, r5

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8000ef6:	42ab      	cmp	r3, r5
 8000ef8:	d004      	beq.n	8000f04 <chHeapFree+0x24>
 8000efa:	42a3      	cmp	r3, r4
 8000efc:	d302      	bcc.n	8000f04 <chHeapFree+0x24>
 8000efe:	681b      	ldr	r3, [r3, #0]
 8000f00:	42ab      	cmp	r3, r5
 8000f02:	d1fa      	bne.n	8000efa <chHeapFree+0x1a>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8000f04:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8000f06:	2a00      	cmp	r2, #0
 8000f08:	d003      	beq.n	8000f12 <chHeapFree+0x32>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8000f0a:	4294      	cmp	r4, r2
 8000f0c:	d301      	bcc.n	8000f12 <chHeapFree+0x32>
 8000f0e:	0013      	movs	r3, r2
 8000f10:	e7f1      	b.n	8000ef6 <chHeapFree+0x16>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8000f12:	6022      	str	r2, [r4, #0]
      qp->h.u.next = hp;
 8000f14:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8000f16:	6861      	ldr	r1, [r4, #4]
 8000f18:	6820      	ldr	r0, [r4, #0]
 8000f1a:	000a      	movs	r2, r1
 8000f1c:	3208      	adds	r2, #8
 8000f1e:	18a2      	adds	r2, r4, r2
 8000f20:	4282      	cmp	r2, r0
 8000f22:	d009      	beq.n	8000f38 <chHeapFree+0x58>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8000f24:	6859      	ldr	r1, [r3, #4]
 8000f26:	000a      	movs	r2, r1
 8000f28:	3208      	adds	r2, #8
 8000f2a:	189a      	adds	r2, r3, r2
 8000f2c:	4294      	cmp	r4, r2
 8000f2e:	d010      	beq.n	8000f52 <chHeapFree+0x72>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8000f30:	0030      	movs	r0, r6
 8000f32:	f7ff ff0d 	bl	8000d50 <chMtxUnlock>

  return;
}
 8000f36:	bd70      	pop	{r4, r5, r6, pc}
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8000f38:	6850      	ldr	r0, [r2, #4]
 8000f3a:	4684      	mov	ip, r0
 8000f3c:	4461      	add	r1, ip
 8000f3e:	3108      	adds	r1, #8
 8000f40:	6061      	str	r1, [r4, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8000f42:	6812      	ldr	r2, [r2, #0]
 8000f44:	6022      	str	r2, [r4, #0]
      }
      if ((LIMIT(qp) == hp)) {
 8000f46:	6859      	ldr	r1, [r3, #4]
 8000f48:	000a      	movs	r2, r1
 8000f4a:	3208      	adds	r2, #8
 8000f4c:	189a      	adds	r2, r3, r2
 8000f4e:	4294      	cmp	r4, r2
 8000f50:	d1ee      	bne.n	8000f30 <chHeapFree+0x50>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8000f52:	6862      	ldr	r2, [r4, #4]
 8000f54:	4694      	mov	ip, r2
 8000f56:	4461      	add	r1, ip
 8000f58:	3108      	adds	r1, #8
 8000f5a:	6059      	str	r1, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8000f5c:	6822      	ldr	r2, [r4, #0]
 8000f5e:	601a      	str	r2, [r3, #0]
 8000f60:	e7e6      	b.n	8000f30 <chHeapFree+0x50>
 8000f62:	46c0      	nop			; (mov r8, r8)
	...

08000f70 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8000f70:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f72:	b672      	cpsid	i
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 8000f74:	7f83      	ldrb	r3, [r0, #30]
 8000f76:	3b01      	subs	r3, #1
 8000f78:	b2db      	uxtb	r3, r3
 8000f7a:	7783      	strb	r3, [r0, #30]
  refs = tp->p_refs;

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8000f7c:	2b00      	cmp	r3, #0
 8000f7e:	d102      	bne.n	8000f86 <chThdRelease+0x16>
 8000f80:	7f03      	ldrb	r3, [r0, #28]
 8000f82:	2b0f      	cmp	r3, #15
 8000f84:	d001      	beq.n	8000f8a <chThdRelease+0x1a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000f86:	b662      	cpsie	i
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
}
 8000f88:	bd10      	pop	{r4, pc}

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8000f8a:	2203      	movs	r2, #3
 8000f8c:	7f43      	ldrb	r3, [r0, #29]
 8000f8e:	4013      	ands	r3, r2
 8000f90:	2b01      	cmp	r3, #1
 8000f92:	d00e      	beq.n	8000fb2 <chThdRelease+0x42>
 8000f94:	2b02      	cmp	r3, #2
 8000f96:	d1f6      	bne.n	8000f86 <chThdRelease+0x16>
      return;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8000f98:	6902      	ldr	r2, [r0, #16]
 8000f9a:	6943      	ldr	r3, [r0, #20]
 8000f9c:	611a      	str	r2, [r3, #16]
 8000f9e:	6902      	ldr	r2, [r0, #16]
 8000fa0:	6153      	str	r3, [r2, #20]
 8000fa2:	b662      	cpsie	i
#endif
      chSysUnlock();
      chPoolFree(tp->p_mpool, tp);
 8000fa4:	6c03      	ldr	r3, [r0, #64]	; 0x40
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fa6:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8000fa8:	681a      	ldr	r2, [r3, #0]
 8000faa:	6002      	str	r2, [r0, #0]
  mp->mp_next = php;
 8000fac:	6018      	str	r0, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fae:	b662      	cpsie	i
 8000fb0:	e7ea      	b.n	8000f88 <chThdRelease+0x18>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8000fb2:	6902      	ldr	r2, [r0, #16]
 8000fb4:	6943      	ldr	r3, [r0, #20]
 8000fb6:	611a      	str	r2, [r3, #16]
 8000fb8:	6902      	ldr	r2, [r0, #16]
 8000fba:	6153      	str	r3, [r2, #20]
 8000fbc:	b662      	cpsie	i
#endif
      chSysUnlock();
      chHeapFree(tp);
 8000fbe:	f7ff ff8f 	bl	8000ee0 <chHeapFree>
 8000fc2:	e7e1      	b.n	8000f88 <chThdRelease+0x18>
	...

08000fd0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8000fd0:	b570      	push	{r4, r5, r6, lr}
 8000fd2:	0004      	movs	r4, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000fd4:	b672      	cpsid	i
  chSysLock();
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 8000fd6:	7f03      	ldrb	r3, [r0, #28]
 8000fd8:	2b0f      	cmp	r3, #15
 8000fda:	d007      	beq.n	8000fec <chThdWait+0x1c>
    list_insert(currp, &tp->p_waiting);
 8000fdc:	4b07      	ldr	r3, [pc, #28]	; (8000ffc <chThdWait+0x2c>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->p_next = tlp->p_next;
 8000fde:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8000fe0:	699b      	ldr	r3, [r3, #24]
 8000fe2:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8000fe4:	6243      	str	r3, [r0, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTEXIT);
 8000fe6:	2009      	movs	r0, #9
 8000fe8:	f7ff fcc2 	bl	8000970 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8000fec:	6a25      	ldr	r5, [r4, #32]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000fee:	b662      	cpsie	i
  chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8000ff0:	0020      	movs	r0, r4
 8000ff2:	f7ff ffbd 	bl	8000f70 <chThdRelease>
#endif

  return msg;
}
 8000ff6:	0028      	movs	r0, r5
 8000ff8:	bd70      	pop	{r4, r5, r6, pc}
 8000ffa:	46c0      	nop			; (mov r8, r8)
 8000ffc:	20000ac0 	.word	0x20000ac0

08001000 <test_wait_threads>:
}

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8001000:	b570      	push	{r4, r5, r6, lr}
 8001002:	4c07      	ldr	r4, [pc, #28]	; (8001020 <test_wait_threads+0x20>)
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8001004:	2600      	movs	r6, #0
 8001006:	0025      	movs	r5, r4
 8001008:	3514      	adds	r5, #20
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 800100a:	6820      	ldr	r0, [r4, #0]
 800100c:	2800      	cmp	r0, #0
 800100e:	d002      	beq.n	8001016 <test_wait_threads+0x16>
      chThdWait(threads[i]);
 8001010:	f7ff ffde 	bl	8000fd0 <chThdWait>
      threads[i] = NULL;
 8001014:	6026      	str	r6, [r4, #0]
 8001016:	3404      	adds	r4, #4
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 8001018:	42ac      	cmp	r4, r5
 800101a:	d1f6      	bne.n	800100a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800101c:	bd70      	pop	{r4, r5, r6, pc}
 800101e:	46c0      	nop			; (mov r8, r8)
 8001020:	20000a28 	.word	0x20000a28
	...

08001030 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8001030:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001032:	4647      	mov	r7, r8
 8001034:	b480      	push	{r7}
 8001036:	1e07      	subs	r7, r0, #0
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8001038:	d039      	beq.n	80010ae <chHeapAlloc+0x7e>
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
 800103a:	2307      	movs	r3, #7
 800103c:	1dce      	adds	r6, r1, #7
 800103e:	439e      	bics	r6, r3
  qp = &heapp->h_free;

  H_LOCK(heapp);
 8001040:	3309      	adds	r3, #9
 8001042:	4698      	mov	r8, r3
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 8001044:	003d      	movs	r5, r7

  H_LOCK(heapp);
 8001046:	44b8      	add	r8, r7
 8001048:	4640      	mov	r0, r8
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 800104a:	3508      	adds	r5, #8

  H_LOCK(heapp);
 800104c:	f7ff ff18 	bl	8000e80 <chMtxLock>
 8001050:	e003      	b.n	800105a <chHeapAlloc+0x2a>
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8001052:	6863      	ldr	r3, [r4, #4]
 8001054:	429e      	cmp	r6, r3
 8001056:	d914      	bls.n	8001082 <chHeapAlloc+0x52>
 8001058:	0025      	movs	r5, r4

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 800105a:	682c      	ldr	r4, [r5, #0]
 800105c:	2c00      	cmp	r4, #0
 800105e:	d1f8      	bne.n	8001052 <chHeapAlloc+0x22>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8001060:	4640      	mov	r0, r8
 8001062:	f7ff fe75 	bl	8000d50 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 8001066:	683b      	ldr	r3, [r7, #0]
 8001068:	2b00      	cmp	r3, #0
 800106a:	d022      	beq.n	80010b2 <chHeapAlloc+0x82>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 800106c:	0030      	movs	r0, r6
 800106e:	3008      	adds	r0, #8
 8001070:	4798      	blx	r3
    if (hp != NULL) {
 8001072:	2800      	cmp	r0, #0
 8001074:	d01d      	beq.n	80010b2 <chHeapAlloc+0x82>
      hp->h.u.heap = heapp;
 8001076:	6007      	str	r7, [r0, #0]
      hp->h.size = size;
 8001078:	6046      	str	r6, [r0, #4]
      hp++;
 800107a:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 800107c:	bc04      	pop	{r2}
 800107e:	4690      	mov	r8, r2
 8001080:	bdf0      	pop	{r4, r5, r6, r7, pc}

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 8001082:	0032      	movs	r2, r6
 8001084:	3208      	adds	r2, #8
 8001086:	4293      	cmp	r3, r2
 8001088:	d208      	bcs.n	800109c <chHeapAlloc+0x6c>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 800108a:	6823      	ldr	r3, [r4, #0]
 800108c:	602b      	str	r3, [r5, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
      H_UNLOCK(heapp);
 800108e:	4640      	mov	r0, r8
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8001090:	6027      	str	r7, [r4, #0]
      H_UNLOCK(heapp);
 8001092:	f7ff fe5d 	bl	8000d50 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 8001096:	0020      	movs	r0, r4
 8001098:	3008      	adds	r0, #8
 800109a:	e7ef      	b.n	800107c <chHeapAlloc+0x4c>
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 800109c:	6821      	ldr	r1, [r4, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 800109e:	1b9b      	subs	r3, r3, r6
        qp->h.u.next = hp->h.u.next;
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80010a0:	18a2      	adds	r2, r4, r2
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80010a2:	3b08      	subs	r3, #8
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80010a4:	6011      	str	r1, [r2, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80010a6:	6053      	str	r3, [r2, #4]
        qp->h.u.next = fp;
 80010a8:	602a      	str	r2, [r5, #0]
        hp->h.size = size;
 80010aa:	6066      	str	r6, [r4, #4]
 80010ac:	e7ef      	b.n	800108e <chHeapAlloc+0x5e>
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
    heapp = &default_heap;
 80010ae:	4f02      	ldr	r7, [pc, #8]	; (80010b8 <chHeapAlloc+0x88>)
 80010b0:	e7c3      	b.n	800103a <chHeapAlloc+0xa>
      return (void *)hp;
      /*lint -restore*/
    }
  }

  return NULL;
 80010b2:	2000      	movs	r0, #0
 80010b4:	e7e2      	b.n	800107c <chHeapAlloc+0x4c>
 80010b6:	46c0      	nop			; (mov r8, r8)
 80010b8:	20000a08 	.word	0x20000a08
 80010bc:	00000000 	.word	0x00000000

080010c0 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 80010c0:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 80010c2:	b510      	push	{r4, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 80010c4:	3301      	adds	r3, #1
 80010c6:	6083      	str	r3, [r0, #8]
 80010c8:	2b00      	cmp	r3, #0
 80010ca:	dd00      	ble.n	80010ce <chSemSignalI+0xe>
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
  }
}
 80010cc:	bd10      	pop	{r4, pc}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80010ce:	6803      	ldr	r3, [r0, #0]

  tqp->p_next = tp->p_next;
 80010d0:	681a      	ldr	r2, [r3, #0]
 80010d2:	6002      	str	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80010d4:	6050      	str	r0, [r2, #4]

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 80010d6:	2200      	movs	r2, #0
    (void) chSchReadyI(tp);
 80010d8:	0018      	movs	r0, r3

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 80010da:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80010dc:	f7ff fc98 	bl	8000a10 <chSchReadyI>
 80010e0:	e7f4      	b.n	80010cc <chSemSignalI+0xc>
 80010e2:	46c0      	nop			; (mov r8, r8)
	...

080010f0 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 80010f0:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 80010f2:	6884      	ldr	r4, [r0, #8]
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 80010f4:	0005      	movs	r5, r0
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 80010f6:	3401      	adds	r4, #1
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
 80010f8:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 80010fa:	2c00      	cmp	r4, #0
 80010fc:	dc0b      	bgt.n	8001116 <chSemResetI+0x26>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 80010fe:	2602      	movs	r6, #2
 8001100:	4276      	negs	r6, r6

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_prev;
 8001102:	6868      	ldr	r0, [r5, #4]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001104:	3401      	adds	r4, #1

  tqp->p_prev = tp->p_prev;
 8001106:	6843      	ldr	r3, [r0, #4]
 8001108:	606b      	str	r3, [r5, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 800110a:	601d      	str	r5, [r3, #0]
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 800110c:	f7ff fc80 	bl	8000a10 <chSchReadyI>
 8001110:	6206      	str	r6, [r0, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001112:	2c01      	cmp	r4, #1
 8001114:	d1f5      	bne.n	8001102 <chSemResetI+0x12>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 8001116:	bd70      	pop	{r4, r5, r6, pc}
	...

08001120 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001120:	b570      	push	{r4, r5, r6, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001122:	b672      	cpsid	i
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001124:	4b0d      	ldr	r3, [pc, #52]	; (800115c <chThdExit+0x3c>)
 8001126:	699c      	ldr	r4, [r3, #24]
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8001128:	0025      	movs	r5, r4
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 800112a:	6220      	str	r0, [r4, #32]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800112c:	6a60      	ldr	r0, [r4, #36]	; 0x24
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800112e:	3524      	adds	r5, #36	; 0x24
 8001130:	4285      	cmp	r5, r0
 8001132:	d006      	beq.n	8001142 <chThdExit+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001134:	6803      	ldr	r3, [r0, #0]
 8001136:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001138:	f7ff fc6a 	bl	8000a10 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800113c:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800113e:	42a8      	cmp	r0, r5
 8001140:	d1f8      	bne.n	8001134 <chThdExit+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8001142:	7f63      	ldrb	r3, [r4, #29]
 8001144:	079b      	lsls	r3, r3, #30
 8001146:	d104      	bne.n	8001152 <chThdExit+0x32>
    REG_REMOVE(tp);
 8001148:	6922      	ldr	r2, [r4, #16]
 800114a:	6963      	ldr	r3, [r4, #20]
 800114c:	611a      	str	r2, [r3, #16]
 800114e:	6922      	ldr	r2, [r4, #16]
 8001150:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001152:	200f      	movs	r0, #15
 8001154:	f7ff fc0c 	bl	8000970 <chSchGoSleepS>
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 8001158:	bd70      	pop	{r4, r5, r6, pc}
 800115a:	46c0      	nop			; (mov r8, r8)
 800115c:	20000ac0 	.word	0x20000ac0

08001160 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001160:	4b1b      	ldr	r3, [pc, #108]	; (80011d0 <chVTDoResetI+0x70>)
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001162:	b510      	push	{r4, lr}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8001164:	69da      	ldr	r2, [r3, #28]
 8001166:	4282      	cmp	r2, r0
 8001168:	d00f      	beq.n	800118a <chVTDoResetI+0x2a>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800116a:	6841      	ldr	r1, [r0, #4]
 800116c:	6802      	ldr	r2, [r0, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800116e:	331c      	adds	r3, #28

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8001170:	600a      	str	r2, [r1, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8001172:	6802      	ldr	r2, [r0, #0]
 8001174:	6051      	str	r1, [r2, #4]
    vtp->vt_func = NULL;
 8001176:	2100      	movs	r1, #0
 8001178:	60c1      	str	r1, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800117a:	429a      	cmp	r2, r3
 800117c:	d004      	beq.n	8001188 <chVTDoResetI+0x28>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 800117e:	6891      	ldr	r1, [r2, #8]
 8001180:	6883      	ldr	r3, [r0, #8]
 8001182:	468c      	mov	ip, r1
 8001184:	4463      	add	r3, ip
 8001186:	6093      	str	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001188:	bd10      	pop	{r4, pc}
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800118a:	0018      	movs	r0, r3
  vtp->vt_func = NULL;
 800118c:	2400      	movs	r4, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 800118e:	6811      	ldr	r1, [r2, #0]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001190:	301c      	adds	r0, #28

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8001192:	61d9      	str	r1, [r3, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001194:	6048      	str	r0, [r1, #4]
  vtp->vt_func = NULL;
 8001196:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8001198:	4281      	cmp	r1, r0
 800119a:	d015      	beq.n	80011c8 <chVTDoResetI+0x68>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 800119c:	6888      	ldr	r0, [r1, #8]
 800119e:	6892      	ldr	r2, [r2, #8]
 80011a0:	4684      	mov	ip, r0
 80011a2:	4462      	add	r2, ip
 80011a4:	608a      	str	r2, [r1, #8]
 80011a6:	2180      	movs	r1, #128	; 0x80
 80011a8:	05c9      	lsls	r1, r1, #23
 80011aa:	6a49      	ldr	r1, [r1, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80011ac:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80011ae:	1acb      	subs	r3, r1, r3

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80011b0:	429a      	cmp	r2, r3
 80011b2:	d9e9      	bls.n	8001188 <chVTDoResetI+0x28>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80011b4:	1ad2      	subs	r2, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80011b6:	2a01      	cmp	r2, #1
 80011b8:	d904      	bls.n	80011c4 <chVTDoResetI+0x64>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80011ba:	2380      	movs	r3, #128	; 0x80
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 80011bc:	188a      	adds	r2, r1, r2
 80011be:	05db      	lsls	r3, r3, #23
 80011c0:	635a      	str	r2, [r3, #52]	; 0x34
 80011c2:	e7e1      	b.n	8001188 <chVTDoResetI+0x28>
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80011c4:	2202      	movs	r2, #2
 80011c6:	e7f8      	b.n	80011ba <chVTDoResetI+0x5a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80011c8:	2380      	movs	r3, #128	; 0x80
 80011ca:	05db      	lsls	r3, r3, #23
 80011cc:	60dc      	str	r4, [r3, #12]
 80011ce:	e7db      	b.n	8001188 <chVTDoResetI+0x28>
 80011d0:	20000ac0 	.word	0x20000ac0
	...

080011e0 <chVTDoSetI>:
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 80011e0:	6103      	str	r3, [r0, #16]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80011e2:	2380      	movs	r3, #128	; 0x80
 80011e4:	05db      	lsls	r3, r3, #23
  vtp->vt_func = vtfunc;
 80011e6:	60c2      	str	r2, [r0, #12]
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 80011e8:	b570      	push	{r4, r5, r6, lr}
 80011ea:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
 80011ec:	2901      	cmp	r1, #1
 80011ee:	d922      	bls.n	8001236 <chVTDoSetI+0x56>
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80011f0:	4d19      	ldr	r5, [pc, #100]	; (8001258 <chVTDoSetI+0x78>)
 80011f2:	002c      	movs	r4, r5
 80011f4:	69eb      	ldr	r3, [r5, #28]
 80011f6:	341c      	adds	r4, #28
 80011f8:	42a3      	cmp	r3, r4
 80011fa:	d01e      	beq.n	800123a <chVTDoSetI+0x5a>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 80011fc:	1889      	adds	r1, r1, r2
    if (delta < ch.vtlist.vt_next->vt_delta) {
 80011fe:	689c      	ldr	r4, [r3, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8001200:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8001202:	1a8a      	subs	r2, r1, r2
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8001204:	42a2      	cmp	r2, r4
 8001206:	d203      	bcs.n	8001210 <chVTDoSetI+0x30>
 8001208:	e011      	b.n	800122e <chVTDoSetI+0x4e>
  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
    p = p->vt_next;
 800120a:	681b      	ldr	r3, [r3, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800120c:	1b12      	subs	r2, r2, r4
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 800120e:	689c      	ldr	r4, [r3, #8]
 8001210:	4294      	cmp	r4, r2
 8001212:	d3fa      	bcc.n	800120a <chVTDoSetI+0x2a>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001214:	6859      	ldr	r1, [r3, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8001216:	6003      	str	r3, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8001218:	6041      	str	r1, [r0, #4]
  vtp->vt_prev->vt_next = vtp;
 800121a:	6008      	str	r0, [r1, #0]
  p->vt_prev = vtp;
 800121c:	6058      	str	r0, [r3, #4]
  vtp->vt_delta = delta
 800121e:	6082      	str	r2, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8001220:	6899      	ldr	r1, [r3, #8]
 8001222:	1a8a      	subs	r2, r1, r2
 8001224:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8001226:	2301      	movs	r3, #1
 8001228:	425b      	negs	r3, r3
 800122a:	626b      	str	r3, [r5, #36]	; 0x24
}
 800122c:	bd70      	pop	{r4, r5, r6, pc}
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800122e:	2680      	movs	r6, #128	; 0x80
 8001230:	05f6      	lsls	r6, r6, #23
 8001232:	6371      	str	r1, [r6, #52]	; 0x34
 8001234:	e7ec      	b.n	8001210 <chVTDoSetI+0x30>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8001236:	2102      	movs	r1, #2
 8001238:	e7da      	b.n	80011f0 <chVTDoSetI+0x10>
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 800123a:	62aa      	str	r2, [r5, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 800123c:	61e8      	str	r0, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 800123e:	6228      	str	r0, [r5, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8001240:	6003      	str	r3, [r0, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001242:	6043      	str	r3, [r0, #4]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001244:	2380      	movs	r3, #128	; 0x80
      vtp->vt_delta = delay;
 8001246:	6081      	str	r1, [r0, #8]

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8001248:	1889      	adds	r1, r1, r2
  STM32_ST_TIM->SR     = 0;
 800124a:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800124c:	05db      	lsls	r3, r3, #23
 800124e:	6359      	str	r1, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001250:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001252:	3202      	adds	r2, #2
 8001254:	60da      	str	r2, [r3, #12]
 8001256:	e7e9      	b.n	800122c <chVTDoSetI+0x4c>
 8001258:	20000ac0 	.word	0x20000ac0
 800125c:	00000000 	.word	0x00000000

08001260 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8001260:	b530      	push	{r4, r5, lr}
 8001262:	0005      	movs	r5, r0
 8001264:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8001266:	1c4b      	adds	r3, r1, #1
 8001268:	d012      	beq.n	8001290 <chSchGoSleepTimeoutS+0x30>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800126a:	4c0b      	ldr	r4, [pc, #44]	; (8001298 <chSchGoSleepTimeoutS+0x38>)
 800126c:	4a0b      	ldr	r2, [pc, #44]	; (800129c <chSchGoSleepTimeoutS+0x3c>)
 800126e:	69a3      	ldr	r3, [r4, #24]
 8001270:	a801      	add	r0, sp, #4
 8001272:	f7ff ffb5 	bl	80011e0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8001276:	0028      	movs	r0, r5
 8001278:	f7ff fb7a 	bl	8000970 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800127c:	9b04      	ldr	r3, [sp, #16]
 800127e:	2b00      	cmp	r3, #0
 8001280:	d002      	beq.n	8001288 <chSchGoSleepTimeoutS+0x28>
      chVTDoResetI(&vt);
 8001282:	a801      	add	r0, sp, #4
 8001284:	f7ff ff6c 	bl	8001160 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8001288:	69a3      	ldr	r3, [r4, #24]
 800128a:	6a18      	ldr	r0, [r3, #32]
}
 800128c:	b007      	add	sp, #28
 800128e:	bd30      	pop	{r4, r5, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001290:	f7ff fb6e 	bl	8000970 <chSchGoSleepS>
 8001294:	4c00      	ldr	r4, [pc, #0]	; (8001298 <chSchGoSleepTimeoutS+0x38>)
 8001296:	e7f7      	b.n	8001288 <chSchGoSleepTimeoutS+0x28>
 8001298:	20000ac0 	.word	0x20000ac0
 800129c:	08000391 	.word	0x08000391

080012a0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 80012a0:	b510      	push	{r4, lr}
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80012a2:	6884      	ldr	r4, [r0, #8]
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 80012a4:	0003      	movs	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80012a6:	1e62      	subs	r2, r4, #1
 80012a8:	6082      	str	r2, [r0, #8]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 80012aa:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80012ac:	2a00      	cmp	r2, #0
 80012ae:	db00      	blt.n	80012b2 <chSemWaitTimeoutS+0x12>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 80012b0:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 80012b2:	2900      	cmp	r1, #0
 80012b4:	d00b      	beq.n	80012ce <chSemWaitTimeoutS+0x2e>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 80012b6:	4a07      	ldr	r2, [pc, #28]	; (80012d4 <chSemWaitTimeoutS+0x34>)
 80012b8:	6992      	ldr	r2, [r2, #24]
 80012ba:	6213      	str	r3, [r2, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80012bc:	6858      	ldr	r0, [r3, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80012be:	6013      	str	r3, [r2, #0]
  tp->p_prev = tqp->p_prev;
 80012c0:	6050      	str	r0, [r2, #4]
  tp->p_prev->p_next = tp;
 80012c2:	6002      	str	r2, [r0, #0]
  tqp->p_prev = tp;
 80012c4:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 80012c6:	2005      	movs	r0, #5
 80012c8:	f7ff ffca 	bl	8001260 <chSchGoSleepTimeoutS>
 80012cc:	e7f0      	b.n	80012b0 <chSemWaitTimeoutS+0x10>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 80012ce:	609c      	str	r4, [r3, #8]

      return MSG_TIMEOUT;
 80012d0:	3801      	subs	r0, #1
 80012d2:	e7ed      	b.n	80012b0 <chSemWaitTimeoutS+0x10>
 80012d4:	20000ac0 	.word	0x20000ac0
	...

080012e0 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 80012e0:	b510      	push	{r4, lr}

  if (TIME_IMMEDIATE == timeout) {
 80012e2:	2900      	cmp	r1, #0
 80012e4:	d00a      	beq.n	80012fc <chThdEnqueueTimeoutS+0x1c>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 80012e6:	4b07      	ldr	r3, [pc, #28]	; (8001304 <chThdEnqueueTimeoutS+0x24>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80012e8:	6842      	ldr	r2, [r0, #4]
 80012ea:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80012ec:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 80012ee:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80012f0:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 80012f2:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 80012f4:	2004      	movs	r0, #4
 80012f6:	f7ff ffb3 	bl	8001260 <chSchGoSleepTimeoutS>
}
 80012fa:	bd10      	pop	{r4, pc}
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
 80012fc:	2001      	movs	r0, #1
 80012fe:	4240      	negs	r0, r0
 8001300:	e7fb      	b.n	80012fa <chThdEnqueueTimeoutS+0x1a>
 8001302:	46c0      	nop			; (mov r8, r8)
 8001304:	20000ac0 	.word	0x20000ac0
	...

08001310 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8001310:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001312:	464e      	mov	r6, r9
 8001314:	4645      	mov	r5, r8
 8001316:	4657      	mov	r7, sl
 8001318:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
 800131a:	69c3      	ldr	r3, [r0, #28]
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 800131c:	b4e0      	push	{r5, r6, r7}
 800131e:	0004      	movs	r4, r0
 8001320:	000e      	movs	r6, r1
 8001322:	0015      	movs	r5, r2
  qnotify_t nfy = oqp->q_notify;
 8001324:	4698      	mov	r8, r3
 8001326:	b672      	cpsid	i
  size_t w = 0;
 8001328:	2700      	movs	r7, #0
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800132a:	68a3      	ldr	r3, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800132c:	2b00      	cmp	r3, #0
 800132e:	d01e      	beq.n	800136e <chOQWriteTimeout+0x5e>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8001330:	68a3      	ldr	r3, [r4, #8]
 8001332:	3b01      	subs	r3, #1
 8001334:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8001336:	6963      	ldr	r3, [r4, #20]
 8001338:	1c5a      	adds	r2, r3, #1
 800133a:	6162      	str	r2, [r4, #20]
 800133c:	1c72      	adds	r2, r6, #1
 800133e:	4692      	mov	sl, r2
 8001340:	7832      	ldrb	r2, [r6, #0]
 8001342:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8001344:	6963      	ldr	r3, [r4, #20]
 8001346:	6922      	ldr	r2, [r4, #16]
 8001348:	4293      	cmp	r3, r2
 800134a:	d301      	bcc.n	8001350 <chOQWriteTimeout+0x40>
      oqp->q_wrptr = oqp->q_buffer;
 800134c:	68e3      	ldr	r3, [r4, #12]
 800134e:	6163      	str	r3, [r4, #20]
    }

    if (nfy != NULL) {
 8001350:	4643      	mov	r3, r8
 8001352:	2b00      	cmp	r3, #0
 8001354:	d001      	beq.n	800135a <chOQWriteTimeout+0x4a>
      nfy(oqp);
 8001356:	0020      	movs	r0, r4
 8001358:	47c0      	blx	r8
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800135a:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 800135c:	3d01      	subs	r5, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 800135e:	3701      	adds	r7, #1
    if (--n == 0U) {
 8001360:	2d00      	cmp	r5, #0
 8001362:	d00b      	beq.n	800137c <chOQWriteTimeout+0x6c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001364:	b672      	cpsid	i
 8001366:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8001368:	4656      	mov	r6, sl

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 800136a:	2b00      	cmp	r3, #0
 800136c:	d1e0      	bne.n	8001330 <chOQWriteTimeout+0x20>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800136e:	4649      	mov	r1, r9
 8001370:	0020      	movs	r0, r4
 8001372:	f7ff ffb5 	bl	80012e0 <chThdEnqueueTimeoutS>
 8001376:	2800      	cmp	r0, #0
 8001378:	d0d7      	beq.n	800132a <chOQWriteTimeout+0x1a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800137a:	b662      	cpsie	i
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 800137c:	0038      	movs	r0, r7
 800137e:	bc1c      	pop	{r2, r3, r4}
 8001380:	4690      	mov	r8, r2
 8001382:	4699      	mov	r9, r3
 8001384:	46a2      	mov	sl, r4
 8001386:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

08001390 <writet.lto_priv.69>:
static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8001390:	b510      	push	{r4, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001392:	3030      	adds	r0, #48	; 0x30
 8001394:	f7ff ffbc 	bl	8001310 <chOQWriteTimeout>
}
 8001398:	bd10      	pop	{r4, pc}
 800139a:	46c0      	nop			; (mov r8, r8)
 800139c:	0000      	movs	r0, r0
	...

080013a0 <write.lto_priv.63>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80013a0:	2301      	movs	r3, #1
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 80013a2:	b510      	push	{r4, lr}

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80013a4:	3030      	adds	r0, #48	; 0x30
 80013a6:	425b      	negs	r3, r3
 80013a8:	f7ff ffb2 	bl	8001310 <chOQWriteTimeout>
                        n, TIME_INFINITE);
}
 80013ac:	bd10      	pop	{r4, pc}
 80013ae:	46c0      	nop			; (mov r8, r8)

080013b0 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 80013b0:	b570      	push	{r4, r5, r6, lr}
 80013b2:	0004      	movs	r4, r0
 80013b4:	000e      	movs	r6, r1
 80013b6:	0015      	movs	r5, r2
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013b8:	b672      	cpsid	i
 80013ba:	e005      	b.n	80013c8 <chOQPutTimeout+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 80013bc:	0029      	movs	r1, r5
 80013be:	0020      	movs	r0, r4
 80013c0:	f7ff ff8e 	bl	80012e0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 80013c4:	2800      	cmp	r0, #0
 80013c6:	db17      	blt.n	80013f8 <chOQPutTimeout+0x48>
 80013c8:	68a3      	ldr	r3, [r4, #8]
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 80013ca:	2b00      	cmp	r3, #0
 80013cc:	d0f6      	beq.n	80013bc <chOQPutTimeout+0xc>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 80013ce:	68a3      	ldr	r3, [r4, #8]
 80013d0:	3b01      	subs	r3, #1
 80013d2:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 80013d4:	6963      	ldr	r3, [r4, #20]
 80013d6:	1c5a      	adds	r2, r3, #1
 80013d8:	6162      	str	r2, [r4, #20]
 80013da:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80013dc:	6963      	ldr	r3, [r4, #20]
 80013de:	6922      	ldr	r2, [r4, #16]
 80013e0:	4293      	cmp	r3, r2
 80013e2:	d301      	bcc.n	80013e8 <chOQPutTimeout+0x38>
    oqp->q_wrptr = oqp->q_buffer;
 80013e4:	68e3      	ldr	r3, [r4, #12]
 80013e6:	6163      	str	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 80013e8:	69e3      	ldr	r3, [r4, #28]
 80013ea:	2b00      	cmp	r3, #0
 80013ec:	d001      	beq.n	80013f2 <chOQPutTimeout+0x42>
    oqp->q_notify(oqp);
 80013ee:	0020      	movs	r0, r4
 80013f0:	4798      	blx	r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80013f2:	b662      	cpsie	i
 80013f4:	2000      	movs	r0, #0
  }
  chSysUnlock();

  return Q_OK;
}
 80013f6:	bd70      	pop	{r4, r5, r6, pc}
 80013f8:	b662      	cpsie	i
 80013fa:	e7fc      	b.n	80013f6 <chOQPutTimeout+0x46>
 80013fc:	0000      	movs	r0, r0
	...

08001400 <putt.lto_priv.67>:
static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 8001400:	b510      	push	{r4, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8001402:	3030      	adds	r0, #48	; 0x30
 8001404:	f7ff ffd4 	bl	80013b0 <chOQPutTimeout>
}
 8001408:	bd10      	pop	{r4, pc}
 800140a:	46c0      	nop			; (mov r8, r8)
 800140c:	0000      	movs	r0, r0
	...

08001410 <put.lto_priv.65>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001410:	2201      	movs	r2, #1

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {
 8001412:	b510      	push	{r4, lr}

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8001414:	3030      	adds	r0, #48	; 0x30
 8001416:	4252      	negs	r2, r2
 8001418:	f7ff ffca 	bl	80013b0 <chOQPutTimeout>
}
 800141c:	bd10      	pop	{r4, pc}
 800141e:	46c0      	nop			; (mov r8, r8)

08001420 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8001420:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001422:	464f      	mov	r7, r9
 8001424:	4646      	mov	r6, r8
 8001426:	0004      	movs	r4, r0
 8001428:	b4c0      	push	{r6, r7}
 800142a:	4689      	mov	r9, r1
 800142c:	4690      	mov	r8, r2
 800142e:	001d      	movs	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8001430:	69c7      	ldr	r7, [r0, #28]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001432:	b672      	cpsid	i
  size_t r = 0;
 8001434:	2600      	movs	r6, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8001436:	2f00      	cmp	r7, #0
 8001438:	d008      	beq.n	800144c <chIQReadTimeout+0x2c>
      nfy(iqp);
 800143a:	0020      	movs	r0, r4
 800143c:	47b8      	blx	r7
 800143e:	e005      	b.n	800144c <chIQReadTimeout+0x2c>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8001440:	0029      	movs	r1, r5
 8001442:	0020      	movs	r0, r4
 8001444:	f7ff ff4c 	bl	80012e0 <chThdEnqueueTimeoutS>
 8001448:	2800      	cmp	r0, #0
 800144a:	d117      	bne.n	800147c <chIQReadTimeout+0x5c>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800144c:	68a3      	ldr	r3, [r4, #8]
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 800144e:	2b00      	cmp	r3, #0
 8001450:	d0f6      	beq.n	8001440 <chIQReadTimeout+0x20>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8001452:	68a3      	ldr	r3, [r4, #8]
 8001454:	3b01      	subs	r3, #1
 8001456:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8001458:	69a3      	ldr	r3, [r4, #24]
 800145a:	1c5a      	adds	r2, r3, #1
 800145c:	61a2      	str	r2, [r4, #24]
 800145e:	464a      	mov	r2, r9
 8001460:	781b      	ldrb	r3, [r3, #0]
 8001462:	5593      	strb	r3, [r2, r6]
    if (iqp->q_rdptr >= iqp->q_top) {
 8001464:	69a3      	ldr	r3, [r4, #24]
 8001466:	6922      	ldr	r2, [r4, #16]
 8001468:	4293      	cmp	r3, r2
 800146a:	d301      	bcc.n	8001470 <chIQReadTimeout+0x50>
      iqp->q_rdptr = iqp->q_buffer;
 800146c:	68e3      	ldr	r3, [r4, #12]
 800146e:	61a3      	str	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001470:	b662      	cpsie	i
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8001472:	3601      	adds	r6, #1
    if (--n == 0U) {
 8001474:	45b0      	cmp	r8, r6
 8001476:	d002      	beq.n	800147e <chIQReadTimeout+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001478:	b672      	cpsid	i
 800147a:	e7dc      	b.n	8001436 <chIQReadTimeout+0x16>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800147c:	b662      	cpsie	i
      return r;
    }

    chSysLock();
  }
}
 800147e:	0030      	movs	r0, r6
 8001480:	bc0c      	pop	{r2, r3}
 8001482:	4690      	mov	r8, r2
 8001484:	4699      	mov	r9, r3
 8001486:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08001490 <readt.lto_priv.70>:
static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8001490:	b510      	push	{r4, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8001492:	300c      	adds	r0, #12
 8001494:	f7ff ffc4 	bl	8001420 <chIQReadTimeout>
}
 8001498:	bd10      	pop	{r4, pc}
 800149a:	46c0      	nop			; (mov r8, r8)
 800149c:	0000      	movs	r0, r0
	...

080014a0 <read.lto_priv.64>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80014a0:	2301      	movs	r3, #1

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {
 80014a2:	b510      	push	{r4, lr}

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80014a4:	300c      	adds	r0, #12
 80014a6:	425b      	negs	r3, r3
 80014a8:	f7ff ffba 	bl	8001420 <chIQReadTimeout>
                       n, TIME_INFINITE);
}
 80014ac:	bd10      	pop	{r4, pc}
 80014ae:	46c0      	nop			; (mov r8, r8)

080014b0 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 80014b0:	b570      	push	{r4, r5, r6, lr}
 80014b2:	0004      	movs	r4, r0
 80014b4:	000d      	movs	r5, r1
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80014b6:	b672      	cpsid	i
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 80014b8:	69c3      	ldr	r3, [r0, #28]
 80014ba:	2b00      	cmp	r3, #0
 80014bc:	d007      	beq.n	80014ce <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 80014be:	4798      	blx	r3
 80014c0:	e005      	b.n	80014ce <chIQGetTimeout+0x1e>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80014c2:	0029      	movs	r1, r5
 80014c4:	0020      	movs	r0, r4
 80014c6:	f7ff ff0b 	bl	80012e0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 80014ca:	2800      	cmp	r0, #0
 80014cc:	db0e      	blt.n	80014ec <chIQGetTimeout+0x3c>
 80014ce:	68a3      	ldr	r3, [r4, #8]
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80014d0:	2b00      	cmp	r3, #0
 80014d2:	d0f6      	beq.n	80014c2 <chIQGetTimeout+0x12>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80014d4:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 80014d6:	69a2      	ldr	r2, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80014d8:	3b01      	subs	r3, #1
 80014da:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 80014dc:	1c53      	adds	r3, r2, #1
 80014de:	61a3      	str	r3, [r4, #24]
 80014e0:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 80014e2:	6922      	ldr	r2, [r4, #16]
 80014e4:	4293      	cmp	r3, r2
 80014e6:	d301      	bcc.n	80014ec <chIQGetTimeout+0x3c>
    iqp->q_rdptr = iqp->q_buffer;
 80014e8:	68e3      	ldr	r3, [r4, #12]
 80014ea:	61a3      	str	r3, [r4, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80014ec:	b662      	cpsie	i
  }
  chSysUnlock();

  return (msg_t)b;
}
 80014ee:	bd70      	pop	{r4, r5, r6, pc}

080014f0 <gett.lto_priv.68>:
static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {
 80014f0:	b510      	push	{r4, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80014f2:	300c      	adds	r0, #12
 80014f4:	f7ff ffdc 	bl	80014b0 <chIQGetTimeout>
}
 80014f8:	bd10      	pop	{r4, pc}
 80014fa:	46c0      	nop			; (mov r8, r8)
 80014fc:	0000      	movs	r0, r0
	...

08001500 <get.lto_priv.66>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001500:	2101      	movs	r1, #1
static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {
 8001502:	b510      	push	{r4, lr}

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001504:	300c      	adds	r0, #12
 8001506:	4249      	negs	r1, r1
 8001508:	f7ff ffd2 	bl	80014b0 <chIQGetTimeout>
}
 800150c:	bd10      	pop	{r4, pc}
 800150e:	46c0      	nop			; (mov r8, r8)

08001510 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8001510:	b510      	push	{r4, lr}
 8001512:	0001      	movs	r1, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001514:	b672      	cpsid	i
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001516:	2008      	movs	r0, #8
 8001518:	f7ff fea2 	bl	8001260 <chSchGoSleepTimeoutS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800151c:	b662      	cpsie	i

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
}
 800151e:	bd10      	pop	{r4, pc}

08001520 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 8001520:	b510      	push	{r4, lr}

  chThdSleep(1);
 8001522:	2001      	movs	r0, #1
 8001524:	f7ff fff4 	bl	8001510 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001528:	b672      	cpsid	i
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800152a:	2380      	movs	r3, #128	; 0x80
 800152c:	05db      	lsls	r3, r3, #23
 800152e:	6a58      	ldr	r0, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001530:	b662      	cpsie	i
  return chVTGetSystemTime();
}
 8001532:	bd10      	pop	{r4, pc}
	...

08001540 <chSysRestoreStatusX.part.3.lto_priv.129>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8001540:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001542:	f3ef 8305 	mrs	r3, IPSR

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 8001546:	05db      	lsls	r3, r3, #23
 8001548:	d101      	bne.n	800154e <chSysRestoreStatusX.part.3.lto_priv.129+0xe>
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 800154a:	f7ff f979 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800154e:	b662      	cpsie	i
      chSysUnlock();
    }
  }
}
 8001550:	bd10      	pop	{r4, pc}
 8001552:	46c0      	nop			; (mov r8, r8)
	...

08001560 <chSysGetStatusAndLockX>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8001560:	f3ef 8010 	mrs	r0, PRIMASK
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8001564:	07c3      	lsls	r3, r0, #31
 8001566:	d402      	bmi.n	800156e <chSysGetStatusAndLockX+0xe>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8001568:	f3ef 8305 	mrs	r3, IPSR
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800156c:	b672      	cpsid	i
    else {
      chSysLock();
    }
  }
  return sts;
}
 800156e:	4770      	bx	lr

08001570 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8001570:	b530      	push	{r4, r5, lr}
 8001572:	0005      	movs	r5, r0
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8001574:	07c3      	lsls	r3, r0, #31
 8001576:	d511      	bpl.n	800159c <chSysIntegrityCheckI+0x2c>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
 8001578:	4a28      	ldr	r2, [pc, #160]	; (800161c <chSysIntegrityCheckI+0xac>)
 800157a:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800157c:	4291      	cmp	r1, r2
 800157e:	d03c      	beq.n	80015fa <chSysIntegrityCheckI+0x8a>
 8001580:	2300      	movs	r3, #0
      n++;
      tp = tp->p_next;
 8001582:	6809      	ldr	r1, [r1, #0]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n++;
 8001584:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001586:	4291      	cmp	r1, r2
 8001588:	d1fb      	bne.n	8001582 <chSysIntegrityCheckI+0x12>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800158a:	684c      	ldr	r4, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 800158c:	428c      	cmp	r4, r1
 800158e:	d032      	beq.n	80015f6 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->p_prev;
 8001590:	6864      	ldr	r4, [r4, #4]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
      n--;
 8001592:	3b01      	subs	r3, #1
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8001594:	4294      	cmp	r4, r2
 8001596:	d1fb      	bne.n	8001590 <chSysIntegrityCheckI+0x20>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8001598:	2b00      	cmp	r3, #0
 800159a:	d12c      	bne.n	80015f6 <chSysIntegrityCheckI+0x86>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800159c:	07ab      	lsls	r3, r5, #30
 800159e:	d513      	bpl.n	80015c8 <chSysIntegrityCheckI+0x58>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 80015a0:	4b1e      	ldr	r3, [pc, #120]	; (800161c <chSysIntegrityCheckI+0xac>)
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80015a2:	001c      	movs	r4, r3
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
 80015a4:	69da      	ldr	r2, [r3, #28]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80015a6:	341c      	adds	r4, #28
 80015a8:	42a2      	cmp	r2, r4
 80015aa:	d02b      	beq.n	8001604 <chSysIntegrityCheckI+0x94>
 80015ac:	2300      	movs	r3, #0
      n++;
      vtp = vtp->vt_next;
 80015ae:	6812      	ldr	r2, [r2, #0]

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n++;
 80015b0:	3301      	adds	r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80015b2:	42a2      	cmp	r2, r4
 80015b4:	d1fb      	bne.n	80015ae <chSysIntegrityCheckI+0x3e>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80015b6:	6851      	ldr	r1, [r2, #4]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80015b8:	4291      	cmp	r1, r2
 80015ba:	d01c      	beq.n	80015f6 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->vt_prev;
 80015bc:	6849      	ldr	r1, [r1, #4]
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
      n--;
 80015be:	3b01      	subs	r3, #1
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80015c0:	42a1      	cmp	r1, r4
 80015c2:	d1fb      	bne.n	80015bc <chSysIntegrityCheckI+0x4c>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80015c4:	2b00      	cmp	r3, #0
 80015c6:	d116      	bne.n	80015f6 <chSysIntegrityCheckI+0x86>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 80015c8:	2000      	movs	r0, #0
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80015ca:	076b      	lsls	r3, r5, #29
 80015cc:	d512      	bpl.n	80015f4 <chSysIntegrityCheckI+0x84>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
 80015ce:	4a13      	ldr	r2, [pc, #76]	; (800161c <chSysIntegrityCheckI+0xac>)
 80015d0:	6911      	ldr	r1, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 80015d2:	4291      	cmp	r1, r2
 80015d4:	d01c      	beq.n	8001610 <chSysIntegrityCheckI+0xa0>
 80015d6:	2300      	movs	r3, #0
      n++;
      tp = tp->p_newer;
 80015d8:	6909      	ldr	r1, [r1, #16]

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
      n++;
 80015da:	3301      	adds	r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 80015dc:	4291      	cmp	r1, r2
 80015de:	d1fb      	bne.n	80015d8 <chSysIntegrityCheckI+0x68>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 80015e0:	694c      	ldr	r4, [r1, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80015e2:	428c      	cmp	r4, r1
 80015e4:	d007      	beq.n	80015f6 <chSysIntegrityCheckI+0x86>
      n--;
      tp = tp->p_older;
 80015e6:	6964      	ldr	r4, [r4, #20]
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
      n--;
 80015e8:	3b01      	subs	r3, #1
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 80015ea:	4294      	cmp	r4, r2
 80015ec:	d1fb      	bne.n	80015e6 <chSysIntegrityCheckI+0x76>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80015ee:	1e58      	subs	r0, r3, #1
 80015f0:	4183      	sbcs	r3, r0
 80015f2:	b2d8      	uxtb	r0, r3
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80015f4:	bd30      	pop	{r4, r5, pc}
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80015f6:	2001      	movs	r0, #1
 80015f8:	e7fc      	b.n	80015f4 <chSysIntegrityCheckI+0x84>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 80015fa:	6854      	ldr	r4, [r2, #4]
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80015fc:	2300      	movs	r3, #0
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 80015fe:	4294      	cmp	r4, r2
 8001600:	d1c6      	bne.n	8001590 <chSysIntegrityCheckI+0x20>
 8001602:	e7cb      	b.n	800159c <chSysIntegrityCheckI+0x2c>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 8001604:	6a19      	ldr	r1, [r3, #32]
 8001606:	0014      	movs	r4, r2
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 8001608:	2300      	movs	r3, #0
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800160a:	4291      	cmp	r1, r2
 800160c:	d1d6      	bne.n	80015bc <chSysIntegrityCheckI+0x4c>
 800160e:	e7db      	b.n	80015c8 <chSysIntegrityCheckI+0x58>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 8001610:	694c      	ldr	r4, [r1, #20]
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 8001612:	2300      	movs	r3, #0
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8001614:	428c      	cmp	r4, r1
 8001616:	d1e6      	bne.n	80015e6 <chSysIntegrityCheckI+0x76>
 8001618:	e7ec      	b.n	80015f4 <chSysIntegrityCheckI+0x84>
 800161a:	46c0      	nop			; (mov r8, r8)
 800161c:	20000ac0 	.word	0x20000ac0

08001620 <__init_ram_areas>:
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001620:	2280      	movs	r2, #128	; 0x80
 8001622:	4694      	mov	ip, r2
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001624:	b5f0      	push	{r4, r5, r6, r7, lr}
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001626:	2600      	movs	r6, #0
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001628:	4f10      	ldr	r7, [pc, #64]	; (800166c <__init_ram_areas+0x4c>)
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 800162a:	4d11      	ldr	r5, [pc, #68]	; (8001670 <__init_ram_areas+0x50>)
 800162c:	4c11      	ldr	r4, [pc, #68]	; (8001674 <__init_ram_areas+0x54>)
 800162e:	4b12      	ldr	r3, [pc, #72]	; (8001678 <__init_ram_areas+0x58>)
 8001630:	4912      	ldr	r1, [pc, #72]	; (800167c <__init_ram_areas+0x5c>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001632:	44bc      	add	ip, r7
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001634:	429c      	cmp	r4, r3
 8001636:	d90d      	bls.n	8001654 <__init_ram_areas+0x34>
 8001638:	001a      	movs	r2, r3
      *p = *tp;
 800163a:	c901      	ldmia	r1!, {r0}
 800163c:	c201      	stmia	r2!, {r0}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800163e:	4294      	cmp	r4, r2
 8001640:	d8fb      	bhi.n	800163a <__init_ram_areas+0x1a>
 8001642:	43da      	mvns	r2, r3
 8001644:	1914      	adds	r4, r2, r4
 8001646:	08a4      	lsrs	r4, r4, #2
 8001648:	3401      	adds	r4, #1
 800164a:	00a4      	lsls	r4, r4, #2
 800164c:	191b      	adds	r3, r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800164e:	429d      	cmp	r5, r3
 8001650:	d902      	bls.n	8001658 <__init_ram_areas+0x38>
      *p = 0;
 8001652:	c340      	stmia	r3!, {r6}
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001654:	429d      	cmp	r5, r3
 8001656:	d8fc      	bhi.n	8001652 <__init_ram_areas+0x32>
      *p = 0;
      p++;
    }
    rap++;
 8001658:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800165a:	4567      	cmp	r7, ip
 800165c:	d004      	beq.n	8001668 <__init_ram_areas+0x48>
 800165e:	68bc      	ldr	r4, [r7, #8]
 8001660:	68fd      	ldr	r5, [r7, #12]
 8001662:	6839      	ldr	r1, [r7, #0]
 8001664:	687b      	ldr	r3, [r7, #4]
 8001666:	e7e5      	b.n	8001634 <__init_ram_areas+0x14>
#endif
}
 8001668:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800166a:	46c0      	nop			; (mov r8, r8)
 800166c:	080057e0 	.word	0x080057e0
 8001670:	200012c0 	.word	0x200012c0
 8001674:	200012c0 	.word	0x200012c0
 8001678:	200012c0 	.word	0x200012c0
 800167c:	080065e8 	.word	0x080065e8

08001680 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001680:	e7fe      	b.n	8001680 <__default_exit>
 8001682:	46c0      	nop			; (mov r8, r8)
	...

08001690 <__late_init>:
 8001690:	4770      	bx	lr
 8001692:	46c0      	nop			; (mov r8, r8)
	...

080016a0 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80016a0:	4770      	bx	lr
 80016a2:	46c0      	nop			; (mov r8, r8)
	...

080016b0 <bmk12_setup>:
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80016b0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016b2:	4b02      	ldr	r3, [pc, #8]	; (80016bc <bmk12_setup+0xc>)
 80016b4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016b6:	605b      	str	r3, [r3, #4]
 80016b8:	609a      	str	r2, [r3, #8]
 */

static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}
 80016ba:	4770      	bx	lr
 80016bc:	20000a54 	.word	0x20000a54

080016c0 <bmk11_setup>:
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 80016c0:	2201      	movs	r2, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016c2:	4b02      	ldr	r3, [pc, #8]	; (80016cc <bmk11_setup+0xc>)
 80016c4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016c6:	605b      	str	r3, [r3, #4]
 80016c8:	609a      	str	r2, [r3, #8]
 */

static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}
 80016ca:	4770      	bx	lr
 80016cc:	200006c0 	.word	0x200006c0

080016d0 <tmo>:
 80016d0:	4770      	bx	lr
 80016d2:	46c0      	nop			; (mov r8, r8)
	...

080016e0 <bmk7_setup>:
 80016e0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80016e2:	4b02      	ldr	r3, [pc, #8]	; (80016ec <bmk7_setup+0xc>)
 80016e4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80016e6:	605b      	str	r3, [r3, #4]
 80016e8:	609a      	str	r2, [r3, #8]
}

static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80016ea:	4770      	bx	lr
 80016ec:	200006c0 	.word	0x200006c0

080016f0 <Thread1>:

/*
 * Blue LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 80016f0:	b570      	push	{r4, r5, r6, lr}

  (void)arg;
  chRegSetThreadName("blinker1");
  while (true) {
    palClearPad(GPIOC, GPIOC_LED4);
 80016f2:	2480      	movs	r4, #128	; 0x80
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80016f4:	4b07      	ldr	r3, [pc, #28]	; (8001714 <Thread1+0x24>)
 80016f6:	4a08      	ldr	r2, [pc, #32]	; (8001718 <Thread1+0x28>)
 80016f8:	699b      	ldr	r3, [r3, #24]
 80016fa:	4d08      	ldr	r5, [pc, #32]	; (800171c <Thread1+0x2c>)
 80016fc:	619a      	str	r2, [r3, #24]
 80016fe:	0064      	lsls	r4, r4, #1
 8001700:	836c      	strh	r4, [r5, #26]
    chThdSleepMilliseconds(500);
 8001702:	4807      	ldr	r0, [pc, #28]	; (8001720 <Thread1+0x30>)
 8001704:	f7ff ff04 	bl	8001510 <chThdSleep>
    palSetPad(GPIOC, GPIOC_LED4);
 8001708:	832c      	strh	r4, [r5, #24]
    chThdSleepMilliseconds(500);
 800170a:	4805      	ldr	r0, [pc, #20]	; (8001720 <Thread1+0x30>)
 800170c:	f7ff ff00 	bl	8001510 <chThdSleep>
 8001710:	e7f6      	b.n	8001700 <Thread1+0x10>
 8001712:	46c0      	nop			; (mov r8, r8)
 8001714:	20000ac0 	.word	0x20000ac0
 8001718:	08005ca0 	.word	0x08005ca0
 800171c:	48000800 	.word	0x48000800
 8001720:	00001388 	.word	0x00001388
	...

08001730 <Thread2>:

/*
 * Green LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
 8001730:	b570      	push	{r4, r5, r6, lr}

  (void)arg;
  chRegSetThreadName("blinker2");
  while (true) {
    palClearPad(GPIOC, GPIOC_LED3);
 8001732:	2480      	movs	r4, #128	; 0x80
 8001734:	4b07      	ldr	r3, [pc, #28]	; (8001754 <Thread2+0x24>)
 8001736:	4a08      	ldr	r2, [pc, #32]	; (8001758 <Thread2+0x28>)
 8001738:	699b      	ldr	r3, [r3, #24]
 800173a:	4d08      	ldr	r5, [pc, #32]	; (800175c <Thread2+0x2c>)
 800173c:	619a      	str	r2, [r3, #24]
 800173e:	00a4      	lsls	r4, r4, #2
 8001740:	836c      	strh	r4, [r5, #26]
    chThdSleepMilliseconds(250);
 8001742:	4807      	ldr	r0, [pc, #28]	; (8001760 <Thread2+0x30>)
 8001744:	f7ff fee4 	bl	8001510 <chThdSleep>
    palSetPad(GPIOC, GPIOC_LED3);
 8001748:	832c      	strh	r4, [r5, #24]
    chThdSleepMilliseconds(250);
 800174a:	4805      	ldr	r0, [pc, #20]	; (8001760 <Thread2+0x30>)
 800174c:	f7ff fee0 	bl	8001510 <chThdSleep>
 8001750:	e7f6      	b.n	8001740 <Thread2+0x10>
 8001752:	46c0      	nop			; (mov r8, r8)
 8001754:	20000ac0 	.word	0x20000ac0
 8001758:	08005cac 	.word	0x08005cac
 800175c:	48000800 	.word	0x48000800
 8001760:	000009c4 	.word	0x000009c4
	...

08001770 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8001770:	b510      	push	{r4, lr}

  test_print("--- System: ");
 8001772:	482e      	ldr	r0, [pc, #184]	; (800182c <bmk13_execute+0xbc>)
 8001774:	f7fe ff6c 	bl	8000650 <test_print>
  test_printn(sizeof(ch_system_t));
 8001778:	20a8      	movs	r0, #168	; 0xa8
 800177a:	0040      	lsls	r0, r0, #1
 800177c:	f7fe ff80 	bl	8000680 <test_printn>
  test_println(" bytes");
 8001780:	4c2b      	ldr	r4, [pc, #172]	; (8001830 <bmk13_execute+0xc0>)
 8001782:	0020      	movs	r0, r4
 8001784:	f7fe ff44 	bl	8000610 <test_println>
  test_print("--- Thread: ");
 8001788:	482a      	ldr	r0, [pc, #168]	; (8001834 <bmk13_execute+0xc4>)
 800178a:	f7fe ff61 	bl	8000650 <test_print>
  test_printn(sizeof(thread_t));
 800178e:	2044      	movs	r0, #68	; 0x44
 8001790:	f7fe ff76 	bl	8000680 <test_printn>
  test_println(" bytes");
 8001794:	0020      	movs	r0, r4
 8001796:	f7fe ff3b 	bl	8000610 <test_println>
  test_print("--- Timer : ");
 800179a:	4827      	ldr	r0, [pc, #156]	; (8001838 <bmk13_execute+0xc8>)
 800179c:	f7fe ff58 	bl	8000650 <test_print>
  test_printn(sizeof(virtual_timer_t));
 80017a0:	2014      	movs	r0, #20
 80017a2:	f7fe ff6d 	bl	8000680 <test_printn>
  test_println(" bytes");
 80017a6:	0020      	movs	r0, r4
 80017a8:	f7fe ff32 	bl	8000610 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 80017ac:	4823      	ldr	r0, [pc, #140]	; (800183c <bmk13_execute+0xcc>)
 80017ae:	f7fe ff4f 	bl	8000650 <test_print>
  test_printn(sizeof(semaphore_t));
 80017b2:	200c      	movs	r0, #12
 80017b4:	f7fe ff64 	bl	8000680 <test_printn>
  test_println(" bytes");
 80017b8:	0020      	movs	r0, r4
 80017ba:	f7fe ff29 	bl	8000610 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 80017be:	4820      	ldr	r0, [pc, #128]	; (8001840 <bmk13_execute+0xd0>)
 80017c0:	f7fe ff46 	bl	8000650 <test_print>
  test_printn(sizeof(event_source_t));
 80017c4:	2004      	movs	r0, #4
 80017c6:	f7fe ff5b 	bl	8000680 <test_printn>
  test_println(" bytes");
 80017ca:	0020      	movs	r0, r4
 80017cc:	f7fe ff20 	bl	8000610 <test_println>
  test_print("--- EventL: ");
 80017d0:	481c      	ldr	r0, [pc, #112]	; (8001844 <bmk13_execute+0xd4>)
 80017d2:	f7fe ff3d 	bl	8000650 <test_print>
  test_printn(sizeof(event_listener_t));
 80017d6:	2014      	movs	r0, #20
 80017d8:	f7fe ff52 	bl	8000680 <test_printn>
  test_println(" bytes");
 80017dc:	0020      	movs	r0, r4
 80017de:	f7fe ff17 	bl	8000610 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 80017e2:	4819      	ldr	r0, [pc, #100]	; (8001848 <bmk13_execute+0xd8>)
 80017e4:	f7fe ff34 	bl	8000650 <test_print>
  test_printn(sizeof(mutex_t));
 80017e8:	2010      	movs	r0, #16
 80017ea:	f7fe ff49 	bl	8000680 <test_printn>
  test_println(" bytes");
 80017ee:	0020      	movs	r0, r4
 80017f0:	f7fe ff0e 	bl	8000610 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 80017f4:	4815      	ldr	r0, [pc, #84]	; (800184c <bmk13_execute+0xdc>)
 80017f6:	f7fe ff2b 	bl	8000650 <test_print>
  test_printn(sizeof(condition_variable_t));
 80017fa:	2008      	movs	r0, #8
 80017fc:	f7fe ff40 	bl	8000680 <test_printn>
  test_println(" bytes");
 8001800:	0020      	movs	r0, r4
 8001802:	f7fe ff05 	bl	8000610 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8001806:	4812      	ldr	r0, [pc, #72]	; (8001850 <bmk13_execute+0xe0>)
 8001808:	f7fe ff22 	bl	8000650 <test_print>
  test_printn(sizeof(io_queue_t));
 800180c:	2024      	movs	r0, #36	; 0x24
 800180e:	f7fe ff37 	bl	8000680 <test_printn>
  test_println(" bytes");
 8001812:	0020      	movs	r0, r4
 8001814:	f7fe fefc 	bl	8000610 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8001818:	480e      	ldr	r0, [pc, #56]	; (8001854 <bmk13_execute+0xe4>)
 800181a:	f7fe ff19 	bl	8000650 <test_print>
  test_printn(sizeof(mailbox_t));
 800181e:	2028      	movs	r0, #40	; 0x28
 8001820:	f7fe ff2e 	bl	8000680 <test_printn>
  test_println(" bytes");
 8001824:	0020      	movs	r0, r4
 8001826:	f7fe fef3 	bl	8000610 <test_println>
#endif
}
 800182a:	bd10      	pop	{r4, pc}
 800182c:	08005cb8 	.word	0x08005cb8
 8001830:	08005cc8 	.word	0x08005cc8
 8001834:	08005cd0 	.word	0x08005cd0
 8001838:	08005ce0 	.word	0x08005ce0
 800183c:	08005cf0 	.word	0x08005cf0
 8001840:	08005d00 	.word	0x08005d00
 8001844:	08005d10 	.word	0x08005d10
 8001848:	08005d20 	.word	0x08005d20
 800184c:	08005d30 	.word	0x08005d30
 8001850:	08005d40 	.word	0x08005d40
 8001854:	08005d50 	.word	0x08005d50
	...

08001860 <bmk12_execute>:
static void bmk12_setup(void) {

  chMtxObjectInit(&mtx1);
}

static void bmk12_execute(void) {
 8001860:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = 0;
 8001862:	2500      	movs	r5, #0

  test_wait_tick();
 8001864:	f7ff fe5c 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 8001868:	f003 ff82 	bl	8005770 <test_start_timer.constprop.1>
 800186c:	4c13      	ldr	r4, [pc, #76]	; (80018bc <bmk12_execute+0x5c>)
 800186e:	4e14      	ldr	r6, [pc, #80]	; (80018c0 <bmk12_execute+0x60>)
  do {
    chMtxLock(&mtx1);
 8001870:	0020      	movs	r0, r4
 8001872:	f7ff fb05 	bl	8000e80 <chMtxLock>
    chMtxUnlock(&mtx1);
 8001876:	0020      	movs	r0, r4
 8001878:	f7ff fa6a 	bl	8000d50 <chMtxUnlock>
    chMtxLock(&mtx1);
 800187c:	0020      	movs	r0, r4
 800187e:	f7ff faff 	bl	8000e80 <chMtxLock>
    chMtxUnlock(&mtx1);
 8001882:	0020      	movs	r0, r4
 8001884:	f7ff fa64 	bl	8000d50 <chMtxUnlock>
    chMtxLock(&mtx1);
 8001888:	0020      	movs	r0, r4
 800188a:	f7ff faf9 	bl	8000e80 <chMtxLock>
    chMtxUnlock(&mtx1);
 800188e:	0020      	movs	r0, r4
 8001890:	f7ff fa5e 	bl	8000d50 <chMtxUnlock>
    chMtxLock(&mtx1);
 8001894:	0020      	movs	r0, r4
 8001896:	f7ff faf3 	bl	8000e80 <chMtxLock>
    chMtxUnlock(&mtx1);
 800189a:	0020      	movs	r0, r4
 800189c:	f7ff fa58 	bl	8000d50 <chMtxUnlock>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80018a0:	7833      	ldrb	r3, [r6, #0]
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    chMtxLock(&mtx1);
    chMtxUnlock(&mtx1);
    n++;
 80018a2:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80018a4:	2b00      	cmp	r3, #0
 80018a6:	d0e3      	beq.n	8001870 <bmk12_execute+0x10>
  test_print("--- Score : ");
 80018a8:	4806      	ldr	r0, [pc, #24]	; (80018c4 <bmk12_execute+0x64>)
 80018aa:	f7fe fed1 	bl	8000650 <test_print>
  test_printn(n * 4);
 80018ae:	00a8      	lsls	r0, r5, #2
 80018b0:	f7fe fee6 	bl	8000680 <test_printn>
  test_println(" lock+unlock/S");
 80018b4:	4804      	ldr	r0, [pc, #16]	; (80018c8 <bmk12_execute+0x68>)
 80018b6:	f7fe feab 	bl	8000610 <test_println>
}
 80018ba:	bd70      	pop	{r4, r5, r6, pc}
 80018bc:	20000a54 	.word	0x20000a54
 80018c0:	20000c10 	.word	0x20000c10
 80018c4:	08005d60 	.word	0x08005d60
 80018c8:	08005d70 	.word	0x08005d70
 80018cc:	00000000 	.word	0x00000000

080018d0 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 80018d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80018d2:	464f      	mov	r7, r9
 80018d4:	4646      	mov	r6, r8
 80018d6:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80018d8:	4b14      	ldr	r3, [pc, #80]	; (800192c <bmk6_execute+0x5c>)
 80018da:	b083      	sub	sp, #12
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80018dc:	699b      	ldr	r3, [r3, #24]

  uint32_t n = 0;
 80018de:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 80018e0:	689d      	ldr	r5, [r3, #8]
  test_wait_tick();
 80018e2:	f7ff fe1d 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 80018e6:	f003 ff43 	bl	8005770 <test_start_timer.constprop.1>
 80018ea:	4b11      	ldr	r3, [pc, #68]	; (8001930 <bmk6_execute+0x60>)
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 80018ec:	2600      	movs	r6, #0
 80018ee:	4699      	mov	r9, r3
 80018f0:	4b10      	ldr	r3, [pc, #64]	; (8001934 <bmk6_execute+0x64>)
 80018f2:	4f11      	ldr	r7, [pc, #68]	; (8001938 <bmk6_execute+0x68>)
 80018f4:	4698      	mov	r8, r3

static void bmk6_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() + 1;
 80018f6:	3501      	adds	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 80018f8:	21a4      	movs	r1, #164	; 0xa4
 80018fa:	464b      	mov	r3, r9
 80018fc:	9600      	str	r6, [sp, #0]
 80018fe:	002a      	movs	r2, r5
 8001900:	0049      	lsls	r1, r1, #1
 8001902:	4640      	mov	r0, r8
 8001904:	f7ff f804 	bl	8000910 <chThdCreateStatic>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001908:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() + 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
    n++;
 800190a:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 800190c:	2b00      	cmp	r3, #0
 800190e:	d0f3      	beq.n	80018f8 <bmk6_execute+0x28>
  test_print("--- Score : ");
 8001910:	480a      	ldr	r0, [pc, #40]	; (800193c <bmk6_execute+0x6c>)
 8001912:	f7fe fe9d 	bl	8000650 <test_print>
  test_printn(n);
 8001916:	0020      	movs	r0, r4
 8001918:	f7fe feb2 	bl	8000680 <test_printn>
  test_println(" threads/S");
 800191c:	4808      	ldr	r0, [pc, #32]	; (8001940 <bmk6_execute+0x70>)
 800191e:	f7fe fe77 	bl	8000610 <test_println>
}
 8001922:	b003      	add	sp, #12
 8001924:	bc0c      	pop	{r2, r3}
 8001926:	4690      	mov	r8, r2
 8001928:	4699      	mov	r9, r3
 800192a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800192c:	20000ac0 	.word	0x20000ac0
 8001930:	08003db1 	.word	0x08003db1
 8001934:	20000c58 	.word	0x20000c58
 8001938:	20000c10 	.word	0x20000c10
 800193c:	08005d60 	.word	0x08005d60
 8001940:	08005d80 	.word	0x08005d80
	...

08001950 <bmk11_execute>:
static void bmk11_setup(void) {

  chSemObjectInit(&sem1, 1);
}

static void bmk11_execute(void) {
 8001950:	b570      	push	{r4, r5, r6, lr}
  uint32_t n = 0;
 8001952:	2500      	movs	r5, #0

  test_wait_tick();
 8001954:	f7ff fde4 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 8001958:	f003 ff0a 	bl	8005770 <test_start_timer.constprop.1>
 800195c:	4c13      	ldr	r4, [pc, #76]	; (80019ac <bmk11_execute+0x5c>)
 800195e:	4e14      	ldr	r6, [pc, #80]	; (80019b0 <bmk11_execute+0x60>)
  do {
    chSemWait(&sem1);
 8001960:	0020      	movs	r0, r4
 8001962:	f7ff f835 	bl	80009d0 <chSemWait>
    chSemSignal(&sem1);
 8001966:	0020      	movs	r0, r4
 8001968:	f7fe ffba 	bl	80008e0 <chSemSignal>
    chSemWait(&sem1);
 800196c:	0020      	movs	r0, r4
 800196e:	f7ff f82f 	bl	80009d0 <chSemWait>
    chSemSignal(&sem1);
 8001972:	0020      	movs	r0, r4
 8001974:	f7fe ffb4 	bl	80008e0 <chSemSignal>
    chSemWait(&sem1);
 8001978:	0020      	movs	r0, r4
 800197a:	f7ff f829 	bl	80009d0 <chSemWait>
    chSemSignal(&sem1);
 800197e:	0020      	movs	r0, r4
 8001980:	f7fe ffae 	bl	80008e0 <chSemSignal>
    chSemWait(&sem1);
 8001984:	0020      	movs	r0, r4
 8001986:	f7ff f823 	bl	80009d0 <chSemWait>
    chSemSignal(&sem1);
 800198a:	0020      	movs	r0, r4
 800198c:	f7fe ffa8 	bl	80008e0 <chSemSignal>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001990:	7833      	ldrb	r3, [r6, #0]
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    chSemWait(&sem1);
    chSemSignal(&sem1);
    n++;
 8001992:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001994:	2b00      	cmp	r3, #0
 8001996:	d0e3      	beq.n	8001960 <bmk11_execute+0x10>
  test_print("--- Score : ");
 8001998:	4806      	ldr	r0, [pc, #24]	; (80019b4 <bmk11_execute+0x64>)
 800199a:	f7fe fe59 	bl	8000650 <test_print>
  test_printn(n * 4);
 800199e:	00a8      	lsls	r0, r5, #2
 80019a0:	f7fe fe6e 	bl	8000680 <test_printn>
  test_println(" wait+signal/S");
 80019a4:	4804      	ldr	r0, [pc, #16]	; (80019b8 <bmk11_execute+0x68>)
 80019a6:	f7fe fe33 	bl	8000610 <test_println>
}
 80019aa:	bd70      	pop	{r4, r5, r6, pc}
 80019ac:	200006c0 	.word	0x200006c0
 80019b0:	20000c10 	.word	0x20000c10
 80019b4:	08005d60 	.word	0x08005d60
 80019b8:	08005d8c 	.word	0x08005d8c
 80019bc:	00000000 	.word	0x00000000

080019c0 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 80019c0:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80019c2:	4c07      	ldr	r4, [pc, #28]	; (80019e0 <thread3+0x20>)

  (void)p;
  while (!chThdShouldTerminateX())
 80019c4:	69a3      	ldr	r3, [r4, #24]
 80019c6:	7f5b      	ldrb	r3, [r3, #29]
 80019c8:	075b      	lsls	r3, r3, #29
 80019ca:	d408      	bmi.n	80019de <thread3+0x1e>
 80019cc:	2504      	movs	r5, #4
 80019ce:	4e05      	ldr	r6, [pc, #20]	; (80019e4 <thread3+0x24>)
    chSemWait(&sem1);
 80019d0:	0030      	movs	r0, r6
 80019d2:	f7fe fffd 	bl	80009d0 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 80019d6:	69a3      	ldr	r3, [r4, #24]
 80019d8:	7f5b      	ldrb	r3, [r3, #29]
 80019da:	421d      	tst	r5, r3
 80019dc:	d0f8      	beq.n	80019d0 <thread3+0x10>
    chSemWait(&sem1);
}
 80019de:	bd70      	pop	{r4, r5, r6, pc}
 80019e0:	20000ac0 	.word	0x20000ac0
 80019e4:	200006c0 	.word	0x200006c0
	...

080019f0 <bmk10_execute>:
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
 80019f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80019f2:	4647      	mov	r7, r8
 80019f4:	b480      	push	{r7}
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;

  test_wait_tick();
 80019f6:	f7ff fd93 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 80019fa:	f003 feb9 	bl	8005770 <test_start_timer.constprop.1>
 80019fe:	4b15      	ldr	r3, [pc, #84]	; (8001a54 <bmk10_execute+0x64>)

static void tmo(void *param) {(void)param;}

static void bmk10_execute(void) {
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8001a00:	2400      	movs	r4, #0
 8001a02:	4698      	mov	r8, r3
 8001a04:	4f14      	ldr	r7, [pc, #80]	; (8001a58 <bmk10_execute+0x68>)
 8001a06:	4e15      	ldr	r6, [pc, #84]	; (8001a5c <bmk10_execute+0x6c>)
 8001a08:	4d15      	ldr	r5, [pc, #84]	; (8001a60 <bmk10_execute+0x70>)
 8001a0a:	b672      	cpsid	i

  test_wait_tick();
  test_start_timer(1000);
  do {
    chSysLock();
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8001a0c:	2300      	movs	r3, #0
 8001a0e:	003a      	movs	r2, r7
 8001a10:	0030      	movs	r0, r6
 8001a12:	2101      	movs	r1, #1
 8001a14:	f7ff fbe4 	bl	80011e0 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8001a18:	2300      	movs	r3, #0
 8001a1a:	003a      	movs	r2, r7
 8001a1c:	4911      	ldr	r1, [pc, #68]	; (8001a64 <bmk10_execute+0x74>)
 8001a1e:	0028      	movs	r0, r5
 8001a20:	f7ff fbde 	bl	80011e0 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8001a24:	0030      	movs	r0, r6
 8001a26:	f7ff fb9b 	bl	8001160 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8001a2a:	0028      	movs	r0, r5
 8001a2c:	f7ff fb98 	bl	8001160 <chVTDoResetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a30:	b662      	cpsie	i
    chSysUnlock();
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001a32:	4643      	mov	r3, r8
 8001a34:	781b      	ldrb	r3, [r3, #0]
    chVTDoSetI(&vt1, 1, tmo, NULL);
    chVTDoSetI(&vt2, 10000, tmo, NULL);
    chVTDoResetI(&vt1);
    chVTDoResetI(&vt2);
    chSysUnlock();
    n++;
 8001a36:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001a38:	2b00      	cmp	r3, #0
 8001a3a:	d0e6      	beq.n	8001a0a <bmk10_execute+0x1a>
  test_print("--- Score : ");
 8001a3c:	480a      	ldr	r0, [pc, #40]	; (8001a68 <bmk10_execute+0x78>)
 8001a3e:	f7fe fe07 	bl	8000650 <test_print>
  test_printn(n * 2);
 8001a42:	0060      	lsls	r0, r4, #1
 8001a44:	f7fe fe1c 	bl	8000680 <test_printn>
  test_println(" timers/S");
 8001a48:	4808      	ldr	r0, [pc, #32]	; (8001a6c <bmk10_execute+0x7c>)
 8001a4a:	f7fe fde1 	bl	8000610 <test_println>
}
 8001a4e:	bc04      	pop	{r2}
 8001a50:	4690      	mov	r8, r2
 8001a52:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001a54:	20000c10 	.word	0x20000c10
 8001a58:	080016d1 	.word	0x080016d1
 8001a5c:	20000974 	.word	0x20000974
 8001a60:	20000a88 	.word	0x20000a88
 8001a64:	00002710 	.word	0x00002710
 8001a68:	08005d60 	.word	0x08005d60
 8001a6c:	08005d9c 	.word	0x08005d9c

08001a70 <bmk9_execute>:
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001a70:	2200      	movs	r2, #0
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 8001a72:	b570      	push	{r4, r5, r6, lr}
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
  n = 0;
 8001a74:	2500      	movs	r5, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001a76:	4c22      	ldr	r4, [pc, #136]	; (8001b00 <bmk9_execute+0x90>)
  iqp->q_buffer  = bp;
 8001a78:	4b22      	ldr	r3, [pc, #136]	; (8001b04 <bmk9_execute+0x94>)
 8001a7a:	6024      	str	r4, [r4, #0]
 8001a7c:	60e3      	str	r3, [r4, #12]
  iqp->q_rdptr   = bp;
 8001a7e:	61a3      	str	r3, [r4, #24]
  iqp->q_wrptr   = bp;
 8001a80:	6163      	str	r3, [r4, #20]
  tqp->p_prev = (thread_t *)tqp;
 8001a82:	6064      	str	r4, [r4, #4]
  iqp->q_top     = bp + size;
 8001a84:	3310      	adds	r3, #16
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001a86:	60a2      	str	r2, [r4, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8001a88:	6123      	str	r3, [r4, #16]
  iqp->q_notify  = infy;
 8001a8a:	61e2      	str	r2, [r4, #28]
  iqp->q_link    = link;
 8001a8c:	6222      	str	r2, [r4, #32]
  test_wait_tick();
 8001a8e:	f7ff fd47 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 8001a92:	f003 fe6d 	bl	8005770 <test_start_timer.constprop.1>
 8001a96:	4e1c      	ldr	r6, [pc, #112]	; (8001b08 <bmk9_execute+0x98>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001a98:	b672      	cpsid	i
  do {
    chSysLock();
    chIQPutI(&iq, 0);
 8001a9a:	2100      	movs	r1, #0
 8001a9c:	0020      	movs	r0, r4
 8001a9e:	f7fe ffc7 	bl	8000a30 <chIQPutI>
    chIQPutI(&iq, 1);
 8001aa2:	2101      	movs	r1, #1
 8001aa4:	0020      	movs	r0, r4
 8001aa6:	f7fe ffc3 	bl	8000a30 <chIQPutI>
    chIQPutI(&iq, 2);
 8001aaa:	2102      	movs	r1, #2
 8001aac:	0020      	movs	r0, r4
 8001aae:	f7fe ffbf 	bl	8000a30 <chIQPutI>
    chIQPutI(&iq, 3);
 8001ab2:	2103      	movs	r1, #3
 8001ab4:	0020      	movs	r0, r4
 8001ab6:	f7fe ffbb 	bl	8000a30 <chIQPutI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001aba:	b662      	cpsie	i
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8001abc:	2101      	movs	r1, #1
 8001abe:	0020      	movs	r0, r4
 8001ac0:	4249      	negs	r1, r1
 8001ac2:	f7ff fcf5 	bl	80014b0 <chIQGetTimeout>
 8001ac6:	2101      	movs	r1, #1
 8001ac8:	0020      	movs	r0, r4
 8001aca:	4249      	negs	r1, r1
 8001acc:	f7ff fcf0 	bl	80014b0 <chIQGetTimeout>
 8001ad0:	2101      	movs	r1, #1
 8001ad2:	0020      	movs	r0, r4
 8001ad4:	4249      	negs	r1, r1
 8001ad6:	f7ff fceb 	bl	80014b0 <chIQGetTimeout>
 8001ada:	2101      	movs	r1, #1
 8001adc:	0020      	movs	r0, r4
 8001ade:	4249      	negs	r1, r1
 8001ae0:	f7ff fce6 	bl	80014b0 <chIQGetTimeout>
    (void)chIQGet(&iq);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001ae4:	7833      	ldrb	r3, [r6, #0]
    chSysUnlock();
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    (void)chIQGet(&iq);
    n++;
 8001ae6:	3501      	adds	r5, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001ae8:	2b00      	cmp	r3, #0
 8001aea:	d0d5      	beq.n	8001a98 <bmk9_execute+0x28>
  test_print("--- Score : ");
 8001aec:	4807      	ldr	r0, [pc, #28]	; (8001b0c <bmk9_execute+0x9c>)
 8001aee:	f7fe fdaf 	bl	8000650 <test_print>
  test_printn(n * 4);
 8001af2:	00a8      	lsls	r0, r5, #2
 8001af4:	f7fe fdc4 	bl	8000680 <test_printn>
  test_println(" bytes/S");
 8001af8:	4805      	ldr	r0, [pc, #20]	; (8001b10 <bmk9_execute+0xa0>)
 8001afa:	f7fe fd89 	bl	8000610 <test_println>
}
 8001afe:	bd70      	pop	{r4, r5, r6, pc}
 8001b00:	20000a64 	.word	0x20000a64
 8001b04:	20000960 	.word	0x20000960
 8001b08:	20000c10 	.word	0x20000c10
 8001b0c:	08005d60 	.word	0x08005d60
 8001b10:	08005da8 	.word	0x08005da8
	...

08001b20 <bmk8_execute>:
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8001b20:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001b22:	464f      	mov	r7, r9
 8001b24:	4646      	mov	r6, r8
  uint32_t n;

  n = 0;
 8001b26:	2300      	movs	r3, #0
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
}

static void bmk8_execute(void) {
 8001b28:	b4c0      	push	{r6, r7}
 8001b2a:	b085      	sub	sp, #20
  uint32_t n;

  n = 0;
 8001b2c:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8001b2e:	f7ff fcf7 	bl	8001520 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001b32:	4b2d      	ldr	r3, [pc, #180]	; (8001be8 <bmk8_execute+0xc8>)
 8001b34:	27a4      	movs	r7, #164	; 0xa4
 8001b36:	4698      	mov	r8, r3
 8001b38:	4b2c      	ldr	r3, [pc, #176]	; (8001bec <bmk8_execute+0xcc>)
 8001b3a:	4c2d      	ldr	r4, [pc, #180]	; (8001bf0 <bmk8_execute+0xd0>)
 8001b3c:	4699      	mov	r9, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001b3e:	699b      	ldr	r3, [r3, #24]
 8001b40:	007f      	lsls	r7, r7, #1
 8001b42:	689a      	ldr	r2, [r3, #8]
 8001b44:	ae03      	add	r6, sp, #12
 8001b46:	4643      	mov	r3, r8
 8001b48:	0039      	movs	r1, r7
 8001b4a:	3a01      	subs	r2, #1
 8001b4c:	9600      	str	r6, [sp, #0]
 8001b4e:	0020      	movs	r0, r4
 8001b50:	f7fe fede 	bl	8000910 <chThdCreateStatic>
 8001b54:	464b      	mov	r3, r9
 8001b56:	699b      	ldr	r3, [r3, #24]
 8001b58:	4d26      	ldr	r5, [pc, #152]	; (8001bf4 <bmk8_execute+0xd4>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001b5a:	689a      	ldr	r2, [r3, #8]
  uint32_t n;

  n = 0;
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001b5c:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001b5e:	4643      	mov	r3, r8
 8001b60:	0039      	movs	r1, r7
 8001b62:	3a01      	subs	r2, #1
 8001b64:	19e0      	adds	r0, r4, r7
 8001b66:	9600      	str	r6, [sp, #0]
 8001b68:	f7fe fed2 	bl	8000910 <chThdCreateStatic>
 8001b6c:	464b      	mov	r3, r9
 8001b6e:	699b      	ldr	r3, [r3, #24]
 8001b70:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001b72:	689a      	ldr	r2, [r3, #8]
 8001b74:	23a4      	movs	r3, #164	; 0xa4
 8001b76:	009b      	lsls	r3, r3, #2
 8001b78:	18e0      	adds	r0, r4, r3
 8001b7a:	0039      	movs	r1, r7
 8001b7c:	4643      	mov	r3, r8
 8001b7e:	3a01      	subs	r2, #1
 8001b80:	9600      	str	r6, [sp, #0]
 8001b82:	f7fe fec5 	bl	8000910 <chThdCreateStatic>
 8001b86:	464b      	mov	r3, r9
 8001b88:	699b      	ldr	r3, [r3, #24]
 8001b8a:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001b8c:	689a      	ldr	r2, [r3, #8]
 8001b8e:	23f6      	movs	r3, #246	; 0xf6
 8001b90:	009b      	lsls	r3, r3, #2
 8001b92:	18e0      	adds	r0, r4, r3
 8001b94:	0039      	movs	r1, r7
 8001b96:	4643      	mov	r3, r8
 8001b98:	3a01      	subs	r2, #1
 8001b9a:	9600      	str	r6, [sp, #0]
 8001b9c:	f7fe feb8 	bl	8000910 <chThdCreateStatic>
 8001ba0:	464b      	mov	r3, r9
 8001ba2:	699b      	ldr	r3, [r3, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001ba4:	0039      	movs	r1, r7
 8001ba6:	689a      	ldr	r2, [r3, #8]
 8001ba8:	23a4      	movs	r3, #164	; 0xa4
 8001baa:	00db      	lsls	r3, r3, #3
 8001bac:	3a01      	subs	r2, #1
  test_wait_tick();

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001bae:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8001bb0:	18e0      	adds	r0, r4, r3
 8001bb2:	9600      	str	r6, [sp, #0]
 8001bb4:	4643      	mov	r3, r8
 8001bb6:	f7fe feab 	bl	8000910 <chThdCreateStatic>
 8001bba:	6128      	str	r0, [r5, #16]

  chThdSleepSeconds(1);
 8001bbc:	480e      	ldr	r0, [pc, #56]	; (8001bf8 <bmk8_execute+0xd8>)
 8001bbe:	f7ff fca7 	bl	8001510 <chThdSleep>
  test_terminate_threads();
 8001bc2:	f7fe fc95 	bl	80004f0 <test_terminate_threads>
  test_wait_threads();
 8001bc6:	f7ff fa1b 	bl	8001000 <test_wait_threads>

  test_print("--- Score : ");
 8001bca:	480c      	ldr	r0, [pc, #48]	; (8001bfc <bmk8_execute+0xdc>)
 8001bcc:	f7fe fd40 	bl	8000650 <test_print>
  test_printn(n);
 8001bd0:	9803      	ldr	r0, [sp, #12]
 8001bd2:	f7fe fd55 	bl	8000680 <test_printn>
  test_println(" ctxswc/S");
 8001bd6:	480a      	ldr	r0, [pc, #40]	; (8001c00 <bmk8_execute+0xe0>)
 8001bd8:	f7fe fd1a 	bl	8000610 <test_println>
}
 8001bdc:	b005      	add	sp, #20
 8001bde:	bc0c      	pop	{r2, r3}
 8001be0:	4690      	mov	r8, r2
 8001be2:	4699      	mov	r9, r3
 8001be4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001be6:	46c0      	nop			; (mov r8, r8)
 8001be8:	08001c11 	.word	0x08001c11
 8001bec:	20000ac0 	.word	0x20000ac0
 8001bf0:	20000c58 	.word	0x20000c58
 8001bf4:	20000a28 	.word	0x20000a28
 8001bf8:	00002710 	.word	0x00002710
 8001bfc:	08005d60 	.word	0x08005d60
 8001c00:	08005db4 	.word	0x08005db4
	...

08001c10 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8001c10:	b570      	push	{r4, r5, r6, lr}
 8001c12:	0004      	movs	r4, r0
    chThdYield();
    (*(uint32_t *)p) += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8001c14:	2504      	movs	r5, #4
 8001c16:	4e08      	ldr	r6, [pc, #32]	; (8001c38 <thread8+0x28>)
 */

static THD_FUNCTION(thread8, p) {

  do {
    chThdYield();
 8001c18:	f7fe fde2 	bl	80007e0 <chThdYield>
    chThdYield();
 8001c1c:	f7fe fde0 	bl	80007e0 <chThdYield>
    chThdYield();
 8001c20:	f7fe fdde 	bl	80007e0 <chThdYield>
    chThdYield();
 8001c24:	f7fe fddc 	bl	80007e0 <chThdYield>
    (*(uint32_t *)p) += 4;
 8001c28:	6823      	ldr	r3, [r4, #0]
 8001c2a:	3304      	adds	r3, #4
 8001c2c:	6023      	str	r3, [r4, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8001c2e:	69b3      	ldr	r3, [r6, #24]
 8001c30:	7f5b      	ldrb	r3, [r3, #29]
 8001c32:	421d      	tst	r5, r3
 8001c34:	d0f0      	beq.n	8001c18 <thread8+0x8>
}
 8001c36:	bd70      	pop	{r4, r5, r6, pc}
 8001c38:	20000ac0 	.word	0x20000ac0
 8001c3c:	00000000 	.word	0x00000000

08001c40 <bmk7_execute>:
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001c40:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001c42:	4647      	mov	r7, r8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001c44:	21a4      	movs	r1, #164	; 0xa4
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001c46:	b480      	push	{r7}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001c48:	2700      	movs	r7, #0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001c4a:	4b3e      	ldr	r3, [pc, #248]	; (8001d44 <bmk7_execute+0x104>)
 8001c4c:	4e3e      	ldr	r6, [pc, #248]	; (8001d48 <bmk7_execute+0x108>)
 8001c4e:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001c50:	699b      	ldr	r3, [r3, #24]
 8001c52:	4c3e      	ldr	r4, [pc, #248]	; (8001d4c <bmk7_execute+0x10c>)
 8001c54:	689a      	ldr	r2, [r3, #8]
static void bmk7_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static void bmk7_execute(void) {
 8001c56:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001c58:	0033      	movs	r3, r6
 8001c5a:	3205      	adds	r2, #5
 8001c5c:	0049      	lsls	r1, r1, #1
 8001c5e:	0020      	movs	r0, r4
 8001c60:	9700      	str	r7, [sp, #0]
 8001c62:	f7fe fe55 	bl	8000910 <chThdCreateStatic>
 8001c66:	4643      	mov	r3, r8
 8001c68:	4d39      	ldr	r5, [pc, #228]	; (8001d50 <bmk7_execute+0x110>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001c6a:	21a4      	movs	r1, #164	; 0xa4
}

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8001c6c:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001c6e:	0020      	movs	r0, r4
 8001c70:	699b      	ldr	r3, [r3, #24]
 8001c72:	3049      	adds	r0, #73	; 0x49
 8001c74:	689a      	ldr	r2, [r3, #8]
 8001c76:	0049      	lsls	r1, r1, #1
 8001c78:	0033      	movs	r3, r6
 8001c7a:	3204      	adds	r2, #4
 8001c7c:	30ff      	adds	r0, #255	; 0xff
 8001c7e:	9700      	str	r7, [sp, #0]
 8001c80:	f7fe fe46 	bl	8000910 <chThdCreateStatic>
 8001c84:	4643      	mov	r3, r8
 8001c86:	699b      	ldr	r3, [r3, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001c88:	21a4      	movs	r1, #164	; 0xa4
 8001c8a:	689a      	ldr	r2, [r3, #8]
 8001c8c:	23a4      	movs	r3, #164	; 0xa4
 8001c8e:	009b      	lsls	r3, r3, #2

static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8001c90:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001c92:	3203      	adds	r2, #3
 8001c94:	18e0      	adds	r0, r4, r3
 8001c96:	0049      	lsls	r1, r1, #1
 8001c98:	0033      	movs	r3, r6
 8001c9a:	9700      	str	r7, [sp, #0]
 8001c9c:	f7fe fe38 	bl	8000910 <chThdCreateStatic>
 8001ca0:	4643      	mov	r3, r8
 8001ca2:	699b      	ldr	r3, [r3, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001ca4:	21a4      	movs	r1, #164	; 0xa4
 8001ca6:	689a      	ldr	r2, [r3, #8]
 8001ca8:	23f6      	movs	r3, #246	; 0xf6
 8001caa:	009b      	lsls	r3, r3, #2
static void bmk7_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 8001cac:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001cae:	3202      	adds	r2, #2
 8001cb0:	18e0      	adds	r0, r4, r3
 8001cb2:	0049      	lsls	r1, r1, #1
 8001cb4:	0033      	movs	r3, r6
 8001cb6:	9700      	str	r7, [sp, #0]
 8001cb8:	f7fe fe2a 	bl	8000910 <chThdCreateStatic>
 8001cbc:	4643      	mov	r3, r8
 8001cbe:	699b      	ldr	r3, [r3, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001cc0:	21a4      	movs	r1, #164	; 0xa4
 8001cc2:	689a      	ldr	r2, [r3, #8]
 8001cc4:	23a4      	movs	r3, #164	; 0xa4
 8001cc6:	00db      	lsls	r3, r3, #3
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 8001cc8:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001cca:	3201      	adds	r2, #1
 8001ccc:	18e0      	adds	r0, r4, r3
 8001cce:	0049      	lsls	r1, r1, #1
 8001cd0:	0033      	movs	r3, r6
 8001cd2:	9700      	str	r7, [sp, #0]
 8001cd4:	f7fe fe1c 	bl	8000910 <chThdCreateStatic>

  n = 0;
 8001cd8:	2400      	movs	r4, #0

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 8001cda:	6128      	str	r0, [r5, #16]

  n = 0;
  test_wait_tick();
 8001cdc:	f7ff fc20 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 8001ce0:	f003 fd46 	bl	8005770 <test_start_timer.constprop.1>
 8001ce4:	4d1b      	ldr	r5, [pc, #108]	; (8001d54 <bmk7_execute+0x114>)
 8001ce6:	4e1c      	ldr	r6, [pc, #112]	; (8001d58 <bmk7_execute+0x118>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ce8:	b672      	cpsid	i
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001cea:	2100      	movs	r1, #0
 8001cec:	0028      	movs	r0, r5
 8001cee:	f7ff f9ff 	bl	80010f0 <chSemResetI>
  chSchRescheduleS();
 8001cf2:	f7fe fda5 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cf6:	b662      	cpsie	i
    chSemReset(&sem1, 0);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001cf8:	7833      	ldrb	r3, [r6, #0]
  n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chSemReset(&sem1, 0);
    n++;
 8001cfa:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001cfc:	2b00      	cmp	r3, #0
 8001cfe:	d0f3      	beq.n	8001ce8 <bmk7_execute+0xa8>
  test_terminate_threads();
 8001d00:	f7fe fbf6 	bl	80004f0 <test_terminate_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001d04:	b672      	cpsid	i
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8001d06:	2100      	movs	r1, #0
 8001d08:	0028      	movs	r0, r5
 8001d0a:	f7ff f9f1 	bl	80010f0 <chSemResetI>
  chSchRescheduleS();
 8001d0e:	f7fe fd97 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d12:	b662      	cpsie	i
  chSemReset(&sem1, 0);
  test_wait_threads();
 8001d14:	f7ff f974 	bl	8001000 <test_wait_threads>

  test_print("--- Score : ");
 8001d18:	4810      	ldr	r0, [pc, #64]	; (8001d5c <bmk7_execute+0x11c>)
 8001d1a:	f7fe fc99 	bl	8000650 <test_print>
  test_printn(n);
 8001d1e:	0020      	movs	r0, r4
 8001d20:	f7fe fcae 	bl	8000680 <test_printn>
  test_print(" reschedules/S, ");
 8001d24:	480e      	ldr	r0, [pc, #56]	; (8001d60 <bmk7_execute+0x120>)
 8001d26:	f7fe fc93 	bl	8000650 <test_print>
  test_printn(n * 6);
 8001d2a:	0060      	lsls	r0, r4, #1
 8001d2c:	1900      	adds	r0, r0, r4
 8001d2e:	0040      	lsls	r0, r0, #1
 8001d30:	f7fe fca6 	bl	8000680 <test_printn>
  test_println(" ctxswc/S");
 8001d34:	480b      	ldr	r0, [pc, #44]	; (8001d64 <bmk7_execute+0x124>)
 8001d36:	f7fe fc6b 	bl	8000610 <test_println>
}
 8001d3a:	b002      	add	sp, #8
 8001d3c:	bc04      	pop	{r2}
 8001d3e:	4690      	mov	r8, r2
 8001d40:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001d42:	46c0      	nop			; (mov r8, r8)
 8001d44:	20000ac0 	.word	0x20000ac0
 8001d48:	080019c1 	.word	0x080019c1
 8001d4c:	20000c58 	.word	0x20000c58
 8001d50:	20000a28 	.word	0x20000a28
 8001d54:	200006c0 	.word	0x200006c0
 8001d58:	20000c10 	.word	0x20000c10
 8001d5c:	08005d60 	.word	0x08005d60
 8001d60:	08005dc0 	.word	0x08005dc0
 8001d64:	08005db4 	.word	0x08005db4
	...

08001d70 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8001d70:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001d72:	464f      	mov	r7, r9
 8001d74:	4646      	mov	r6, r8
 8001d76:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001d78:	4b15      	ldr	r3, [pc, #84]	; (8001dd0 <bmk5_execute+0x60>)
 8001d7a:	b083      	sub	sp, #12
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8001d7c:	699b      	ldr	r3, [r3, #24]

  uint32_t n = 0;
 8001d7e:	2400      	movs	r4, #0
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8001d80:	689d      	ldr	r5, [r3, #8]
  test_wait_tick();
 8001d82:	f7ff fbcd 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 8001d86:	f003 fcf3 	bl	8005770 <test_start_timer.constprop.1>
 8001d8a:	4b12      	ldr	r3, [pc, #72]	; (8001dd4 <bmk5_execute+0x64>)
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8001d8c:	2600      	movs	r6, #0
 8001d8e:	4699      	mov	r9, r3
 8001d90:	4b11      	ldr	r3, [pc, #68]	; (8001dd8 <bmk5_execute+0x68>)
 8001d92:	4f12      	ldr	r7, [pc, #72]	; (8001ddc <bmk5_execute+0x6c>)
 8001d94:	4698      	mov	r8, r3

static void bmk5_execute(void) {

  uint32_t n = 0;
  void *wap = wa[0];
  tprio_t prio = chThdGetPriorityX() - 1;
 8001d96:	3d01      	subs	r5, #1
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8001d98:	21a4      	movs	r1, #164	; 0xa4
 8001d9a:	464b      	mov	r3, r9
 8001d9c:	002a      	movs	r2, r5
 8001d9e:	0049      	lsls	r1, r1, #1
 8001da0:	9600      	str	r6, [sp, #0]
 8001da2:	4640      	mov	r0, r8
 8001da4:	f7fe fdb4 	bl	8000910 <chThdCreateStatic>
 8001da8:	f7ff f912 	bl	8000fd0 <chThdWait>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001dac:	783b      	ldrb	r3, [r7, #0]
  tprio_t prio = chThdGetPriorityX() - 1;
  test_wait_tick();
  test_start_timer(1000);
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
    n++;
 8001dae:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8001db0:	2b00      	cmp	r3, #0
 8001db2:	d0f1      	beq.n	8001d98 <bmk5_execute+0x28>
  test_print("--- Score : ");
 8001db4:	480a      	ldr	r0, [pc, #40]	; (8001de0 <bmk5_execute+0x70>)
 8001db6:	f7fe fc4b 	bl	8000650 <test_print>
  test_printn(n);
 8001dba:	0020      	movs	r0, r4
 8001dbc:	f7fe fc60 	bl	8000680 <test_printn>
  test_println(" threads/S");
 8001dc0:	4808      	ldr	r0, [pc, #32]	; (8001de4 <bmk5_execute+0x74>)
 8001dc2:	f7fe fc25 	bl	8000610 <test_println>
}
 8001dc6:	b003      	add	sp, #12
 8001dc8:	bc0c      	pop	{r2, r3}
 8001dca:	4690      	mov	r8, r2
 8001dcc:	4699      	mov	r9, r3
 8001dce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001dd0:	20000ac0 	.word	0x20000ac0
 8001dd4:	08003db1 	.word	0x08003db1
 8001dd8:	20000c58 	.word	0x20000c58
 8001ddc:	20000c10 	.word	0x20000c10
 8001de0:	08005d60 	.word	0x08005d60
 8001de4:	08005d80 	.word	0x08005d80
	...

08001df0 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8001df0:	4bb2      	ldr	r3, [pc, #712]	; (80020bc <main+0x2cc>)
 8001df2:	2101      	movs	r1, #1
}

/*
 * Application entry point.
 */
int main(void) {
 8001df4:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001df6:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001df8:	4644      	mov	r4, r8
 8001dfa:	2200      	movs	r2, #0
 8001dfc:	465f      	mov	r7, fp
 8001dfe:	4656      	mov	r6, sl
 8001e00:	464d      	mov	r5, r9
 8001e02:	4249      	negs	r1, r1
 8001e04:	b4f0      	push	{r4, r5, r6, r7}
 8001e06:	6299      	str	r1, [r3, #40]	; 0x28
 8001e08:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001e0a:	6918      	ldr	r0, [r3, #16]
 8001e0c:	6119      	str	r1, [r3, #16]
 8001e0e:	611a      	str	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001e10:	68d9      	ldr	r1, [r3, #12]
 8001e12:	48ab      	ldr	r0, [pc, #684]	; (80020c0 <main+0x2d0>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001e14:	2480      	movs	r4, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001e16:	4301      	orrs	r1, r0

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001e18:	2080      	movs	r0, #128	; 0x80
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001e1a:	60d9      	str	r1, [r3, #12]
 8001e1c:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001e1e:	69d9      	ldr	r1, [r3, #28]
 8001e20:	0540      	lsls	r0, r0, #21
 8001e22:	4301      	orrs	r1, r0
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001e24:	48a7      	ldr	r0, [pc, #668]	; (80020c4 <main+0x2d4>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001e26:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001e28:	6801      	ldr	r1, [r0, #0]
 8001e2a:	0064      	lsls	r4, r4, #1
 8001e2c:	4321      	orrs	r1, r4
 8001e2e:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8001e30:	21c0      	movs	r1, #192	; 0xc0
 8001e32:	6a18      	ldr	r0, [r3, #32]
 8001e34:	0089      	lsls	r1, r1, #2
 8001e36:	4001      	ands	r1, r0
 8001e38:	2080      	movs	r0, #128	; 0x80
 8001e3a:	b087      	sub	sp, #28
 8001e3c:	0080      	lsls	r0, r0, #2
 8001e3e:	4281      	cmp	r1, r0
 8001e40:	d003      	beq.n	8001e4a <main+0x5a>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001e42:	2180      	movs	r1, #128	; 0x80
 8001e44:	0249      	lsls	r1, r1, #9
 8001e46:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8001e48:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8001e4a:	2080      	movs	r0, #128	; 0x80
 8001e4c:	4b9b      	ldr	r3, [pc, #620]	; (80020bc <main+0x2cc>)
 8001e4e:	0200      	lsls	r0, r0, #8
 8001e50:	6a1a      	ldr	r2, [r3, #32]
 8001e52:	4202      	tst	r2, r0
 8001e54:	d107      	bne.n	8001e66 <main+0x76>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8001e56:	2280      	movs	r2, #128	; 0x80
 8001e58:	6a19      	ldr	r1, [r3, #32]
 8001e5a:	0092      	lsls	r2, r2, #2
 8001e5c:	4311      	orrs	r1, r2
 8001e5e:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8001e60:	6a1a      	ldr	r2, [r3, #32]
 8001e62:	4302      	orrs	r2, r0
 8001e64:	621a      	str	r2, [r3, #32]
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001e66:	22bc      	movs	r2, #188	; 0xbc
 8001e68:	4d94      	ldr	r5, [pc, #592]	; (80020bc <main+0x2cc>)
 8001e6a:	03d2      	lsls	r2, r2, #15
 8001e6c:	696b      	ldr	r3, [r5, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001e6e:	21fc      	movs	r1, #252	; 0xfc
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001e70:	4313      	orrs	r3, r2
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e72:	2290      	movs	r2, #144	; 0x90
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001e74:	616b      	str	r3, [r5, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e76:	2300      	movs	r3, #0
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001e78:	20a0      	movs	r0, #160	; 0xa0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e7a:	05d2      	lsls	r2, r2, #23
  gpiop->OSPEEDR = config->ospeedr;
 8001e7c:	0609      	lsls	r1, r1, #24
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e7e:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e80:	6091      	str	r1, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e82:	4991      	ldr	r1, [pc, #580]	; (80020c8 <main+0x2d8>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001e84:	0580      	lsls	r0, r0, #22

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001e86:	60d1      	str	r1, [r2, #12]
  gpiop->ODR     = config->odr;
 8001e88:	4990      	ldr	r1, [pc, #576]	; (80020cc <main+0x2dc>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001e8a:	4c91      	ldr	r4, [pc, #580]	; (80020d0 <main+0x2e0>)
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001e8c:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8001e8e:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8001e90:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001e92:	6010      	str	r0, [r2, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001e94:	20fc      	movs	r0, #252	; 0xfc
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e96:	4a8f      	ldr	r2, [pc, #572]	; (80020d4 <main+0x2e4>)
  gpiop->OSPEEDR = config->ospeedr;
 8001e98:	0080      	lsls	r0, r0, #2
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001e9a:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001e9c:	6090      	str	r0, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001e9e:	488e      	ldr	r0, [pc, #568]	; (80020d8 <main+0x2e8>)
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001ea0:	26c0      	movs	r6, #192	; 0xc0
 8001ea2:	60d0      	str	r0, [r2, #12]
  gpiop->ODR     = config->odr;
 8001ea4:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8001ea6:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8001ea8:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001eaa:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001eac:	4a8b      	ldr	r2, [pc, #556]	; (80020dc <main+0x2ec>)
 8001eae:	0636      	lsls	r6, r6, #24
 8001eb0:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001eb2:	6094      	str	r4, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001eb4:	4c8a      	ldr	r4, [pc, #552]	; (80020e0 <main+0x2f0>)
 8001eb6:	27c3      	movs	r7, #195	; 0xc3
 8001eb8:	60d4      	str	r4, [r2, #12]
  gpiop->ODR     = config->odr;
 8001eba:	4c8a      	ldr	r4, [pc, #552]	; (80020e4 <main+0x2f4>)
 8001ebc:	00bf      	lsls	r7, r7, #2
 8001ebe:	6154      	str	r4, [r2, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001ec0:	24a0      	movs	r4, #160	; 0xa0
 8001ec2:	02e4      	lsls	r4, r4, #11

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8001ec4:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8001ec6:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001ec8:	6014      	str	r4, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001eca:	4a87      	ldr	r2, [pc, #540]	; (80020e8 <main+0x2f8>)
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001ecc:	2401      	movs	r4, #1
 8001ece:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001ed0:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001ed2:	60d0      	str	r0, [r2, #12]
  gpiop->ODR     = config->odr;
 8001ed4:	6151      	str	r1, [r2, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001ed6:	4885      	ldr	r0, [pc, #532]	; (80020ec <main+0x2fc>)
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8001ed8:	6213      	str	r3, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8001eda:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001edc:	6013      	str	r3, [r2, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001ede:	4a84      	ldr	r2, [pc, #528]	; (80020f0 <main+0x300>)
 8001ee0:	6053      	str	r3, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001ee2:	6093      	str	r3, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8001ee4:	60d0      	str	r0, [r2, #12]
  gpiop->ODR     = config->odr;
 8001ee6:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8001ee8:	6213      	str	r3, [r2, #32]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8001eea:	4982      	ldr	r1, [pc, #520]	; (80020f4 <main+0x304>)
  gpiop->AFRH    = config->afrh;
 8001eec:	6253      	str	r3, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001eee:	6013      	str	r3, [r2, #0]
 8001ef0:	4a81      	ldr	r2, [pc, #516]	; (80020f8 <main+0x308>)
 8001ef2:	c202      	stmia	r2!, {r1}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8001ef4:	4980      	ldr	r1, [pc, #512]	; (80020f8 <main+0x308>)
 8001ef6:	604a      	str	r2, [r1, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001ef8:	000a      	movs	r2, r1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001efa:	320c      	adds	r2, #12
 8001efc:	60ca      	str	r2, [r1, #12]
  tqp->p_prev = (thread_t *)tqp;
 8001efe:	610a      	str	r2, [r1, #16]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001f00:	000a      	movs	r2, r1
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8001f02:	0008      	movs	r0, r1
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8001f04:	3254      	adds	r2, #84	; 0x54
 8001f06:	618a      	str	r2, [r1, #24]
  iqp->q_rdptr   = bp;
 8001f08:	624a      	str	r2, [r1, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8001f0a:	620a      	str	r2, [r1, #32]
  iqp->q_top     = bp + size;
 8001f0c:	3210      	adds	r2, #16
 8001f0e:	61ca      	str	r2, [r1, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8001f10:	63c2      	str	r2, [r0, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8001f12:	6482      	str	r2, [r0, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8001f14:	6442      	str	r2, [r0, #68]	; 0x44
  oqp->q_top     = bp + size;
 8001f16:	3210      	adds	r2, #16
 8001f18:	6402      	str	r2, [r0, #64]	; 0x40
  oqp->q_notify  = onfy;
 8001f1a:	4a78      	ldr	r2, [pc, #480]	; (80020fc <main+0x30c>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001f1c:	614b      	str	r3, [r1, #20]
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8001f1e:	64c2      	str	r2, [r0, #76]	; 0x4c
  oqp->q_link    = link;
 8001f20:	0002      	movs	r2, r0
 8001f22:	720c      	strb	r4, [r1, #8]
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8001f24:	628b      	str	r3, [r1, #40]	; 0x28
  iqp->q_link    = link;
 8001f26:	62c9      	str	r1, [r1, #44]	; 0x2c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001f28:	3130      	adds	r1, #48	; 0x30
 8001f2a:	6301      	str	r1, [r0, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8001f2c:	6341      	str	r1, [r0, #52]	; 0x34
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001f2e:	2110      	movs	r1, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8001f30:	6510      	str	r0, [r2, #80]	; 0x50
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8001f32:	4a73      	ldr	r2, [pc, #460]	; (8002100 <main+0x310>)
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001f34:	6381      	str	r1, [r0, #56]	; 0x38
 8001f36:	6742      	str	r2, [r0, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
 8001f38:	4a72      	ldr	r2, [pc, #456]	; (8002104 <main+0x314>)
 8001f3a:	6782      	str	r2, [r0, #120]	; 0x78
 8001f3c:	20c6      	movs	r0, #198	; 0xc6
 8001f3e:	4a72      	ldr	r2, [pc, #456]	; (8002108 <main+0x318>)
 8001f40:	0080      	lsls	r0, r0, #2
 8001f42:	5811      	ldr	r1, [r2, r0]
 8001f44:	0209      	lsls	r1, r1, #8
 8001f46:	0a09      	lsrs	r1, r1, #8
 8001f48:	4331      	orrs	r1, r6
 8001f4a:	5011      	str	r1, [r2, r0]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001f4c:	21c0      	movs	r1, #192	; 0xc0
 8001f4e:	0049      	lsls	r1, r1, #1
 8001f50:	4689      	mov	r9, r1
 8001f52:	2180      	movs	r1, #128	; 0x80
 8001f54:	4648      	mov	r0, r9
 8001f56:	0509      	lsls	r1, r1, #20
 8001f58:	5011      	str	r1, [r2, r0]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001f5a:	6011      	str	r1, [r2, #0]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001f5c:	69e9      	ldr	r1, [r5, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001f5e:	4e6b      	ldr	r6, [pc, #428]	; (800210c <main+0x31c>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001f60:	4321      	orrs	r1, r4
 8001f62:	61e9      	str	r1, [r5, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001f64:	68b1      	ldr	r1, [r6, #8]
 8001f66:	4321      	orrs	r1, r4
 8001f68:	60b1      	str	r1, [r6, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001f6a:	2180      	movs	r1, #128	; 0x80
 8001f6c:	4e68      	ldr	r6, [pc, #416]	; (8002110 <main+0x320>)
 8001f6e:	05c9      	lsls	r1, r1, #23
 8001f70:	628e      	str	r6, [r1, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001f72:	2601      	movs	r6, #1
 8001f74:	4276      	negs	r6, r6
 8001f76:	62ce      	str	r6, [r1, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001f78:	618b      	str	r3, [r1, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001f7a:	634b      	str	r3, [r1, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001f7c:	60cb      	str	r3, [r1, #12]
  STM32_ST_TIM->CR2    = 0;
 8001f7e:	604b      	str	r3, [r1, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001f80:	614c      	str	r4, [r1, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001f82:	600c      	str	r4, [r1, #0]
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001f84:	59d1      	ldr	r1, [r2, r7]
 8001f86:	0209      	lsls	r1, r1, #8
 8001f88:	0a09      	lsrs	r1, r1, #8
 8001f8a:	4688      	mov	r8, r1
 8001f8c:	2180      	movs	r1, #128	; 0x80
 8001f8e:	4640      	mov	r0, r8
 8001f90:	0609      	lsls	r1, r1, #24
 8001f92:	4308      	orrs	r0, r1
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001f94:	2180      	movs	r1, #128	; 0x80
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8001f96:	51d0      	str	r0, [r2, r7]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001f98:	4648      	mov	r0, r9
 8001f9a:	0209      	lsls	r1, r1, #8
 8001f9c:	5011      	str	r1, [r2, r0]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001f9e:	6011      	str	r1, [r2, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)(IRQn) < 0) {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001fa0:	495c      	ldr	r1, [pc, #368]	; (8002114 <main+0x324>)
 8001fa2:	4a5d      	ldr	r2, [pc, #372]	; (8002118 <main+0x328>)
 8001fa4:	6a08      	ldr	r0, [r1, #32]
 8001fa6:	4002      	ands	r2, r0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001fa8:	485c      	ldr	r0, [pc, #368]	; (800211c <main+0x32c>)
 8001faa:	620a      	str	r2, [r1, #32]
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8001fac:	0002      	movs	r2, r0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001fae:	2107      	movs	r1, #7
 8001fb0:	321c      	adds	r2, #28
 8001fb2:	61c2      	str	r2, [r0, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001fb4:	6202      	str	r2, [r0, #32]
 8001fb6:	4a5a      	ldr	r2, [pc, #360]	; (8002120 <main+0x330>)
  ch.vtlist.vt_delta = (systime_t)-1;
 8001fb8:	6246      	str	r6, [r0, #36]	; 0x24
 8001fba:	3207      	adds	r2, #7
 8001fbc:	4e59      	ldr	r6, [pc, #356]	; (8002124 <main+0x334>)
 8001fbe:	438a      	bics	r2, r1
 8001fc0:	6032      	str	r2, [r6, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001fc2:	4a59      	ldr	r2, [pc, #356]	; (8002128 <main+0x338>)
 8001fc4:	6000      	str	r0, [r0, #0]
 8001fc6:	438a      	bics	r2, r1
  tqp->p_prev = (thread_t *)tqp;
 8001fc8:	6040      	str	r0, [r0, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8001fca:	6083      	str	r3, [r0, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8001fcc:	6283      	str	r3, [r0, #40]	; 0x28
 8001fce:	4957      	ldr	r1, [pc, #348]	; (800212c <main+0x33c>)
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8001fd0:	6683      	str	r3, [r0, #104]	; 0x68
 8001fd2:	600a      	str	r2, [r1, #0]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001fd4:	4a56      	ldr	r2, [pc, #344]	; (8002130 <main+0x340>)
 8001fd6:	4957      	ldr	r1, [pc, #348]	; (8002134 <main+0x344>)
  default_heap.h_free.h.u.next = NULL;
 8001fd8:	6093      	str	r3, [r2, #8]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8001fda:	6011      	str	r1, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001fdc:	0011      	movs	r1, r2
 8001fde:	3110      	adds	r1, #16
 8001fe0:	6111      	str	r1, [r2, #16]
  tqp->p_prev = (thread_t *)tqp;
 8001fe2:	6151      	str	r1, [r2, #20]
  default_heap.h_free.h.u.next = NULL;
  default_heap.h_free.h.size = 0;
 8001fe4:	60d3      	str	r3, [r2, #12]
 8001fe6:	6193      	str	r3, [r2, #24]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001fe8:	214d      	movs	r1, #77	; 0x4d
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001fea:	2240      	movs	r2, #64	; 0x40
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001fec:	5443      	strb	r3, [r0, r1]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001fee:	6382      	str	r2, [r0, #56]	; 0x38
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001ff0:	66c2      	str	r2, [r0, #108]	; 0x6c
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001ff2:	0001      	movs	r1, r0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001ff4:	320e      	adds	r2, #14
 8001ff6:	5484      	strb	r4, [r0, r2]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001ff8:	0002      	movs	r2, r0
 8001ffa:	3154      	adds	r1, #84	; 0x54
 8001ffc:	3230      	adds	r2, #48	; 0x30
 8001ffe:	6541      	str	r1, [r0, #84]	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002000:	0001      	movs	r1, r0
 8002002:	6102      	str	r2, [r0, #16]
 8002004:	6142      	str	r2, [r0, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8002006:	6182      	str	r2, [r0, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8002008:	224c      	movs	r2, #76	; 0x4c
 800200a:	3158      	adds	r1, #88	; 0x58
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800200c:	6643      	str	r3, [r0, #100]	; 0x64
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800200e:	6483      	str	r3, [r0, #72]	; 0x48
  REG_INSERT(tp);
 8002010:	6400      	str	r0, [r0, #64]	; 0x40
 8002012:	6440      	str	r0, [r0, #68]	; 0x44
 8002014:	6581      	str	r1, [r0, #88]	; 0x58
  tqp->p_prev = (thread_t *)tqp;
 8002016:	65c1      	str	r1, [r0, #92]	; 0x5c
 8002018:	5484      	strb	r4, [r0, r2]
 800201a:	b662      	cpsie	i
 800201c:	4946      	ldr	r1, [pc, #280]	; (8002138 <main+0x348>)
 800201e:	6982      	ldr	r2, [r0, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8002020:	3078      	adds	r0, #120	; 0x78
 8002022:	6191      	str	r1, [r2, #24]
 8002024:	9300      	str	r3, [sp, #0]
 8002026:	2201      	movs	r2, #1
 8002028:	4b44      	ldr	r3, [pc, #272]	; (800213c <main+0x34c>)
 800202a:	21d8      	movs	r1, #216	; 0xd8
 800202c:	f7fe fc70 	bl	8000910 <chThdCreateStatic>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8002030:	4b43      	ldr	r3, [pc, #268]	; (8002140 <main+0x350>)
 8002032:	6183      	str	r3, [r0, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002034:	b672      	cpsid	i
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8002036:	4b30      	ldr	r3, [pc, #192]	; (80020f8 <main+0x308>)
 8002038:	7a1b      	ldrb	r3, [r3, #8]
 800203a:	2b01      	cmp	r3, #1
 800203c:	d104      	bne.n	8002048 <main+0x258>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 800203e:	2280      	movs	r2, #128	; 0x80
 8002040:	69ab      	ldr	r3, [r5, #24]
 8002042:	01d2      	lsls	r2, r2, #7
 8002044:	4313      	orrs	r3, r2
 8002046:	61ab      	str	r3, [r5, #24]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8002048:	2196      	movs	r1, #150	; 0x96
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800204a:	4b2b      	ldr	r3, [pc, #172]	; (80020f8 <main+0x308>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800204c:	0209      	lsls	r1, r1, #8
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 800204e:	6f5c      	ldr	r4, [r3, #116]	; 0x74
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8002050:	6f9b      	ldr	r3, [r3, #120]	; 0x78
 8002052:	0018      	movs	r0, r3
 8002054:	9303      	str	r3, [sp, #12]
 8002056:	f7fe f8bb 	bl	80001d0 <__aeabi_uidiv>

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800205a:	4b3a      	ldr	r3, [pc, #232]	; (8002144 <main+0x354>)
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800205c:	60e0      	str	r0, [r4, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800205e:	6063      	str	r3, [r4, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8002060:	2301      	movs	r3, #1
 8002062:	60a3      	str	r3, [r4, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8002064:	232e      	movs	r3, #46	; 0x2e
 8002066:	33ff      	adds	r3, #255	; 0xff
 8002068:	6023      	str	r3, [r4, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800206a:	3b2f      	subs	r3, #47	; 0x2f
 800206c:	3bff      	subs	r3, #255	; 0xff

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 800206e:	4a22      	ldr	r2, [pc, #136]	; (80020f8 <main+0x308>)
 8002070:	6223      	str	r3, [r4, #32]
 8002072:	3303      	adds	r3, #3
 8002074:	7213      	strb	r3, [r2, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002076:	b662      	cpsie	i
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9 and PA10 are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(1));       /* USART1 TX.       */
 8002078:	2080      	movs	r0, #128	; 0x80
 800207a:	0080      	lsls	r0, r0, #2
 800207c:	f003 fb10 	bl	80056a0 <_pal_lld_setgroupmode.constprop.5>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(1));      /* USART1 RX.       */
 8002080:	2080      	movs	r0, #128	; 0x80
 8002082:	00c0      	lsls	r0, r0, #3
 8002084:	f003 fb0c 	bl	80056a0 <_pal_lld_setgroupmode.constprop.5>

  /*
   * Creates the blinker threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8002088:	2400      	movs	r4, #0
 800208a:	21a4      	movs	r1, #164	; 0xa4
 800208c:	9400      	str	r4, [sp, #0]
 800208e:	4b2e      	ldr	r3, [pc, #184]	; (8002148 <main+0x358>)
 8002090:	2240      	movs	r2, #64	; 0x40
 8002092:	0049      	lsls	r1, r1, #1
 8002094:	482d      	ldr	r0, [pc, #180]	; (800214c <main+0x35c>)
 8002096:	f7fe fc3b 	bl	8000910 <chThdCreateStatic>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
 800209a:	21a4      	movs	r1, #164	; 0xa4
 800209c:	9400      	str	r4, [sp, #0]
 800209e:	4b2c      	ldr	r3, [pc, #176]	; (8002150 <main+0x360>)
 80020a0:	2240      	movs	r2, #64	; 0x40
 80020a2:	0049      	lsls	r1, r1, #1
 80020a4:	482b      	ldr	r0, [pc, #172]	; (8002154 <main+0x364>)
 80020a6:	f7fe fc33 	bl	8000910 <chThdCreateStatic>
 80020aa:	4b2b      	ldr	r3, [pc, #172]	; (8002158 <main+0x368>)
 80020ac:	4c2b      	ldr	r4, [pc, #172]	; (800215c <main+0x36c>)
 80020ae:	4699      	mov	r9, r3
 80020b0:	4b2b      	ldr	r3, [pc, #172]	; (8002160 <main+0x370>)
 80020b2:	4e2c      	ldr	r6, [pc, #176]	; (8002164 <main+0x374>)
 80020b4:	469a      	mov	sl, r3
 80020b6:	4b2c      	ldr	r3, [pc, #176]	; (8002168 <main+0x378>)
 80020b8:	469b      	mov	fp, r3
 80020ba:	e05a      	b.n	8002172 <main+0x382>
 80020bc:	40021000 	.word	0x40021000
 80020c0:	ffbfffff 	.word	0xffbfffff
 80020c4:	40007000 	.word	0x40007000
 80020c8:	65555554 	.word	0x65555554
 80020cc:	0000ffff 	.word	0x0000ffff
 80020d0:	f00f0000 	.word	0xf00f0000
 80020d4:	48000400 	.word	0x48000400
 80020d8:	55555555 	.word	0x55555555
 80020dc:	48000800 	.word	0x48000800
 80020e0:	05505555 	.word	0x05505555
 80020e4:	0000fcff 	.word	0x0000fcff
 80020e8:	48000c00 	.word	0x48000c00
 80020ec:	55555550 	.word	0x55555550
 80020f0:	48001400 	.word	0x48001400
 80020f4:	08005970 	.word	0x08005970
 80020f8:	2000098c 	.word	0x2000098c
 80020fc:	08000301 	.word	0x08000301
 8002100:	40013800 	.word	0x40013800
 8002104:	02dc6c00 	.word	0x02dc6c00
 8002108:	e000e100 	.word	0xe000e100
 800210c:	40015800 	.word	0x40015800
 8002110:	000012bf 	.word	0x000012bf
 8002114:	e000ed00 	.word	0xe000ed00
 8002118:	ff00ffff 	.word	0xff00ffff
 800211c:	20000ac0 	.word	0x20000ac0
 8002120:	200012c0 	.word	0x200012c0
 8002124:	20000a50 	.word	0x20000a50
 8002128:	20002000 	.word	0x20002000
 800212c:	20000970 	.word	0x20000970
 8002130:	20000a08 	.word	0x20000a08
 8002134:	08000361 	.word	0x08000361
 8002138:	08005920 	.word	0x08005920
 800213c:	080003f1 	.word	0x080003f1
 8002140:	08005eb4 	.word	0x08005eb4
 8002144:	00004040 	.word	0x00004040
 8002148:	080016f1 	.word	0x080016f1
 800214c:	200006d0 	.word	0x200006d0
 8002150:	08001731 	.word	0x08001731
 8002154:	20000818 	.word	0x20000818
 8002158:	20000a40 	.word	0x20000a40
 800215c:	200006bc 	.word	0x200006bc
 8002160:	20000a28 	.word	0x20000a28
 8002164:	20000a3c 	.word	0x20000a3c
 8002168:	200006b8 	.word	0x200006b8
   * driver 1.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
      TestThread(&SD1);
    chThdSleepMilliseconds(500);
 800216c:	489e      	ldr	r0, [pc, #632]	; (80023e8 <main+0x5f8>)
 800216e:	f7ff f9cf 	bl	8001510 <chThdSleep>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched with output on the serial
   * driver 1.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
 8002172:	2390      	movs	r3, #144	; 0x90
 8002174:	2201      	movs	r2, #1
 8002176:	05db      	lsls	r3, r3, #23
 8002178:	691b      	ldr	r3, [r3, #16]
 800217a:	421a      	tst	r2, r3
 800217c:	d0f6      	beq.n	800216c <main+0x37c>
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 800217e:	4b9b      	ldr	r3, [pc, #620]	; (80023ec <main+0x5fc>)
  test_println("");
 8002180:	489b      	ldr	r0, [pc, #620]	; (80023f0 <main+0x600>)
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
  int i, j;

  chp = p;
 8002182:	6023      	str	r3, [r4, #0]
  test_println("");
 8002184:	f7fe fa44 	bl	8000610 <test_println>
  test_println("*** ChibiOS/RT test suite");
 8002188:	489a      	ldr	r0, [pc, #616]	; (80023f4 <main+0x604>)
 800218a:	f7fe fa41 	bl	8000610 <test_println>
  test_println("***");
 800218e:	489a      	ldr	r0, [pc, #616]	; (80023f8 <main+0x608>)
 8002190:	f7fe fa3e 	bl	8000610 <test_println>
 8002194:	212a      	movs	r1, #42	; 0x2a
 8002196:	4d99      	ldr	r5, [pc, #612]	; (80023fc <main+0x60c>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002198:	6820      	ldr	r0, [r4, #0]
 800219a:	3501      	adds	r5, #1
 800219c:	6803      	ldr	r3, [r0, #0]
 800219e:	689b      	ldr	r3, [r3, #8]
 80021a0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80021a2:	7829      	ldrb	r1, [r5, #0]
 80021a4:	2900      	cmp	r1, #0
 80021a6:	d1f7      	bne.n	8002198 <main+0x3a8>
  chp = p;
  test_println("");
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
 80021a8:	4895      	ldr	r0, [pc, #596]	; (8002400 <main+0x610>)
 80021aa:	f7fe fa31 	bl	8000610 <test_println>
 80021ae:	212a      	movs	r1, #42	; 0x2a
 80021b0:	4d94      	ldr	r5, [pc, #592]	; (8002404 <main+0x614>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80021b2:	6820      	ldr	r0, [r4, #0]
 80021b4:	3501      	adds	r5, #1
 80021b6:	6803      	ldr	r3, [r0, #0]
 80021b8:	689b      	ldr	r3, [r3, #8]
 80021ba:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80021bc:	7829      	ldrb	r1, [r5, #0]
 80021be:	2900      	cmp	r1, #0
 80021c0:	d1f7      	bne.n	80021b2 <main+0x3c2>
  test_println("*** ChibiOS/RT test suite");
  test_println("***");
  test_print("*** Kernel:       ");
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 80021c2:	4891      	ldr	r0, [pc, #580]	; (8002408 <main+0x618>)
 80021c4:	f7fe fa24 	bl	8000610 <test_println>
 80021c8:	212a      	movs	r1, #42	; 0x2a
 80021ca:	4d90      	ldr	r5, [pc, #576]	; (800240c <main+0x61c>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80021cc:	6820      	ldr	r0, [r4, #0]
 80021ce:	3501      	adds	r5, #1
 80021d0:	6803      	ldr	r3, [r0, #0]
 80021d2:	689b      	ldr	r3, [r3, #8]
 80021d4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80021d6:	7829      	ldrb	r1, [r5, #0]
 80021d8:	2900      	cmp	r1, #0
 80021da:	d1f7      	bne.n	80021cc <main+0x3dc>
  test_println(CH_KERNEL_VERSION);
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
 80021dc:	488c      	ldr	r0, [pc, #560]	; (8002410 <main+0x620>)
 80021de:	f7fe fa17 	bl	8000610 <test_println>
 80021e2:	212a      	movs	r1, #42	; 0x2a
 80021e4:	4d8b      	ldr	r5, [pc, #556]	; (8002414 <main+0x624>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80021e6:	6820      	ldr	r0, [r4, #0]
 80021e8:	3501      	adds	r5, #1
 80021ea:	6803      	ldr	r3, [r0, #0]
 80021ec:	689b      	ldr	r3, [r3, #8]
 80021ee:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80021f0:	7829      	ldrb	r1, [r5, #0]
 80021f2:	2900      	cmp	r1, #0
 80021f4:	d1f7      	bne.n	80021e6 <main+0x3f6>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
  test_println(PORT_COMPILER_NAME);
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
 80021f6:	4888      	ldr	r0, [pc, #544]	; (8002418 <main+0x628>)
 80021f8:	f7fe fa0a 	bl	8000610 <test_println>
 80021fc:	212a      	movs	r1, #42	; 0x2a
 80021fe:	4d87      	ldr	r5, [pc, #540]	; (800241c <main+0x62c>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002200:	6820      	ldr	r0, [r4, #0]
 8002202:	3501      	adds	r5, #1
 8002204:	6803      	ldr	r3, [r0, #0]
 8002206:	689b      	ldr	r3, [r3, #8]
 8002208:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800220a:	7829      	ldrb	r1, [r5, #0]
 800220c:	2900      	cmp	r1, #0
 800220e:	d1f7      	bne.n	8002200 <main+0x410>
#endif
  test_print("*** Architecture: ");
  test_println(PORT_ARCHITECTURE_NAME);
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
 8002210:	4883      	ldr	r0, [pc, #524]	; (8002420 <main+0x630>)
 8002212:	f7fe f9fd 	bl	8000610 <test_println>
 8002216:	212a      	movs	r1, #42	; 0x2a
 8002218:	4d82      	ldr	r5, [pc, #520]	; (8002424 <main+0x634>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800221a:	6820      	ldr	r0, [r4, #0]
 800221c:	3501      	adds	r5, #1
 800221e:	6803      	ldr	r3, [r0, #0]
 8002220:	689b      	ldr	r3, [r3, #8]
 8002222:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002224:	7829      	ldrb	r1, [r5, #0]
 8002226:	2900      	cmp	r1, #0
 8002228:	d1f7      	bne.n	800221a <main+0x42a>
  test_print("*** Core Variant: ");
  test_println(PORT_CORE_VARIANT_NAME);
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
 800222a:	487f      	ldr	r0, [pc, #508]	; (8002428 <main+0x638>)
 800222c:	f7fe f9f0 	bl	8000610 <test_println>
 8002230:	212a      	movs	r1, #42	; 0x2a
 8002232:	4d7e      	ldr	r5, [pc, #504]	; (800242c <main+0x63c>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002234:	6820      	ldr	r0, [r4, #0]
 8002236:	3501      	adds	r5, #1
 8002238:	6803      	ldr	r3, [r0, #0]
 800223a:	689b      	ldr	r3, [r3, #8]
 800223c:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800223e:	7829      	ldrb	r1, [r5, #0]
 8002240:	2900      	cmp	r1, #0
 8002242:	d1f7      	bne.n	8002234 <main+0x444>
  test_print("*** Port Info:    ");
  test_println(PORT_INFO);
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8002244:	252a      	movs	r5, #42	; 0x2a
 8002246:	487a      	ldr	r0, [pc, #488]	; (8002430 <main+0x640>)
 8002248:	f7fe f9e2 	bl	8000610 <test_println>
 800224c:	0029      	movs	r1, r5
 800224e:	4f79      	ldr	r7, [pc, #484]	; (8002434 <main+0x644>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002250:	6820      	ldr	r0, [r4, #0]
 8002252:	3701      	adds	r7, #1
 8002254:	6803      	ldr	r3, [r0, #0]
 8002256:	689b      	ldr	r3, [r3, #8]
 8002258:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800225a:	7839      	ldrb	r1, [r7, #0]
 800225c:	2900      	cmp	r1, #0
 800225e:	d1f7      	bne.n	8002250 <main+0x460>
 8002260:	000d      	movs	r5, r1
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8002262:	4875      	ldr	r0, [pc, #468]	; (8002438 <main+0x648>)
 8002264:	f7fe f9d4 	bl	8000610 <test_println>
#endif
  test_println("");
 8002268:	4861      	ldr	r0, [pc, #388]	; (80023f0 <main+0x600>)
 800226a:	f7fe f9d1 	bl	8000610 <test_println>

  test_global_fail = FALSE;
 800226e:	2200      	movs	r2, #0
 8002270:	4b72      	ldr	r3, [pc, #456]	; (800243c <main+0x64c>)
 8002272:	4f73      	ldr	r7, [pc, #460]	; (8002440 <main+0x650>)
 8002274:	701d      	strb	r5, [r3, #0]
 8002276:	4b73      	ldr	r3, [pc, #460]	; (8002444 <main+0x654>)
 8002278:	9203      	str	r2, [sp, #12]
 800227a:	3308      	adds	r3, #8
 800227c:	9304      	str	r3, [sp, #16]
 800227e:	4b72      	ldr	r3, [pc, #456]	; (8002448 <main+0x658>)
 8002280:	9305      	str	r3, [sp, #20]
 8002282:	4b72      	ldr	r3, [pc, #456]	; (800244c <main+0x65c>)
 8002284:	9a03      	ldr	r2, [sp, #12]
 8002286:	3201      	adds	r2, #1
 8002288:	9203      	str	r2, [sp, #12]
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800228a:	2200      	movs	r2, #0
 800228c:	4690      	mov	r8, r2

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 800228e:	2b00      	cmp	r3, #0
 8002290:	d100      	bne.n	8002294 <main+0x4a4>
 8002292:	e081      	b.n	8002398 <main+0x5a8>
      print_line();
 8002294:	f000 ffac 	bl	80031f0 <print_line.lto_priv.124>
 8002298:	212d      	movs	r1, #45	; 0x2d
 800229a:	4d6d      	ldr	r5, [pc, #436]	; (8002450 <main+0x660>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800229c:	6820      	ldr	r0, [r4, #0]
 800229e:	3501      	adds	r5, #1
 80022a0:	6803      	ldr	r3, [r0, #0]
 80022a2:	689b      	ldr	r3, [r3, #8]
 80022a4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80022a6:	7829      	ldrb	r1, [r5, #0]
 80022a8:	2900      	cmp	r1, #0
 80022aa:	d1f7      	bne.n	800229c <main+0x4ac>
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 80022ac:	9803      	ldr	r0, [sp, #12]
 80022ae:	f7fe f9e7 	bl	8000680 <test_printn>
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80022b2:	6820      	ldr	r0, [r4, #0]
 80022b4:	212e      	movs	r1, #46	; 0x2e
 80022b6:	6803      	ldr	r3, [r0, #0]
 80022b8:	689b      	ldr	r3, [r3, #8]
 80022ba:	4798      	blx	r3
    while (patterns[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 80022bc:	2301      	movs	r3, #1
 80022be:	469c      	mov	ip, r3
 80022c0:	44e0      	add	r8, ip
 80022c2:	4640      	mov	r0, r8
 80022c4:	f7fe f9dc 	bl	8000680 <test_printn>
 80022c8:	2120      	movs	r1, #32
 80022ca:	4d62      	ldr	r5, [pc, #392]	; (8002454 <main+0x664>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80022cc:	6820      	ldr	r0, [r4, #0]
 80022ce:	3501      	adds	r5, #1
 80022d0:	6803      	ldr	r3, [r0, #0]
 80022d2:	689b      	ldr	r3, [r3, #8]
 80022d4:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80022d6:	7829      	ldrb	r1, [r5, #0]
 80022d8:	2900      	cmp	r1, #0
 80022da:	d1f7      	bne.n	80022cc <main+0x4dc>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
 80022dc:	683b      	ldr	r3, [r7, #0]
 80022de:	681d      	ldr	r5, [r3, #0]
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80022e0:	7829      	ldrb	r1, [r5, #0]
 80022e2:	2900      	cmp	r1, #0
 80022e4:	d007      	beq.n	80022f6 <main+0x506>
    chSequentialStreamPut(chp, *msgp++);
 80022e6:	6820      	ldr	r0, [r4, #0]
 80022e8:	3501      	adds	r5, #1
 80022ea:	6803      	ldr	r3, [r0, #0]
 80022ec:	689b      	ldr	r3, [r3, #8]
 80022ee:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80022f0:	7829      	ldrb	r1, [r5, #0]
 80022f2:	2900      	cmp	r1, #0
 80022f4:	d1f7      	bne.n	80022e6 <main+0x4f6>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(patterns[i][j]->name);
      test_println(")");
 80022f6:	4858      	ldr	r0, [pc, #352]	; (8002458 <main+0x668>)
 80022f8:	f7fe f98a 	bl	8000610 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 80022fc:	20fa      	movs	r0, #250	; 0xfa
 80022fe:	00c0      	lsls	r0, r0, #3
 8002300:	f7ff f906 	bl	8001510 <chThdSleep>
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002304:	464b      	mov	r3, r9
      test_print(patterns[i][j]->name);
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
 8002306:	683d      	ldr	r5, [r7, #0]
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 8002308:	6033      	str	r3, [r6, #0]
static void execute_test(const struct testcase *tcp) {
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
 800230a:	2300      	movs	r3, #0
 800230c:	4a53      	ldr	r2, [pc, #332]	; (800245c <main+0x66c>)
 800230e:	7013      	strb	r3, [r2, #0]
  for (i = 0; i < MAX_THREADS; i++)
    threads[i] = NULL;
 8002310:	4652      	mov	r2, sl
 8002312:	6013      	str	r3, [r2, #0]
 8002314:	6053      	str	r3, [r2, #4]
 8002316:	6093      	str	r3, [r2, #8]
 8002318:	60d3      	str	r3, [r2, #12]
 800231a:	6113      	str	r3, [r2, #16]

  if (tcp->setup != NULL)
 800231c:	686b      	ldr	r3, [r5, #4]
 800231e:	2b00      	cmp	r3, #0
 8002320:	d000      	beq.n	8002324 <main+0x534>
    tcp->setup();
 8002322:	4798      	blx	r3
  tcp->execute();
 8002324:	68eb      	ldr	r3, [r5, #12]
 8002326:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8002328:	68ab      	ldr	r3, [r5, #8]
 800232a:	2b00      	cmp	r3, #0
 800232c:	d000      	beq.n	8002330 <main+0x540>
    tcp->teardown();
 800232e:	4798      	blx	r3

  test_wait_threads();
 8002330:	f7fe fe66 	bl	8001000 <test_wait_threads>
      test_println(")");
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
 8002334:	4b49      	ldr	r3, [pc, #292]	; (800245c <main+0x66c>)
 8002336:	781b      	ldrb	r3, [r3, #0]
 8002338:	2b00      	cmp	r3, #0
 800233a:	d036      	beq.n	80023aa <main+0x5ba>
 800233c:	212d      	movs	r1, #45	; 0x2d
 800233e:	4d48      	ldr	r5, [pc, #288]	; (8002460 <main+0x670>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8002340:	6820      	ldr	r0, [r4, #0]
 8002342:	3501      	adds	r5, #1
 8002344:	6803      	ldr	r3, [r0, #0]
 8002346:	689b      	ldr	r3, [r3, #8]
 8002348:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800234a:	7829      	ldrb	r1, [r5, #0]
 800234c:	2900      	cmp	r1, #0
 800234e:	d1f7      	bne.n	8002340 <main+0x550>
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
#endif
      execute_test(patterns[i][j]);
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
 8002350:	465b      	mov	r3, fp
 8002352:	6818      	ldr	r0, [r3, #0]
 8002354:	f7fe f994 	bl	8000680 <test_printn>
 8002358:	2120      	movs	r1, #32
 800235a:	4d42      	ldr	r5, [pc, #264]	; (8002464 <main+0x674>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 800235c:	6820      	ldr	r0, [r4, #0]
 800235e:	3501      	adds	r5, #1
 8002360:	6803      	ldr	r3, [r0, #0]
 8002362:	689b      	ldr	r3, [r3, #8]
 8002364:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8002366:	7829      	ldrb	r1, [r5, #0]
 8002368:	2900      	cmp	r1, #0
 800236a:	d1f7      	bne.n	800235c <main+0x56c>
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800236c:	6833      	ldr	r3, [r6, #0]
 800236e:	464d      	mov	r5, r9
 8002370:	454b      	cmp	r3, r9
 8002372:	d909      	bls.n	8002388 <main+0x598>
    chSequentialStreamPut(chp, *cp++);
 8002374:	6820      	ldr	r0, [r4, #0]
 8002376:	3501      	adds	r5, #1
 8002378:	1e6b      	subs	r3, r5, #1
 800237a:	7819      	ldrb	r1, [r3, #0]
 800237c:	6803      	ldr	r3, [r0, #0]
 800237e:	689b      	ldr	r3, [r3, #8]
 8002380:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 8002382:	6833      	ldr	r3, [r6, #0]
 8002384:	429d      	cmp	r5, r3
 8002386:	d3f5      	bcc.n	8002374 <main+0x584>
      if (local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(failpoint);
        test_print(" [");
        print_tokens();
        test_println("])");
 8002388:	4837      	ldr	r0, [pc, #220]	; (8002468 <main+0x678>)
 800238a:	f7fe f941 	bl	8000610 <test_println>
 800238e:	687b      	ldr	r3, [r7, #4]
 8002390:	3704      	adds	r7, #4

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 8002392:	2b00      	cmp	r3, #0
 8002394:	d000      	beq.n	8002398 <main+0x5a8>
 8002396:	e77d      	b.n	8002294 <main+0x4a4>
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 8002398:	9f05      	ldr	r7, [sp, #20]
 800239a:	2f00      	cmp	r7, #0
 800239c:	d009      	beq.n	80023b2 <main+0x5c2>
 800239e:	9a04      	ldr	r2, [sp, #16]
 80023a0:	683b      	ldr	r3, [r7, #0]
 80023a2:	ca02      	ldmia	r2!, {r1}
 80023a4:	9105      	str	r1, [sp, #20]
 80023a6:	9204      	str	r2, [sp, #16]
 80023a8:	e76c      	b.n	8002284 <main+0x494>
        test_print(" [");
        print_tokens();
        test_println("])");
      }
      else
        test_println("--- Result: SUCCESS");
 80023aa:	4830      	ldr	r0, [pc, #192]	; (800246c <main+0x67c>)
 80023ac:	f7fe f930 	bl	8000610 <test_println>
 80023b0:	e7ed      	b.n	800238e <main+0x59e>
      j++;
    }
    i++;
  }
  print_line();
 80023b2:	f000 ff1d 	bl	80031f0 <print_line.lto_priv.124>
  test_println("");
 80023b6:	480e      	ldr	r0, [pc, #56]	; (80023f0 <main+0x600>)
 80023b8:	f7fe f92a 	bl	8000610 <test_println>
 80023bc:	2146      	movs	r1, #70	; 0x46
 80023be:	4d2c      	ldr	r5, [pc, #176]	; (8002470 <main+0x680>)
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 80023c0:	6820      	ldr	r0, [r4, #0]
 80023c2:	3501      	adds	r5, #1
 80023c4:	6803      	ldr	r3, [r0, #0]
 80023c6:	689b      	ldr	r3, [r3, #8]
 80023c8:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80023ca:	7829      	ldrb	r1, [r5, #0]
 80023cc:	2900      	cmp	r1, #0
 80023ce:	d1f7      	bne.n	80023c0 <main+0x5d0>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 80023d0:	4b1a      	ldr	r3, [pc, #104]	; (800243c <main+0x64c>)
 80023d2:	781b      	ldrb	r3, [r3, #0]
 80023d4:	2b00      	cmp	r3, #0
 80023d6:	d103      	bne.n	80023e0 <main+0x5f0>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80023d8:	4826      	ldr	r0, [pc, #152]	; (8002474 <main+0x684>)
 80023da:	f7fe f919 	bl	8000610 <test_println>
 80023de:	e6c5      	b.n	800216c <main+0x37c>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 80023e0:	4825      	ldr	r0, [pc, #148]	; (8002478 <main+0x688>)
 80023e2:	f7fe f915 	bl	8000610 <test_println>
 80023e6:	e6c1      	b.n	800216c <main+0x37c>
 80023e8:	00001388 	.word	0x00001388
 80023ec:	2000098c 	.word	0x2000098c
 80023f0:	08005dd0 	.word	0x08005dd0
 80023f4:	08005ebc 	.word	0x08005ebc
 80023f8:	08005ed8 	.word	0x08005ed8
 80023fc:	08005dd4 	.word	0x08005dd4
 8002400:	08005f00 	.word	0x08005f00
 8002404:	08005de8 	.word	0x08005de8
 8002408:	08005f08 	.word	0x08005f08
 800240c:	08005dfc 	.word	0x08005dfc
 8002410:	08005f20 	.word	0x08005f20
 8002414:	08005e10 	.word	0x08005e10
 8002418:	08005f68 	.word	0x08005f68
 800241c:	08005e24 	.word	0x08005e24
 8002420:	08005f70 	.word	0x08005f70
 8002424:	08005e38 	.word	0x08005e38
 8002428:	08005f7c 	.word	0x08005f7c
 800242c:	08005e4c 	.word	0x08005e4c
 8002430:	08005f94 	.word	0x08005f94
 8002434:	08005e60 	.word	0x08005e60
 8002438:	08005fc4 	.word	0x08005fc4
 800243c:	20000988 	.word	0x20000988
 8002440:	08005a80 	.word	0x08005a80
 8002444:	08005ab0 	.word	0x08005ab0
 8002448:	08005b70 	.word	0x08005b70
 800244c:	080059c0 	.word	0x080059c0
 8002450:	08005e74 	.word	0x08005e74
 8002454:	08005e84 	.word	0x08005e84
 8002458:	08005edc 	.word	0x08005edc
 800245c:	20000989 	.word	0x20000989
 8002460:	08005e88 	.word	0x08005e88
 8002464:	08005ea0 	.word	0x08005ea0
 8002468:	08005ee0 	.word	0x08005ee0
 800246c:	08005ee4 	.word	0x08005ee4
 8002470:	08005ea4 	.word	0x08005ea4
 8002474:	08005ef0 	.word	0x08005ef0
 8002478:	08005ef8 	.word	0x08005ef8
 800247c:	00000000 	.word	0x00000000

08002480 <mtx4_setup.lto_priv.87>:
 8002480:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002482:	4b04      	ldr	r3, [pc, #16]	; (8002494 <mtx4_setup.lto_priv.87+0x14>)
 8002484:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8002486:	605b      	str	r3, [r3, #4]
 8002488:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800248a:	4b03      	ldr	r3, [pc, #12]	; (8002498 <mtx4_setup.lto_priv.87+0x18>)
 800248c:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800248e:	605b      	str	r3, [r3, #4]
 8002490:	609a      	str	r2, [r3, #8]

static void mtx4_setup(void) {

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8002492:	4770      	bx	lr
 8002494:	2000066c 	.word	0x2000066c
 8002498:	2000065c 	.word	0x2000065c
 800249c:	00000000 	.word	0x00000000

080024a0 <mtx1_setup.lto_priv.85>:
 80024a0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80024a2:	4b02      	ldr	r3, [pc, #8]	; (80024ac <mtx1_setup.lto_priv.85+0xc>)
 80024a4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80024a6:	605b      	str	r3, [r3, #4]
 80024a8:	609a      	str	r2, [r3, #8]
 */

static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}
 80024aa:	4770      	bx	lr
 80024ac:	2000066c 	.word	0x2000066c

080024b0 <sem1_setup.lto_priv.78>:
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 80024b0:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80024b2:	4b02      	ldr	r3, [pc, #8]	; (80024bc <sem1_setup.lto_priv.78+0xc>)
 80024b4:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80024b6:	605b      	str	r3, [r3, #4]
 80024b8:	609a      	str	r2, [r3, #8]
 */

static void sem1_setup(void) {

  chSemObjectInit(&sem1, 0);
}
 80024ba:	4770      	bx	lr
 80024bc:	200006ac 	.word	0x200006ac

080024c0 <sem3_setup.lto_priv.82>:
 80024c0:	b510      	push	{r4, lr}
 80024c2:	f7ff fff5 	bl	80024b0 <sem1_setup.lto_priv.78>
 80024c6:	bd10      	pop	{r4, pc}
	...

080024d0 <sem2_setup.lto_priv.80>:
 80024d0:	b510      	push	{r4, lr}
 80024d2:	f7ff ffed 	bl	80024b0 <sem1_setup.lto_priv.78>
 80024d6:	bd10      	pop	{r4, pc}
	...

080024e0 <tmr.lto_priv.58>:

static virtual_timer_t vt;
static void tmr(void *p) {
  (void)p;

  test_timer_done = TRUE;
 80024e0:	2201      	movs	r2, #1
 80024e2:	4b01      	ldr	r3, [pc, #4]	; (80024e8 <tmr.lto_priv.58+0x8>)
 80024e4:	701a      	strb	r2, [r3, #0]
}
 80024e6:	4770      	bx	lr
 80024e8:	20000c10 	.word	0x20000c10
 80024ec:	00000000 	.word	0x00000000

080024f0 <mtx4_execute.lto_priv.88>:
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 80024f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80024f2:	465f      	mov	r7, fp
 80024f4:	4656      	mov	r6, sl
 80024f6:	464d      	mov	r5, r9
 80024f8:	4644      	mov	r4, r8
 80024fa:	b4f0      	push	{r4, r5, r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80024fc:	4d8f      	ldr	r5, [pc, #572]	; (800273c <mtx4_execute.lto_priv.88+0x24c>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 80024fe:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002500:	69ab      	ldr	r3, [r5, #24]
 8002502:	4f8f      	ldr	r7, [pc, #572]	; (8002740 <mtx4_execute.lto_priv.88+0x250>)
 8002504:	689c      	ldr	r4, [r3, #8]
  chThdSleepMilliseconds(150);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static void mtx4_execute(void) {
 8002506:	b083      	sub	sp, #12
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
 8002508:	1c63      	adds	r3, r4, #1
 800250a:	4698      	mov	r8, r3
  p2 = p + 2;
 800250c:	1ca3      	adds	r3, r4, #2
 800250e:	4699      	mov	r9, r3
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 8002510:	4b8c      	ldr	r3, [pc, #560]	; (8002744 <mtx4_execute.lto_priv.88+0x254>)
 8002512:	4642      	mov	r2, r8
 8002514:	469b      	mov	fp, r3
 8002516:	4b8c      	ldr	r3, [pc, #560]	; (8002748 <mtx4_execute.lto_priv.88+0x258>)
 8002518:	0049      	lsls	r1, r1, #1
 800251a:	9300      	str	r3, [sp, #0]
 800251c:	0038      	movs	r0, r7
 800251e:	465b      	mov	r3, fp
 8002520:	f7fe f9f6 	bl	8000910 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8002524:	4b89      	ldr	r3, [pc, #548]	; (800274c <mtx4_execute.lto_priv.88+0x25c>)
 8002526:	21a4      	movs	r1, #164	; 0xa4
 8002528:	469a      	mov	sl, r3
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800252a:	4e89      	ldr	r6, [pc, #548]	; (8002750 <mtx4_execute.lto_priv.88+0x260>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800252c:	4b89      	ldr	r3, [pc, #548]	; (8002754 <mtx4_execute.lto_priv.88+0x264>)
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
  p1 = p + 1;
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800252e:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 8002530:	0049      	lsls	r1, r1, #1
 8002532:	9300      	str	r3, [sp, #0]
 8002534:	464a      	mov	r2, r9
 8002536:	4653      	mov	r3, sl
 8002538:	4887      	ldr	r0, [pc, #540]	; (8002758 <mtx4_execute.lto_priv.88+0x268>)
 800253a:	f7fe f9e9 	bl	8000910 <chThdCreateStatic>
 800253e:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 8002540:	4886      	ldr	r0, [pc, #536]	; (800275c <mtx4_execute.lto_priv.88+0x26c>)
 8002542:	f7fe fc9d 	bl	8000e80 <chMtxLock>
 8002546:	69ab      	ldr	r3, [r5, #24]
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 8002548:	2001      	movs	r0, #1
 800254a:	6899      	ldr	r1, [r3, #8]
 800254c:	1b09      	subs	r1, r1, r4
 800254e:	424b      	negs	r3, r1
 8002550:	4159      	adcs	r1, r3
 8002552:	b2c9      	uxtb	r1, r1
 8002554:	f7fe f834 	bl	80005c0 <_test_assert>
 8002558:	2800      	cmp	r0, #0
 800255a:	d006      	beq.n	800256a <mtx4_execute.lto_priv.88+0x7a>
  chThdSleepMilliseconds(100);
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
  chMtxUnlockAll();
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();
}
 800255c:	b003      	add	sp, #12
 800255e:	bc3c      	pop	{r2, r3, r4, r5}
 8002560:	4690      	mov	r8, r2
 8002562:	4699      	mov	r9, r3
 8002564:	46a2      	mov	sl, r4
 8002566:	46ab      	mov	fp, r5
 8002568:	bdf0      	pop	{r4, r5, r6, r7, pc}
  p2 = p + 2;
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
  chMtxLock(&m2);
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
  chThdSleepMilliseconds(100);
 800256a:	20fa      	movs	r0, #250	; 0xfa
 800256c:	0080      	lsls	r0, r0, #2
 800256e:	f7fe ffcf 	bl	8001510 <chThdSleep>
 8002572:	69ab      	ldr	r3, [r5, #24]
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 8002574:	2002      	movs	r0, #2
 8002576:	6899      	ldr	r1, [r3, #8]
 8002578:	4643      	mov	r3, r8
 800257a:	1ac9      	subs	r1, r1, r3
 800257c:	424b      	negs	r3, r1
 800257e:	4159      	adcs	r1, r3
 8002580:	b2c9      	uxtb	r1, r1
 8002582:	f7fe f81d 	bl	80005c0 <_test_assert>
 8002586:	2800      	cmp	r0, #0
 8002588:	d1e8      	bne.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chMtxLock(&m1);
 800258a:	4875      	ldr	r0, [pc, #468]	; (8002760 <mtx4_execute.lto_priv.88+0x270>)
 800258c:	f7fe fc78 	bl	8000e80 <chMtxLock>
 8002590:	69ab      	ldr	r3, [r5, #24]
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 8002592:	2003      	movs	r0, #3
 8002594:	6899      	ldr	r1, [r3, #8]
 8002596:	4643      	mov	r3, r8
 8002598:	1ac9      	subs	r1, r1, r3
 800259a:	424b      	negs	r3, r1
 800259c:	4159      	adcs	r1, r3
 800259e:	b2c9      	uxtb	r1, r1
 80025a0:	f7fe f80e 	bl	80005c0 <_test_assert>
 80025a4:	2800      	cmp	r0, #0
 80025a6:	d1d9      	bne.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chThdSleepMilliseconds(100);
 80025a8:	20fa      	movs	r0, #250	; 0xfa
 80025aa:	0080      	lsls	r0, r0, #2
 80025ac:	f7fe ffb0 	bl	8001510 <chThdSleep>
 80025b0:	69ab      	ldr	r3, [r5, #24]
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 80025b2:	2004      	movs	r0, #4
 80025b4:	6899      	ldr	r1, [r3, #8]
 80025b6:	464b      	mov	r3, r9
 80025b8:	1ac9      	subs	r1, r1, r3
 80025ba:	424b      	negs	r3, r1
 80025bc:	4159      	adcs	r1, r3
 80025be:	b2c9      	uxtb	r1, r1
 80025c0:	f7fd fffe 	bl	80005c0 <_test_assert>
 80025c4:	2800      	cmp	r0, #0
 80025c6:	d1c9      	bne.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chMtxUnlock(&m1);
 80025c8:	4865      	ldr	r0, [pc, #404]	; (8002760 <mtx4_execute.lto_priv.88+0x270>)
 80025ca:	f7fe fbc1 	bl	8000d50 <chMtxUnlock>
 80025ce:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 80025d0:	2005      	movs	r0, #5
 80025d2:	6899      	ldr	r1, [r3, #8]
 80025d4:	4643      	mov	r3, r8
 80025d6:	1ac9      	subs	r1, r1, r3
 80025d8:	424b      	negs	r3, r1
 80025da:	4159      	adcs	r1, r3
 80025dc:	b2c9      	uxtb	r1, r1
 80025de:	f7fd ffef 	bl	80005c0 <_test_assert>
 80025e2:	2800      	cmp	r0, #0
 80025e4:	d1ba      	bne.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chThdSleepMilliseconds(100);
 80025e6:	20fa      	movs	r0, #250	; 0xfa
 80025e8:	0080      	lsls	r0, r0, #2
 80025ea:	f7fe ff91 	bl	8001510 <chThdSleep>
 80025ee:	69ab      	ldr	r3, [r5, #24]
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 80025f0:	2006      	movs	r0, #6
 80025f2:	6899      	ldr	r1, [r3, #8]
 80025f4:	4643      	mov	r3, r8
 80025f6:	1ac9      	subs	r1, r1, r3
 80025f8:	424b      	negs	r3, r1
 80025fa:	4159      	adcs	r1, r3
 80025fc:	b2c9      	uxtb	r1, r1
 80025fe:	f7fd ffdf 	bl	80005c0 <_test_assert>
 8002602:	2800      	cmp	r0, #0
 8002604:	d1aa      	bne.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chMtxUnlockAll();
 8002606:	f7fe fb53 	bl	8000cb0 <chMtxUnlockAll>
 800260a:	69ab      	ldr	r3, [r5, #24]
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800260c:	2007      	movs	r0, #7
 800260e:	6899      	ldr	r1, [r3, #8]
 8002610:	1b09      	subs	r1, r1, r4
 8002612:	424b      	negs	r3, r1
 8002614:	4159      	adcs	r1, r3
 8002616:	b2c9      	uxtb	r1, r1
 8002618:	f7fd ffd2 	bl	80005c0 <_test_assert>
 800261c:	2800      	cmp	r0, #0
 800261e:	d19d      	bne.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  test_wait_threads();
 8002620:	f7fe fcee 	bl	8001000 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 8002624:	21a4      	movs	r1, #164	; 0xa4
 8002626:	4b4f      	ldr	r3, [pc, #316]	; (8002764 <mtx4_execute.lto_priv.88+0x274>)
 8002628:	4642      	mov	r2, r8
 800262a:	9300      	str	r3, [sp, #0]
 800262c:	0049      	lsls	r1, r1, #1
 800262e:	465b      	mov	r3, fp
 8002630:	0038      	movs	r0, r7
 8002632:	f7fe f96d 	bl	8000910 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 8002636:	21a4      	movs	r1, #164	; 0xa4
 8002638:	4b4b      	ldr	r3, [pc, #300]	; (8002768 <mtx4_execute.lto_priv.88+0x278>)
  chMtxUnlockAll();
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
  test_wait_threads();

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 800263a:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800263c:	0049      	lsls	r1, r1, #1
 800263e:	9300      	str	r3, [sp, #0]
 8002640:	464a      	mov	r2, r9
 8002642:	4653      	mov	r3, sl
 8002644:	4844      	ldr	r0, [pc, #272]	; (8002758 <mtx4_execute.lto_priv.88+0x268>)
 8002646:	f7fe f963 	bl	8000910 <chThdCreateStatic>
 800264a:	6070      	str	r0, [r6, #4]
  chMtxLock(&m2);
 800264c:	4843      	ldr	r0, [pc, #268]	; (800275c <mtx4_execute.lto_priv.88+0x26c>)
 800264e:	f7fe fc17 	bl	8000e80 <chMtxLock>
 8002652:	69ab      	ldr	r3, [r5, #24]
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 8002654:	2008      	movs	r0, #8
 8002656:	6899      	ldr	r1, [r3, #8]
 8002658:	1b09      	subs	r1, r1, r4
 800265a:	424b      	negs	r3, r1
 800265c:	4159      	adcs	r1, r3
 800265e:	b2c9      	uxtb	r1, r1
 8002660:	f7fd ffae 	bl	80005c0 <_test_assert>
 8002664:	2800      	cmp	r0, #0
 8002666:	d000      	beq.n	800266a <mtx4_execute.lto_priv.88+0x17a>
 8002668:	e778      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chThdSleepMilliseconds(100);
 800266a:	20fa      	movs	r0, #250	; 0xfa
 800266c:	0080      	lsls	r0, r0, #2
 800266e:	f7fe ff4f 	bl	8001510 <chThdSleep>
 8002672:	69ab      	ldr	r3, [r5, #24]
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 8002674:	2009      	movs	r0, #9
 8002676:	6899      	ldr	r1, [r3, #8]
 8002678:	4643      	mov	r3, r8
 800267a:	1ac9      	subs	r1, r1, r3
 800267c:	424b      	negs	r3, r1
 800267e:	4159      	adcs	r1, r3
 8002680:	b2c9      	uxtb	r1, r1
 8002682:	f7fd ff9d 	bl	80005c0 <_test_assert>
 8002686:	2800      	cmp	r0, #0
 8002688:	d000      	beq.n	800268c <mtx4_execute.lto_priv.88+0x19c>
 800268a:	e767      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chMtxLock(&m1);
 800268c:	4834      	ldr	r0, [pc, #208]	; (8002760 <mtx4_execute.lto_priv.88+0x270>)
 800268e:	f7fe fbf7 	bl	8000e80 <chMtxLock>
 8002692:	69ab      	ldr	r3, [r5, #24]
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 8002694:	200a      	movs	r0, #10
 8002696:	6899      	ldr	r1, [r3, #8]
 8002698:	4643      	mov	r3, r8
 800269a:	1ac9      	subs	r1, r1, r3
 800269c:	424b      	negs	r3, r1
 800269e:	4159      	adcs	r1, r3
 80026a0:	b2c9      	uxtb	r1, r1
 80026a2:	f7fd ff8d 	bl	80005c0 <_test_assert>
 80026a6:	2800      	cmp	r0, #0
 80026a8:	d000      	beq.n	80026ac <mtx4_execute.lto_priv.88+0x1bc>
 80026aa:	e757      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chThdSleepMilliseconds(100);
 80026ac:	20fa      	movs	r0, #250	; 0xfa
 80026ae:	0080      	lsls	r0, r0, #2
 80026b0:	f7fe ff2e 	bl	8001510 <chThdSleep>
 80026b4:	69ab      	ldr	r3, [r5, #24]
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 80026b6:	200b      	movs	r0, #11
 80026b8:	6899      	ldr	r1, [r3, #8]
 80026ba:	464b      	mov	r3, r9
 80026bc:	1ac9      	subs	r1, r1, r3
 80026be:	424b      	negs	r3, r1
 80026c0:	4159      	adcs	r1, r3
 80026c2:	b2c9      	uxtb	r1, r1
 80026c4:	f7fd ff7c 	bl	80005c0 <_test_assert>
 80026c8:	2800      	cmp	r0, #0
 80026ca:	d000      	beq.n	80026ce <mtx4_execute.lto_priv.88+0x1de>
 80026cc:	e746      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80026ce:	b672      	cpsid	i
  chSysLock();
  chMtxUnlockS(&m1);
 80026d0:	4823      	ldr	r0, [pc, #140]	; (8002760 <mtx4_execute.lto_priv.88+0x270>)
 80026d2:	f7fe fb15 	bl	8000d00 <chMtxUnlockS>
  chSchRescheduleS();
 80026d6:	f7fe f8b3 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80026da:	b662      	cpsie	i
 80026dc:	69ab      	ldr	r3, [r5, #24]
  chSysUnlock();
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 80026de:	200c      	movs	r0, #12
 80026e0:	6899      	ldr	r1, [r3, #8]
 80026e2:	4643      	mov	r3, r8
 80026e4:	1ac9      	subs	r1, r1, r3
 80026e6:	424b      	negs	r3, r1
 80026e8:	4159      	adcs	r1, r3
 80026ea:	b2c9      	uxtb	r1, r1
 80026ec:	f7fd ff68 	bl	80005c0 <_test_assert>
 80026f0:	2800      	cmp	r0, #0
 80026f2:	d000      	beq.n	80026f6 <mtx4_execute.lto_priv.88+0x206>
 80026f4:	e732      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chThdSleepMilliseconds(100);
 80026f6:	20fa      	movs	r0, #250	; 0xfa
 80026f8:	0080      	lsls	r0, r0, #2
 80026fa:	f7fe ff09 	bl	8001510 <chThdSleep>
 80026fe:	69ab      	ldr	r3, [r5, #24]
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 8002700:	200d      	movs	r0, #13
 8002702:	6899      	ldr	r1, [r3, #8]
 8002704:	4643      	mov	r3, r8
 8002706:	1ac9      	subs	r1, r1, r3
 8002708:	424b      	negs	r3, r1
 800270a:	4159      	adcs	r1, r3
 800270c:	b2c9      	uxtb	r1, r1
 800270e:	f7fd ff57 	bl	80005c0 <_test_assert>
 8002712:	2800      	cmp	r0, #0
 8002714:	d000      	beq.n	8002718 <mtx4_execute.lto_priv.88+0x228>
 8002716:	e721      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  chMtxUnlockAll();
 8002718:	f7fe faca 	bl	8000cb0 <chMtxUnlockAll>
 800271c:	69ab      	ldr	r3, [r5, #24]
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 800271e:	200e      	movs	r0, #14
 8002720:	6899      	ldr	r1, [r3, #8]
 8002722:	1b09      	subs	r1, r1, r4
 8002724:	424c      	negs	r4, r1
 8002726:	4161      	adcs	r1, r4
 8002728:	b2c9      	uxtb	r1, r1
 800272a:	f7fd ff49 	bl	80005c0 <_test_assert>
 800272e:	2800      	cmp	r0, #0
 8002730:	d000      	beq.n	8002734 <mtx4_execute.lto_priv.88+0x244>
 8002732:	e713      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
  test_wait_threads();
 8002734:	f7fe fc64 	bl	8001000 <test_wait_threads>
 8002738:	e710      	b.n	800255c <mtx4_execute.lto_priv.88+0x6c>
 800273a:	46c0      	nop			; (mov r8, r8)
 800273c:	20000ac0 	.word	0x20000ac0
 8002740:	20000c58 	.word	0x20000c58
 8002744:	08002771 	.word	0x08002771
 8002748:	080064d0 	.word	0x080064d0
 800274c:	08002791 	.word	0x08002791
 8002750:	20000a28 	.word	0x20000a28
 8002754:	080064d4 	.word	0x080064d4
 8002758:	20000da0 	.word	0x20000da0
 800275c:	2000065c 	.word	0x2000065c
 8002760:	2000066c 	.word	0x2000066c
 8002764:	080064d8 	.word	0x080064d8
 8002768:	080064dc 	.word	0x080064dc
 800276c:	00000000 	.word	0x00000000

08002770 <thread4a>:
}

static THD_FUNCTION(thread4a, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8002770:	20fa      	movs	r0, #250	; 0xfa

  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread4a, p) {
 8002772:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8002774:	0040      	lsls	r0, r0, #1
 8002776:	f7fe fecb 	bl	8001510 <chThdSleep>
  chMtxLock(&m2);
 800277a:	4c04      	ldr	r4, [pc, #16]	; (800278c <thread4a+0x1c>)
 800277c:	0020      	movs	r0, r4
 800277e:	f7fe fb7f 	bl	8000e80 <chMtxLock>
  chMtxUnlock(&m2);
 8002782:	0020      	movs	r0, r4
 8002784:	f7fe fae4 	bl	8000d50 <chMtxUnlock>
}
 8002788:	bd10      	pop	{r4, pc}
 800278a:	46c0      	nop			; (mov r8, r8)
 800278c:	2000065c 	.word	0x2000065c

08002790 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 8002790:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 8002792:	4805      	ldr	r0, [pc, #20]	; (80027a8 <thread4b+0x18>)
 8002794:	f7fe febc 	bl	8001510 <chThdSleep>
  chMtxLock(&m1);
 8002798:	4c04      	ldr	r4, [pc, #16]	; (80027ac <thread4b+0x1c>)
 800279a:	0020      	movs	r0, r4
 800279c:	f7fe fb70 	bl	8000e80 <chMtxLock>
  chMtxUnlock(&m1);
 80027a0:	0020      	movs	r0, r4
 80027a2:	f7fe fad5 	bl	8000d50 <chMtxUnlock>
}
 80027a6:	bd10      	pop	{r4, pc}
 80027a8:	000005dc 	.word	0x000005dc
 80027ac:	2000066c 	.word	0x2000066c

080027b0 <mtx1_execute.lto_priv.86>:
  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx1_execute(void) {
 80027b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80027b2:	464f      	mov	r7, r9
 80027b4:	4646      	mov	r6, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80027b6:	4b31      	ldr	r3, [pc, #196]	; (800287c <mtx1_execute.lto_priv.86+0xcc>)
 80027b8:	b4c0      	push	{r6, r7}
 80027ba:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80027bc:	699b      	ldr	r3, [r3, #24]
 80027be:	b083      	sub	sp, #12
 80027c0:	689d      	ldr	r5, [r3, #8]

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
 80027c2:	4b2f      	ldr	r3, [pc, #188]	; (8002880 <mtx1_execute.lto_priv.86+0xd0>)
 80027c4:	0018      	movs	r0, r3
 80027c6:	4699      	mov	r9, r3
 80027c8:	f7fe fb5a 	bl	8000e80 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80027cc:	21a4      	movs	r1, #164	; 0xa4
 80027ce:	4f2d      	ldr	r7, [pc, #180]	; (8002884 <mtx1_execute.lto_priv.86+0xd4>)
 80027d0:	4c2d      	ldr	r4, [pc, #180]	; (8002888 <mtx1_execute.lto_priv.86+0xd8>)
 80027d2:	4b2e      	ldr	r3, [pc, #184]	; (800288c <mtx1_execute.lto_priv.86+0xdc>)
 80027d4:	1c6a      	adds	r2, r5, #1
 80027d6:	9300      	str	r3, [sp, #0]
 80027d8:	0049      	lsls	r1, r1, #1
 80027da:	003b      	movs	r3, r7
 80027dc:	0020      	movs	r0, r4
 80027de:	f7fe f897 	bl	8000910 <chThdCreateStatic>
 80027e2:	4e2b      	ldr	r6, [pc, #172]	; (8002890 <mtx1_execute.lto_priv.86+0xe0>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80027e4:	21a4      	movs	r1, #164	; 0xa4

static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80027e6:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80027e8:	0020      	movs	r0, r4
 80027ea:	4b2a      	ldr	r3, [pc, #168]	; (8002894 <mtx1_execute.lto_priv.86+0xe4>)
 80027ec:	3049      	adds	r0, #73	; 0x49
 80027ee:	1caa      	adds	r2, r5, #2
 80027f0:	9300      	str	r3, [sp, #0]
 80027f2:	0049      	lsls	r1, r1, #1
 80027f4:	003b      	movs	r3, r7
 80027f6:	30ff      	adds	r0, #255	; 0xff
 80027f8:	f7fe f88a 	bl	8000910 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80027fc:	23a4      	movs	r3, #164	; 0xa4
 80027fe:	21a4      	movs	r1, #164	; 0xa4
 8002800:	009b      	lsls	r3, r3, #2
static void mtx1_execute(void) {

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 8002802:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8002804:	18e0      	adds	r0, r4, r3
 8002806:	4b24      	ldr	r3, [pc, #144]	; (8002898 <mtx1_execute.lto_priv.86+0xe8>)
 8002808:	1cea      	adds	r2, r5, #3
 800280a:	9300      	str	r3, [sp, #0]
 800280c:	0049      	lsls	r1, r1, #1
 800280e:	003b      	movs	r3, r7
 8002810:	f7fe f87e 	bl	8000910 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8002814:	23f6      	movs	r3, #246	; 0xf6
 8002816:	21a4      	movs	r1, #164	; 0xa4
 8002818:	009b      	lsls	r3, r3, #2

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800281a:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800281c:	18e0      	adds	r0, r4, r3
 800281e:	4b1f      	ldr	r3, [pc, #124]	; (800289c <mtx1_execute.lto_priv.86+0xec>)
 8002820:	1d2a      	adds	r2, r5, #4
 8002822:	9300      	str	r3, [sp, #0]
 8002824:	0049      	lsls	r1, r1, #1
 8002826:	003b      	movs	r3, r7
 8002828:	f7fe f872 	bl	8000910 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800282c:	23a4      	movs	r3, #164	; 0xa4
 800282e:	21a4      	movs	r1, #164	; 0xa4
 8002830:	00db      	lsls	r3, r3, #3
  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
  chMtxLock(&m1);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8002832:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8002834:	18e0      	adds	r0, r4, r3
 8002836:	4b1a      	ldr	r3, [pc, #104]	; (80028a0 <mtx1_execute.lto_priv.86+0xf0>)
 8002838:	0049      	lsls	r1, r1, #1
 800283a:	1d6a      	adds	r2, r5, #5
 800283c:	9300      	str	r3, [sp, #0]
 800283e:	003b      	movs	r3, r7
 8002840:	f7fe f866 	bl	8000910 <chThdCreateStatic>
 8002844:	6130      	str	r0, [r6, #16]
  chMtxUnlock(&m1);
 8002846:	4648      	mov	r0, r9
 8002848:	f7fe fa82 	bl	8000d50 <chMtxUnlock>
  test_wait_threads();
 800284c:	f7fe fbd8 	bl	8001000 <test_wait_threads>
 8002850:	4643      	mov	r3, r8
 8002852:	699b      	ldr	r3, [r3, #24]
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 8002854:	2001      	movs	r0, #1
 8002856:	6899      	ldr	r1, [r3, #8]
 8002858:	1b49      	subs	r1, r1, r5
 800285a:	424b      	negs	r3, r1
 800285c:	4159      	adcs	r1, r3
 800285e:	b2c9      	uxtb	r1, r1
 8002860:	f7fd feae 	bl	80005c0 <_test_assert>
 8002864:	2800      	cmp	r0, #0
 8002866:	d103      	bne.n	8002870 <mtx1_execute.lto_priv.86+0xc0>
  test_assert_sequence(2, "ABCDE");
 8002868:	490e      	ldr	r1, [pc, #56]	; (80028a4 <mtx1_execute.lto_priv.86+0xf4>)
 800286a:	3002      	adds	r0, #2
 800286c:	f7fd fe78 	bl	8000560 <_test_assert_sequence>
}
 8002870:	b003      	add	sp, #12
 8002872:	bc0c      	pop	{r2, r3}
 8002874:	4690      	mov	r8, r2
 8002876:	4699      	mov	r9, r3
 8002878:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800287a:	46c0      	nop			; (mov r8, r8)
 800287c:	20000ac0 	.word	0x20000ac0
 8002880:	2000066c 	.word	0x2000066c
 8002884:	08002991 	.word	0x08002991
 8002888:	20000c58 	.word	0x20000c58
 800288c:	080064e4 	.word	0x080064e4
 8002890:	20000a28 	.word	0x20000a28
 8002894:	080064d8 	.word	0x080064d8
 8002898:	080064dc 	.word	0x080064dc
 800289c:	080064d0 	.word	0x080064d0
 80028a0:	080064d4 	.word	0x080064d4
 80028a4:	080064e0 	.word	0x080064e0
	...

080028b0 <thd1_execute.lto_priv.74>:
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 80028b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80028b2:	4647      	mov	r7, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80028b4:	4b29      	ldr	r3, [pc, #164]	; (800295c <thd1_execute.lto_priv.74+0xac>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028b6:	26a4      	movs	r6, #164	; 0xa4
 80028b8:	4698      	mov	r8, r3
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 80028ba:	b480      	push	{r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80028bc:	699b      	ldr	r3, [r3, #24]

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028be:	4f28      	ldr	r7, [pc, #160]	; (8002960 <thd1_execute.lto_priv.74+0xb0>)
 80028c0:	4c28      	ldr	r4, [pc, #160]	; (8002964 <thd1_execute.lto_priv.74+0xb4>)
 80028c2:	689a      	ldr	r2, [r3, #8]
 80028c4:	4b28      	ldr	r3, [pc, #160]	; (8002968 <thd1_execute.lto_priv.74+0xb8>)
static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {
 80028c6:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028c8:	0076      	lsls	r6, r6, #1
 80028ca:	9300      	str	r3, [sp, #0]
 80028cc:	0031      	movs	r1, r6
 80028ce:	003b      	movs	r3, r7
 80028d0:	3a05      	subs	r2, #5
 80028d2:	0020      	movs	r0, r4
 80028d4:	f7fe f81c 	bl	8000910 <chThdCreateStatic>
 80028d8:	4643      	mov	r3, r8
 80028da:	699b      	ldr	r3, [r3, #24]
 80028dc:	4d23      	ldr	r5, [pc, #140]	; (800296c <thd1_execute.lto_priv.74+0xbc>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80028de:	689a      	ldr	r2, [r3, #8]
 80028e0:	4b23      	ldr	r3, [pc, #140]	; (8002970 <thd1_execute.lto_priv.74+0xc0>)
  test_emit_token(*(char *)p);
}

static void thd1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80028e2:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80028e4:	0031      	movs	r1, r6
 80028e6:	9300      	str	r3, [sp, #0]
 80028e8:	3a04      	subs	r2, #4
 80028ea:	003b      	movs	r3, r7
 80028ec:	19a0      	adds	r0, r4, r6
 80028ee:	f7fe f80f 	bl	8000910 <chThdCreateStatic>
 80028f2:	4643      	mov	r3, r8
 80028f4:	699b      	ldr	r3, [r3, #24]
 80028f6:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80028f8:	689a      	ldr	r2, [r3, #8]
 80028fa:	23a4      	movs	r3, #164	; 0xa4
 80028fc:	009b      	lsls	r3, r3, #2
 80028fe:	18e0      	adds	r0, r4, r3
 8002900:	4b1c      	ldr	r3, [pc, #112]	; (8002974 <thd1_execute.lto_priv.74+0xc4>)
 8002902:	0031      	movs	r1, r6
 8002904:	9300      	str	r3, [sp, #0]
 8002906:	3a03      	subs	r2, #3
 8002908:	003b      	movs	r3, r7
 800290a:	f7fe f801 	bl	8000910 <chThdCreateStatic>
 800290e:	4643      	mov	r3, r8
 8002910:	699b      	ldr	r3, [r3, #24]
 8002912:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8002914:	689a      	ldr	r2, [r3, #8]
 8002916:	23f6      	movs	r3, #246	; 0xf6
 8002918:	009b      	lsls	r3, r3, #2
 800291a:	18e0      	adds	r0, r4, r3
 800291c:	4b16      	ldr	r3, [pc, #88]	; (8002978 <thd1_execute.lto_priv.74+0xc8>)
 800291e:	0031      	movs	r1, r6
 8002920:	9300      	str	r3, [sp, #0]
 8002922:	3a02      	subs	r2, #2
 8002924:	003b      	movs	r3, r7
 8002926:	f7fd fff3 	bl	8000910 <chThdCreateStatic>
 800292a:	4643      	mov	r3, r8
 800292c:	699b      	ldr	r3, [r3, #24]
 800292e:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002930:	689a      	ldr	r2, [r3, #8]
 8002932:	23a4      	movs	r3, #164	; 0xa4
 8002934:	00db      	lsls	r3, r3, #3
 8002936:	18e0      	adds	r0, r4, r3
 8002938:	4b10      	ldr	r3, [pc, #64]	; (800297c <thd1_execute.lto_priv.74+0xcc>)
 800293a:	3a01      	subs	r2, #1
 800293c:	0031      	movs	r1, r6
 800293e:	9300      	str	r3, [sp, #0]
 8002940:	003b      	movs	r3, r7
 8002942:	f7fd ffe5 	bl	8000910 <chThdCreateStatic>
 8002946:	6128      	str	r0, [r5, #16]
  test_wait_threads();
 8002948:	f7fe fb5a 	bl	8001000 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800294c:	490c      	ldr	r1, [pc, #48]	; (8002980 <thd1_execute.lto_priv.74+0xd0>)
 800294e:	2001      	movs	r0, #1
 8002950:	f7fd fe06 	bl	8000560 <_test_assert_sequence>
}
 8002954:	b002      	add	sp, #8
 8002956:	bc04      	pop	{r2}
 8002958:	4690      	mov	r8, r2
 800295a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800295c:	20000ac0 	.word	0x20000ac0
 8002960:	080029b1 	.word	0x080029b1
 8002964:	20000c58 	.word	0x20000c58
 8002968:	080064e4 	.word	0x080064e4
 800296c:	20000a28 	.word	0x20000a28
 8002970:	080064d8 	.word	0x080064d8
 8002974:	080064dc 	.word	0x080064dc
 8002978:	080064d0 	.word	0x080064d0
 800297c:	080064d4 	.word	0x080064d4
 8002980:	080064e0 	.word	0x080064e0
	...

08002990 <thread1.lto_priv.139>:
static void mtx1_setup(void) {

  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread1, p) {
 8002990:	b570      	push	{r4, r5, r6, lr}
 8002992:	0005      	movs	r5, r0

  chMtxLock(&m1);
 8002994:	4c05      	ldr	r4, [pc, #20]	; (80029ac <thread1.lto_priv.139+0x1c>)
 8002996:	0020      	movs	r0, r4
 8002998:	f7fe fa72 	bl	8000e80 <chMtxLock>
  test_emit_token(*(char *)p);
 800299c:	7828      	ldrb	r0, [r5, #0]
 800299e:	f7fd fe27 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m1);
 80029a2:	0020      	movs	r0, r4
 80029a4:	f7fe f9d4 	bl	8000d50 <chMtxUnlock>
}
 80029a8:	bd70      	pop	{r4, r5, r6, pc}
 80029aa:	46c0      	nop			; (mov r8, r8)
 80029ac:	2000066c 	.word	0x2000066c

080029b0 <thread.lto_priv.132>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 80029b0:	b510      	push	{r4, lr}

  test_emit_token(*(char *)p);
 80029b2:	7800      	ldrb	r0, [r0, #0]
 80029b4:	f7fd fe1c 	bl	80005f0 <test_emit_token>
}
 80029b8:	bd10      	pop	{r4, pc}
 80029ba:	46c0      	nop			; (mov r8, r8)
 80029bc:	0000      	movs	r0, r0
	...

080029c0 <thread1.lto_priv.138>:

static THD_FUNCTION(thread1, p) {
 80029c0:	b510      	push	{r4, lr}
 80029c2:	0004      	movs	r4, r0

  chSemWait(&sem1);
 80029c4:	4803      	ldr	r0, [pc, #12]	; (80029d4 <thread1.lto_priv.138+0x14>)
 80029c6:	f7fe f803 	bl	80009d0 <chSemWait>
  test_emit_token(*(char *)p);
 80029ca:	7820      	ldrb	r0, [r4, #0]
 80029cc:	f7fd fe10 	bl	80005f0 <test_emit_token>
}
 80029d0:	bd10      	pop	{r4, pc}
 80029d2:	46c0      	nop			; (mov r8, r8)
 80029d4:	200006ac 	.word	0x200006ac
	...

080029e0 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 80029e0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80029e2:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 80029e4:	6883      	ldr	r3, [r0, #8]
 80029e6:	2b00      	cmp	r3, #0
 80029e8:	dd03      	ble.n	80029f2 <thread4+0x12>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80029ea:	f7fd ff29 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80029ee:	b662      	cpsie	i

  chBSemSignal((binary_semaphore_t *)p);
}
 80029f0:	bd10      	pop	{r4, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 80029f2:	f7fe fb65 	bl	80010c0 <chSemSignalI>
 80029f6:	e7f8      	b.n	80029ea <thread4+0xa>
	...

08002a00 <thread2>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8002a00:	20fa      	movs	r0, #250	; 0xfa
static void sem2_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread2, p) {
 8002a02:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8002a04:	0040      	lsls	r0, r0, #1
 8002a06:	f7fe fd83 	bl	8001510 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a0a:	b672      	cpsid	i
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8002a0c:	4803      	ldr	r0, [pc, #12]	; (8002a1c <thread2+0x1c>)
 8002a0e:	f7fe fb57 	bl	80010c0 <chSemSignalI>
  chSchRescheduleS();
 8002a12:	f7fd ff15 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a16:	b662      	cpsie	i
  chSysUnlock();
}
 8002a18:	bd10      	pop	{r4, pc}
 8002a1a:	46c0      	nop			; (mov r8, r8)
 8002a1c:	200006ac 	.word	0x200006ac

08002a20 <sem4_execute.lto_priv.84>:
 8002a20:	2300      	movs	r3, #0
static THD_FUNCTION(thread4, p) {

  chBSemSignal((binary_semaphore_t *)p);
}

static void sem4_execute(void) {
 8002a22:	b510      	push	{r4, lr}
 8002a24:	b086      	sub	sp, #24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002a26:	ac03      	add	r4, sp, #12
 8002a28:	9403      	str	r4, [sp, #12]
  tqp->p_prev = (thread_t *)tqp;
 8002a2a:	6064      	str	r4, [r4, #4]
 8002a2c:	60a3      	str	r3, [r4, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a2e:	b672      	cpsid	i
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {

  chSysLock();
  chSemResetI(sp, n);
 8002a30:	2100      	movs	r1, #0
 8002a32:	0020      	movs	r0, r4
 8002a34:	f7fe fb5c 	bl	80010f0 <chSemResetI>
  chSchRescheduleS();
 8002a38:	f7fd ff02 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a3c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a3e:	b672      	cpsid	i
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8002a40:	9b05      	ldr	r3, [sp, #20]
 8002a42:	2001      	movs	r0, #1
 8002a44:	1e59      	subs	r1, r3, #1
 8002a46:	4319      	orrs	r1, r3
 8002a48:	0fc9      	lsrs	r1, r1, #31
 8002a4a:	f7fd fdb9 	bl	80005c0 <_test_assert>
 8002a4e:	2800      	cmp	r0, #0
 8002a50:	d002      	beq.n	8002a58 <sem4_execute.lto_priv.84+0x38>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a52:	b662      	cpsie	i

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
}
 8002a54:	b006      	add	sp, #24
 8002a56:	bd10      	pop	{r4, pc}
 8002a58:	b662      	cpsie	i
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8002a5a:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002a5c:	4b2d      	ldr	r3, [pc, #180]	; (8002b14 <sem4_execute.lto_priv.84+0xf4>)
 8002a5e:	0049      	lsls	r1, r1, #1
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002a60:	699b      	ldr	r3, [r3, #24]
 8002a62:	482d      	ldr	r0, [pc, #180]	; (8002b18 <sem4_execute.lto_priv.84+0xf8>)
 8002a64:	689a      	ldr	r2, [r3, #8]
 8002a66:	9400      	str	r4, [sp, #0]
 8002a68:	3a01      	subs	r2, #1
 8002a6a:	4b2c      	ldr	r3, [pc, #176]	; (8002b1c <sem4_execute.lto_priv.84+0xfc>)
 8002a6c:	f7fd ff50 	bl	8000910 <chThdCreateStatic>
 8002a70:	4b2b      	ldr	r3, [pc, #172]	; (8002b20 <sem4_execute.lto_priv.84+0x100>)
 8002a72:	6018      	str	r0, [r3, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->bs_sem);
 8002a74:	0020      	movs	r0, r4
 8002a76:	f7fd ffab 	bl	80009d0 <chSemWait>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a7a:	b672      	cpsid	i
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 8002a7c:	9b05      	ldr	r3, [sp, #20]
 8002a7e:	2002      	movs	r0, #2
 8002a80:	1e59      	subs	r1, r3, #1
 8002a82:	4319      	orrs	r1, r3
 8002a84:	0fc9      	lsrs	r1, r1, #31
 8002a86:	f7fd fd9b 	bl	80005c0 <_test_assert>
 8002a8a:	2800      	cmp	r0, #0
 8002a8c:	d1e1      	bne.n	8002a52 <sem4_execute.lto_priv.84+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a8e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a90:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8002a92:	68a3      	ldr	r3, [r4, #8]
 8002a94:	2b00      	cmp	r3, #0
 8002a96:	dd35      	ble.n	8002b04 <sem4_execute.lto_priv.84+0xe4>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8002a98:	f7fd fed2 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a9c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a9e:	b672      	cpsid	i

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 8002aa0:	9b05      	ldr	r3, [sp, #20]
 8002aa2:	2003      	movs	r0, #3
 8002aa4:	17d9      	asrs	r1, r3, #31
 8002aa6:	1ac9      	subs	r1, r1, r3
 8002aa8:	0fc9      	lsrs	r1, r1, #31
 8002aaa:	f7fd fd89 	bl	80005c0 <_test_assert>
 8002aae:	2800      	cmp	r0, #0
 8002ab0:	d1cf      	bne.n	8002a52 <sem4_execute.lto_priv.84+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ab2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ab4:	b672      	cpsid	i
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8002ab6:	9b05      	ldr	r3, [sp, #20]
 8002ab8:	2004      	movs	r0, #4
 8002aba:	1e59      	subs	r1, r3, #1
 8002abc:	424a      	negs	r2, r1
 8002abe:	414a      	adcs	r2, r1
 8002ac0:	b2d1      	uxtb	r1, r2
 8002ac2:	f7fd fd7d 	bl	80005c0 <_test_assert>
 8002ac6:	2800      	cmp	r0, #0
 8002ac8:	d1c3      	bne.n	8002a52 <sem4_execute.lto_priv.84+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002aca:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002acc:	b672      	cpsid	i
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 8002ace:	68a3      	ldr	r3, [r4, #8]
 8002ad0:	2b00      	cmp	r3, #0
 8002ad2:	dd1b      	ble.n	8002b0c <sem4_execute.lto_priv.84+0xec>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8002ad4:	f7fd feb4 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ad8:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ada:	b672      	cpsid	i

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 8002adc:	9b05      	ldr	r3, [sp, #20]
 8002ade:	2003      	movs	r0, #3
 8002ae0:	17d9      	asrs	r1, r3, #31
 8002ae2:	1ac9      	subs	r1, r1, r3
 8002ae4:	0fc9      	lsrs	r1, r1, #31
 8002ae6:	f7fd fd6b 	bl	80005c0 <_test_assert>
 8002aea:	2800      	cmp	r0, #0
 8002aec:	d1b1      	bne.n	8002a52 <sem4_execute.lto_priv.84+0x32>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002aee:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002af0:	b672      	cpsid	i
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 8002af2:	9b05      	ldr	r3, [sp, #20]
 8002af4:	2005      	movs	r0, #5
 8002af6:	1e59      	subs	r1, r3, #1
 8002af8:	424a      	negs	r2, r1
 8002afa:	414a      	adcs	r2, r1
 8002afc:	b2d1      	uxtb	r1, r2
 8002afe:	f7fd fd5f 	bl	80005c0 <_test_assert>
 8002b02:	e7a6      	b.n	8002a52 <sem4_execute.lto_priv.84+0x32>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
    chSemSignalI(&bsp->bs_sem);
 8002b04:	0020      	movs	r0, r4
 8002b06:	f7fe fadb 	bl	80010c0 <chSemSignalI>
 8002b0a:	e7c5      	b.n	8002a98 <sem4_execute.lto_priv.84+0x78>
 8002b0c:	0020      	movs	r0, r4
 8002b0e:	f7fe fad7 	bl	80010c0 <chSemSignalI>
 8002b12:	e7df      	b.n	8002ad4 <sem4_execute.lto_priv.84+0xb4>
 8002b14:	20000ac0 	.word	0x20000ac0
 8002b18:	20000c58 	.word	0x20000c58
 8002b1c:	080029e1 	.word	0x080029e1
 8002b20:	20000a28 	.word	0x20000a28
	...

08002b30 <sem3_execute.lto_priv.83>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002b30:	4b1d      	ldr	r3, [pc, #116]	; (8002ba8 <sem3_execute.lto_priv.83+0x78>)
  chSemSignal(&sem1);
}

static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002b32:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002b34:	699b      	ldr	r3, [r3, #24]
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8002b36:	b510      	push	{r4, lr}

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002b38:	689a      	ldr	r2, [r3, #8]
 8002b3a:	2300      	movs	r3, #0
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static void sem3_execute(void) {
 8002b3c:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8002b3e:	3201      	adds	r2, #1
 8002b40:	0049      	lsls	r1, r1, #1
 8002b42:	9300      	str	r3, [sp, #0]
 8002b44:	4819      	ldr	r0, [pc, #100]	; (8002bac <sem3_execute.lto_priv.83+0x7c>)
 8002b46:	4b1a      	ldr	r3, [pc, #104]	; (8002bb0 <sem3_execute.lto_priv.83+0x80>)
 8002b48:	f7fd fee2 	bl	8000910 <chThdCreateStatic>
 8002b4c:	4b19      	ldr	r3, [pc, #100]	; (8002bb4 <sem3_execute.lto_priv.83+0x84>)
 8002b4e:	6018      	str	r0, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 8002b50:	f002 fc56 	bl	8005400 <chSemSignalWait.constprop.48>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 8002b54:	4c18      	ldr	r4, [pc, #96]	; (8002bb8 <sem3_execute.lto_priv.83+0x88>)
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 8002b56:	2001      	movs	r0, #1
 8002b58:	6823      	ldr	r3, [r4, #0]
 8002b5a:	1b19      	subs	r1, r3, r4
 8002b5c:	424a      	negs	r2, r1
 8002b5e:	414a      	adcs	r2, r1
 8002b60:	b2d1      	uxtb	r1, r2
 8002b62:	f7fd fd2d 	bl	80005c0 <_test_assert>
 8002b66:	2800      	cmp	r0, #0
 8002b68:	d001      	beq.n	8002b6e <sem3_execute.lto_priv.83+0x3e>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");

  chSemSignalWait(&sem1, &sem1);
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
}
 8002b6a:	b002      	add	sp, #8
 8002b6c:	bd10      	pop	{r4, pc}
static void sem3_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
  chSemSignalWait(&sem1, &sem1);
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 8002b6e:	68a1      	ldr	r1, [r4, #8]
 8002b70:	3002      	adds	r0, #2
 8002b72:	424b      	negs	r3, r1
 8002b74:	4159      	adcs	r1, r3
 8002b76:	b2c9      	uxtb	r1, r1
 8002b78:	f7fd fd22 	bl	80005c0 <_test_assert>
 8002b7c:	2800      	cmp	r0, #0
 8002b7e:	d1f4      	bne.n	8002b6a <sem3_execute.lto_priv.83+0x3a>

  chSemSignalWait(&sem1, &sem1);
 8002b80:	f002 fc3e 	bl	8005400 <chSemSignalWait.constprop.48>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 8002b84:	6823      	ldr	r3, [r4, #0]
 8002b86:	2003      	movs	r0, #3
 8002b88:	1b19      	subs	r1, r3, r4
 8002b8a:	424a      	negs	r2, r1
 8002b8c:	414a      	adcs	r2, r1
 8002b8e:	b2d1      	uxtb	r1, r2
 8002b90:	f7fd fd16 	bl	80005c0 <_test_assert>
 8002b94:	2800      	cmp	r0, #0
 8002b96:	d1e8      	bne.n	8002b6a <sem3_execute.lto_priv.83+0x3a>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 8002b98:	68a3      	ldr	r3, [r4, #8]
 8002b9a:	3004      	adds	r0, #4
 8002b9c:	4259      	negs	r1, r3
 8002b9e:	4159      	adcs	r1, r3
 8002ba0:	b2c9      	uxtb	r1, r1
 8002ba2:	f7fd fd0d 	bl	80005c0 <_test_assert>
 8002ba6:	e7e0      	b.n	8002b6a <sem3_execute.lto_priv.83+0x3a>
 8002ba8:	20000ac0 	.word	0x20000ac0
 8002bac:	20000c58 	.word	0x20000c58
 8002bb0:	08002bc1 	.word	0x08002bc1
 8002bb4:	20000a28 	.word	0x20000a28
 8002bb8:	200006ac 	.word	0x200006ac
 8002bbc:	00000000 	.word	0x00000000

08002bc0 <thread3>:
static void sem3_setup(void) {

  chSemObjectInit(&sem1, 0);
}

static THD_FUNCTION(thread3, p) {
 8002bc0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8002bc2:	4c04      	ldr	r4, [pc, #16]	; (8002bd4 <thread3+0x14>)
 8002bc4:	0020      	movs	r0, r4
 8002bc6:	f7fd ff03 	bl	80009d0 <chSemWait>
  chSemSignal(&sem1);
 8002bca:	0020      	movs	r0, r4
 8002bcc:	f7fd fe88 	bl	80008e0 <chSemSignal>
}
 8002bd0:	bd10      	pop	{r4, pc}
 8002bd2:	46c0      	nop			; (mov r8, r8)
 8002bd4:	200006ac 	.word	0x200006ac
	...

08002be0 <sem2_execute.lto_priv.81>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static void sem2_execute(void) {
 8002be0:	b570      	push	{r4, r5, r6, lr}
 8002be2:	b082      	sub	sp, #8
 8002be4:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8002be6:	4c48      	ldr	r4, [pc, #288]	; (8002d08 <sem2_execute.lto_priv.81+0x128>)
 8002be8:	68a3      	ldr	r3, [r4, #8]
 8002bea:	3b01      	subs	r3, #1
 8002bec:	d500      	bpl.n	8002bf0 <sem2_execute.lto_priv.81+0x10>
 8002bee:	e089      	b.n	8002d04 <sem2_execute.lto_priv.81+0x124>
 8002bf0:	2100      	movs	r1, #0
 8002bf2:	60a3      	str	r3, [r4, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002bf4:	b662      	cpsie	i

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 8002bf6:	2001      	movs	r0, #1
 8002bf8:	f7fd fce2 	bl	80005c0 <_test_assert>
 8002bfc:	2800      	cmp	r0, #0
 8002bfe:	d001      	beq.n	8002c04 <sem2_execute.lto_priv.81+0x24>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
}
 8002c00:	b002      	add	sp, #8
 8002c02:	bd70      	pop	{r4, r5, r6, pc}
  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 8002c04:	6823      	ldr	r3, [r4, #0]
 8002c06:	3002      	adds	r0, #2
 8002c08:	1b19      	subs	r1, r3, r4
 8002c0a:	424a      	negs	r2, r1
 8002c0c:	414a      	adcs	r2, r1
 8002c0e:	b2d1      	uxtb	r1, r2
 8002c10:	f7fd fcd6 	bl	80005c0 <_test_assert>
 8002c14:	2800      	cmp	r0, #0
 8002c16:	d1f3      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 8002c18:	68a1      	ldr	r1, [r4, #8]
 8002c1a:	3003      	adds	r0, #3
 8002c1c:	424b      	negs	r3, r1
 8002c1e:	4159      	adcs	r1, r3
 8002c20:	b2c9      	uxtb	r1, r1
 8002c22:	f7fd fccd 	bl	80005c0 <_test_assert>
 8002c26:	2800      	cmp	r0, #0
 8002c28:	d1ea      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002c2a:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002c2c:	4b37      	ldr	r3, [pc, #220]	; (8002d0c <sem2_execute.lto_priv.81+0x12c>)
 8002c2e:	0049      	lsls	r1, r1, #1
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002c30:	699b      	ldr	r3, [r3, #24]
 8002c32:	689a      	ldr	r2, [r3, #8]
 8002c34:	9000      	str	r0, [sp, #0]
 8002c36:	3a01      	subs	r2, #1
 8002c38:	4b35      	ldr	r3, [pc, #212]	; (8002d10 <sem2_execute.lto_priv.81+0x130>)
 8002c3a:	4836      	ldr	r0, [pc, #216]	; (8002d14 <sem2_execute.lto_priv.81+0x134>)
 8002c3c:	f7fd fe68 	bl	8000910 <chThdCreateStatic>
 8002c40:	4b35      	ldr	r3, [pc, #212]	; (8002d18 <sem2_execute.lto_priv.81+0x138>)
 8002c42:	6018      	str	r0, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 8002c44:	4835      	ldr	r0, [pc, #212]	; (8002d1c <sem2_execute.lto_priv.81+0x13c>)
 8002c46:	f002 fbb3 	bl	80053b0 <chSemWaitTimeout.constprop.50>
 8002c4a:	0005      	movs	r5, r0
  test_wait_threads();
 8002c4c:	f7fe f9d8 	bl	8001000 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 8002c50:	4269      	negs	r1, r5
 8002c52:	4169      	adcs	r1, r5
 8002c54:	2004      	movs	r0, #4
 8002c56:	b2c9      	uxtb	r1, r1
 8002c58:	f7fd fcb2 	bl	80005c0 <_test_assert>
 8002c5c:	2800      	cmp	r0, #0
 8002c5e:	d1cf      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 8002c60:	6823      	ldr	r3, [r4, #0]
 8002c62:	3005      	adds	r0, #5
 8002c64:	1b19      	subs	r1, r3, r4
 8002c66:	424a      	negs	r2, r1
 8002c68:	414a      	adcs	r2, r1
 8002c6a:	b2d1      	uxtb	r1, r2
 8002c6c:	f7fd fca8 	bl	80005c0 <_test_assert>
 8002c70:	2800      	cmp	r0, #0
 8002c72:	d1c5      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 8002c74:	68a1      	ldr	r1, [r4, #8]
 8002c76:	3006      	adds	r0, #6
 8002c78:	424b      	negs	r3, r1
 8002c7a:	4159      	adcs	r1, r3
 8002c7c:	b2c9      	uxtb	r1, r1
 8002c7e:	f7fd fc9f 	bl	80005c0 <_test_assert>
 8002c82:	2800      	cmp	r0, #0
 8002c84:	d1bc      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 8002c86:	f7fe fc4b 	bl	8001520 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c8a:	b672      	cpsid	i
 8002c8c:	2380      	movs	r3, #128	; 0x80
 8002c8e:	05db      	lsls	r3, r3, #23
 8002c90:	6a5e      	ldr	r6, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002c92:	b662      	cpsie	i
 8002c94:	2541      	movs	r5, #65	; 0x41
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
    test_emit_token('A' + i);
 8002c96:	0028      	movs	r0, r5
 8002c98:	f7fd fcaa 	bl	80005f0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 8002c9c:	20fa      	movs	r0, #250	; 0xfa
 8002c9e:	0040      	lsls	r0, r0, #1
 8002ca0:	f002 fb86 	bl	80053b0 <chSemWaitTimeout.constprop.50>
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 8002ca4:	3001      	adds	r0, #1
 8002ca6:	4241      	negs	r1, r0
 8002ca8:	4141      	adcs	r1, r0
 8002caa:	2007      	movs	r0, #7
 8002cac:	b2c9      	uxtb	r1, r1
 8002cae:	f7fd fc87 	bl	80005c0 <_test_assert>
 8002cb2:	2800      	cmp	r0, #0
 8002cb4:	d1a4      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 8002cb6:	6823      	ldr	r3, [r4, #0]
 8002cb8:	3008      	adds	r0, #8
 8002cba:	1b19      	subs	r1, r3, r4
 8002cbc:	424a      	negs	r2, r1
 8002cbe:	414a      	adcs	r2, r1
 8002cc0:	b2d1      	uxtb	r1, r2
 8002cc2:	f7fd fc7d 	bl	80005c0 <_test_assert>
 8002cc6:	2800      	cmp	r0, #0
 8002cc8:	d19a      	bne.n	8002c00 <sem2_execute.lto_priv.81+0x20>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 8002cca:	68a1      	ldr	r1, [r4, #8]
 8002ccc:	3009      	adds	r0, #9
 8002cce:	424b      	negs	r3, r1
 8002cd0:	4159      	adcs	r1, r3
 8002cd2:	b2c9      	uxtb	r1, r1
 8002cd4:	f7fd fc74 	bl	80005c0 <_test_assert>
 8002cd8:	2800      	cmp	r0, #0
 8002cda:	d000      	beq.n	8002cde <sem2_execute.lto_priv.81+0xfe>
 8002cdc:	e790      	b.n	8002c00 <sem2_execute.lto_priv.81+0x20>
 8002cde:	3501      	adds	r5, #1
 8002ce0:	b2ed      	uxtb	r5, r5
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 8002ce2:	2d46      	cmp	r5, #70	; 0x46
 8002ce4:	d1d7      	bne.n	8002c96 <sem2_execute.lto_priv.81+0xb6>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 8002ce6:	490e      	ldr	r1, [pc, #56]	; (8002d20 <sem2_execute.lto_priv.81+0x140>)
 8002ce8:	300a      	adds	r0, #10
 8002cea:	f7fd fc39 	bl	8000560 <_test_assert_sequence>
 8002cee:	2800      	cmp	r0, #0
 8002cf0:	d000      	beq.n	8002cf4 <sem2_execute.lto_priv.81+0x114>
 8002cf2:	e785      	b.n	8002c00 <sem2_execute.lto_priv.81+0x20>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 8002cf4:	4b0b      	ldr	r3, [pc, #44]	; (8002d24 <sem2_execute.lto_priv.81+0x144>)
 8002cf6:	300b      	adds	r0, #11
 8002cf8:	18f2      	adds	r2, r6, r3
 8002cfa:	4b0b      	ldr	r3, [pc, #44]	; (8002d28 <sem2_execute.lto_priv.81+0x148>)
 8002cfc:	18f1      	adds	r1, r6, r3
 8002cfe:	f7fd fc0f 	bl	8000520 <_test_assert_time_window>
 8002d02:	e77d      	b.n	8002c00 <sem2_execute.lto_priv.81+0x20>
 8002d04:	2101      	movs	r1, #1
 8002d06:	e775      	b.n	8002bf4 <sem2_execute.lto_priv.81+0x14>
 8002d08:	200006ac 	.word	0x200006ac
 8002d0c:	20000ac0 	.word	0x20000ac0
 8002d10:	08002a01 	.word	0x08002a01
 8002d14:	20000c58 	.word	0x20000c58
 8002d18:	20000a28 	.word	0x20000a28
 8002d1c:	00001388 	.word	0x00001388
 8002d20:	080064e0 	.word	0x080064e0
 8002d24:	000009d8 	.word	0x000009d8
 8002d28:	000009c4 	.word	0x000009c4
 8002d2c:	00000000 	.word	0x00000000

08002d30 <sem1_execute.lto_priv.79>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8002d30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002d32:	464f      	mov	r7, r9
 8002d34:	4646      	mov	r6, r8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002d36:	21a4      	movs	r1, #164	; 0xa4

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8002d38:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002d3a:	4b4f      	ldr	r3, [pc, #316]	; (8002e78 <sem1_execute.lto_priv.79+0x148>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002d3c:	4f4f      	ldr	r7, [pc, #316]	; (8002e7c <sem1_execute.lto_priv.79+0x14c>)
 8002d3e:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002d40:	699b      	ldr	r3, [r3, #24]
 8002d42:	4e4f      	ldr	r6, [pc, #316]	; (8002e80 <sem1_execute.lto_priv.79+0x150>)
 8002d44:	689a      	ldr	r2, [r3, #8]
 8002d46:	4b4f      	ldr	r3, [pc, #316]	; (8002e84 <sem1_execute.lto_priv.79+0x154>)

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {
 8002d48:	b083      	sub	sp, #12

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002d4a:	3205      	adds	r2, #5
 8002d4c:	9300      	str	r3, [sp, #0]
 8002d4e:	0049      	lsls	r1, r1, #1
 8002d50:	4699      	mov	r9, r3
 8002d52:	0030      	movs	r0, r6
 8002d54:	003b      	movs	r3, r7
 8002d56:	f7fd fddb 	bl	8000910 <chThdCreateStatic>
 8002d5a:	4643      	mov	r3, r8
 8002d5c:	4d4a      	ldr	r5, [pc, #296]	; (8002e88 <sem1_execute.lto_priv.79+0x158>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002d5e:	21a4      	movs	r1, #164	; 0xa4
  test_emit_token(*(char *)p);
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002d60:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002d62:	0030      	movs	r0, r6
 8002d64:	699b      	ldr	r3, [r3, #24]
 8002d66:	3049      	adds	r0, #73	; 0x49
 8002d68:	689a      	ldr	r2, [r3, #8]
 8002d6a:	4b48      	ldr	r3, [pc, #288]	; (8002e8c <sem1_execute.lto_priv.79+0x15c>)
 8002d6c:	3201      	adds	r2, #1
 8002d6e:	9300      	str	r3, [sp, #0]
 8002d70:	0049      	lsls	r1, r1, #1
 8002d72:	003b      	movs	r3, r7
 8002d74:	30ff      	adds	r0, #255	; 0xff
 8002d76:	f7fd fdcb 	bl	8000910 <chThdCreateStatic>
 8002d7a:	4643      	mov	r3, r8
 8002d7c:	699b      	ldr	r3, [r3, #24]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002d7e:	21a4      	movs	r1, #164	; 0xa4
 8002d80:	689a      	ldr	r2, [r3, #8]
 8002d82:	23a4      	movs	r3, #164	; 0xa4
 8002d84:	009b      	lsls	r3, r3, #2
}

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8002d86:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002d88:	18f0      	adds	r0, r6, r3
 8002d8a:	4b41      	ldr	r3, [pc, #260]	; (8002e90 <sem1_execute.lto_priv.79+0x160>)
 8002d8c:	3203      	adds	r2, #3
 8002d8e:	9300      	str	r3, [sp, #0]
 8002d90:	0049      	lsls	r1, r1, #1
 8002d92:	003b      	movs	r3, r7
 8002d94:	f7fd fdbc 	bl	8000910 <chThdCreateStatic>
 8002d98:	4643      	mov	r3, r8
 8002d9a:	699b      	ldr	r3, [r3, #24]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002d9c:	21a4      	movs	r1, #164	; 0xa4
 8002d9e:	689a      	ldr	r2, [r3, #8]
 8002da0:	23f6      	movs	r3, #246	; 0xf6
 8002da2:	009b      	lsls	r3, r3, #2

static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 8002da4:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002da6:	18f0      	adds	r0, r6, r3
 8002da8:	4b3a      	ldr	r3, [pc, #232]	; (8002e94 <sem1_execute.lto_priv.79+0x164>)
 8002daa:	3204      	adds	r2, #4
 8002dac:	9300      	str	r3, [sp, #0]
 8002dae:	0049      	lsls	r1, r1, #1
 8002db0:	003b      	movs	r3, r7
 8002db2:	f7fd fdad 	bl	8000910 <chThdCreateStatic>
 8002db6:	4643      	mov	r3, r8
 8002db8:	699b      	ldr	r3, [r3, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002dba:	21a4      	movs	r1, #164	; 0xa4
 8002dbc:	689a      	ldr	r2, [r3, #8]
 8002dbe:	23a4      	movs	r3, #164	; 0xa4
 8002dc0:	00db      	lsls	r3, r3, #3
static void sem1_execute(void) {

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8002dc2:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002dc4:	18f0      	adds	r0, r6, r3
 8002dc6:	4b34      	ldr	r3, [pc, #208]	; (8002e98 <sem1_execute.lto_priv.79+0x168>)
 8002dc8:	0049      	lsls	r1, r1, #1
 8002dca:	3202      	adds	r2, #2
 8002dcc:	9300      	str	r3, [sp, #0]
 8002dce:	003b      	movs	r3, r7
 8002dd0:	f7fd fd9e 	bl	8000910 <chThdCreateStatic>
  chSemSignal(&sem1);
 8002dd4:	4c31      	ldr	r4, [pc, #196]	; (8002e9c <sem1_execute.lto_priv.79+0x16c>)

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8002dd6:	6128      	str	r0, [r5, #16]
  chSemSignal(&sem1);
 8002dd8:	0020      	movs	r0, r4
 8002dda:	f7fd fd81 	bl	80008e0 <chSemSignal>
  chSemSignal(&sem1);
 8002dde:	0020      	movs	r0, r4
 8002de0:	f7fd fd7e 	bl	80008e0 <chSemSignal>
  chSemSignal(&sem1);
 8002de4:	0020      	movs	r0, r4
 8002de6:	f7fd fd7b 	bl	80008e0 <chSemSignal>
  chSemSignal(&sem1);
 8002dea:	0020      	movs	r0, r4
 8002dec:	f7fd fd78 	bl	80008e0 <chSemSignal>
  chSemSignal(&sem1);
 8002df0:	0020      	movs	r0, r4
 8002df2:	f7fd fd75 	bl	80008e0 <chSemSignal>
  test_wait_threads();
 8002df6:	f7fe f903 	bl	8001000 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 8002dfa:	4929      	ldr	r1, [pc, #164]	; (8002ea0 <sem1_execute.lto_priv.79+0x170>)
 8002dfc:	2001      	movs	r0, #1
 8002dfe:	f7fd fbaf 	bl	8000560 <_test_assert_sequence>
 8002e02:	2800      	cmp	r0, #0
 8002e04:	d004      	beq.n	8002e10 <sem1_execute.lto_priv.79+0xe0>
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
  chSysUnlock();
  test_wait_threads();
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
}
 8002e06:	b003      	add	sp, #12
 8002e08:	bc0c      	pop	{r2, r3}
 8002e0a:	4690      	mov	r8, r2
 8002e0c:	4699      	mov	r9, r3
 8002e0e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002e10:	4643      	mov	r3, r8
 8002e12:	699b      	ldr	r3, [r3, #24]
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 8002e14:	21a4      	movs	r1, #164	; 0xa4
 8002e16:	689a      	ldr	r2, [r3, #8]
 8002e18:	464b      	mov	r3, r9
 8002e1a:	3205      	adds	r2, #5
 8002e1c:	9300      	str	r3, [sp, #0]
 8002e1e:	0049      	lsls	r1, r1, #1
 8002e20:	003b      	movs	r3, r7
 8002e22:	0030      	movs	r0, r6
 8002e24:	f7fd fd74 	bl	8000910 <chThdCreateStatic>
 8002e28:	6028      	str	r0, [r5, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e2a:	b672      	cpsid	i
 8002e2c:	2502      	movs	r5, #2
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->s_cnt <= (cnt_t)0) {
 8002e2e:	0026      	movs	r6, r4
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002e30:	2700      	movs	r7, #0
 8002e32:	e002      	b.n	8002e3a <sem1_execute.lto_priv.79+0x10a>
 8002e34:	3d01      	subs	r5, #1
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002e36:	2d00      	cmp	r5, #0
 8002e38:	d00e      	beq.n	8002e58 <sem1_execute.lto_priv.79+0x128>
    if (++sp->s_cnt <= (cnt_t)0) {
 8002e3a:	68a3      	ldr	r3, [r4, #8]
 8002e3c:	3301      	adds	r3, #1
 8002e3e:	60a3      	str	r3, [r4, #8]
 8002e40:	2b00      	cmp	r3, #0
 8002e42:	dcf7      	bgt.n	8002e34 <sem1_execute.lto_priv.79+0x104>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8002e44:	6830      	ldr	r0, [r6, #0]
 8002e46:	3d01      	subs	r5, #1

  tqp->p_next = tp->p_next;
 8002e48:	6803      	ldr	r3, [r0, #0]
 8002e4a:	6033      	str	r3, [r6, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002e4c:	605e      	str	r6, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8002e4e:	f7fd fddf 	bl	8000a10 <chSchReadyI>
 8002e52:	6207      	str	r7, [r0, #32]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8002e54:	2d00      	cmp	r5, #0
 8002e56:	d1f0      	bne.n	8002e3a <sem1_execute.lto_priv.79+0x10a>
  chSysLock();
  chSemAddCounterI(&sem1, 2);
  chSchRescheduleS();
 8002e58:	f7fd fcf2 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e5c:	b662      	cpsie	i
  chSysUnlock();
  test_wait_threads();
 8002e5e:	f7fe f8cf 	bl	8001000 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e62:	b672      	cpsid	i
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 8002e64:	68a1      	ldr	r1, [r4, #8]
 8002e66:	2002      	movs	r0, #2
 8002e68:	3901      	subs	r1, #1
 8002e6a:	424a      	negs	r2, r1
 8002e6c:	414a      	adcs	r2, r1
 8002e6e:	b2d1      	uxtb	r1, r2
 8002e70:	f7fd fba6 	bl	80005c0 <_test_assert>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e74:	b662      	cpsie	i
 8002e76:	e7c6      	b.n	8002e06 <sem1_execute.lto_priv.79+0xd6>
 8002e78:	20000ac0 	.word	0x20000ac0
 8002e7c:	080029c1 	.word	0x080029c1
 8002e80:	20000c58 	.word	0x20000c58
 8002e84:	080064d4 	.word	0x080064d4
 8002e88:	20000a28 	.word	0x20000a28
 8002e8c:	080064d0 	.word	0x080064d0
 8002e90:	080064dc 	.word	0x080064dc
 8002e94:	080064d8 	.word	0x080064d8
 8002e98:	080064e4 	.word	0x080064e4
 8002e9c:	200006ac 	.word	0x200006ac
 8002ea0:	080064e0 	.word	0x080064e0
	...

08002eb0 <thd2_execute.lto_priv.75>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8002eb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002eb2:	464f      	mov	r7, r9
 8002eb4:	4646      	mov	r6, r8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002eb6:	4b46      	ldr	r3, [pc, #280]	; (8002fd0 <thd2_execute.lto_priv.75+0x120>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8002eb8:	b4c0      	push	{r6, r7}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002eba:	4e46      	ldr	r6, [pc, #280]	; (8002fd4 <thd2_execute.lto_priv.75+0x124>)

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002ebc:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8002ebe:	69b3      	ldr	r3, [r6, #24]
 8002ec0:	4d45      	ldr	r5, [pc, #276]	; (8002fd8 <thd2_execute.lto_priv.75+0x128>)
 8002ec2:	689a      	ldr	r2, [r3, #8]
 8002ec4:	23a4      	movs	r3, #164	; 0xa4
 8002ec6:	005b      	lsls	r3, r3, #1
 8002ec8:	4699      	mov	r9, r3
 8002eca:	4b44      	ldr	r3, [pc, #272]	; (8002fdc <thd2_execute.lto_priv.75+0x12c>)
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 8002ecc:	b083      	sub	sp, #12

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8002ece:	002c      	movs	r4, r5
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002ed0:	9300      	str	r3, [sp, #0]
 8002ed2:	4649      	mov	r1, r9
 8002ed4:	4643      	mov	r3, r8
 8002ed6:	3a04      	subs	r2, #4
 8002ed8:	0028      	movs	r0, r5
 8002eda:	f7fd fd19 	bl	8000910 <chThdCreateStatic>
 8002ede:	69b3      	ldr	r3, [r6, #24]
 8002ee0:	4f3f      	ldr	r7, [pc, #252]	; (8002fe0 <thd2_execute.lto_priv.75+0x130>)
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8002ee2:	689a      	ldr	r2, [r3, #8]
 8002ee4:	3c49      	subs	r4, #73	; 0x49
 8002ee6:	4b3f      	ldr	r3, [pc, #252]	; (8002fe4 <thd2_execute.lto_priv.75+0x134>)
 8002ee8:	3cff      	subs	r4, #255	; 0xff
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8002eea:	6078      	str	r0, [r7, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8002eec:	4649      	mov	r1, r9
 8002eee:	9300      	str	r3, [sp, #0]
 8002ef0:	3a05      	subs	r2, #5
 8002ef2:	4643      	mov	r3, r8
 8002ef4:	0020      	movs	r0, r4
 8002ef6:	f7fd fd0b 	bl	8000910 <chThdCreateStatic>
 8002efa:	69b3      	ldr	r3, [r6, #24]
 8002efc:	6038      	str	r0, [r7, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8002efe:	689a      	ldr	r2, [r3, #8]
 8002f00:	23f6      	movs	r3, #246	; 0xf6
 8002f02:	009b      	lsls	r3, r3, #2
 8002f04:	18e8      	adds	r0, r5, r3
 8002f06:	4b38      	ldr	r3, [pc, #224]	; (8002fe8 <thd2_execute.lto_priv.75+0x138>)
 8002f08:	4649      	mov	r1, r9
 8002f0a:	9300      	str	r3, [sp, #0]
 8002f0c:	3a01      	subs	r2, #1
 8002f0e:	4643      	mov	r3, r8
 8002f10:	f7fd fcfe 	bl	8000910 <chThdCreateStatic>
 8002f14:	69b3      	ldr	r3, [r6, #24]
 8002f16:	6138      	str	r0, [r7, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8002f18:	689a      	ldr	r2, [r3, #8]
 8002f1a:	23a4      	movs	r3, #164	; 0xa4
 8002f1c:	009b      	lsls	r3, r3, #2
 8002f1e:	18e8      	adds	r0, r5, r3
 8002f20:	4b32      	ldr	r3, [pc, #200]	; (8002fec <thd2_execute.lto_priv.75+0x13c>)
 8002f22:	3a02      	subs	r2, #2
 8002f24:	9300      	str	r3, [sp, #0]
 8002f26:	4649      	mov	r1, r9
 8002f28:	4643      	mov	r3, r8
 8002f2a:	f7fd fcf1 	bl	8000910 <chThdCreateStatic>
 8002f2e:	60f8      	str	r0, [r7, #12]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002f30:	b672      	cpsid	i
 8002f32:	69b3      	ldr	r3, [r6, #24]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8002f34:	689a      	ldr	r2, [r3, #8]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002f36:	239b      	movs	r3, #155	; 0x9b
 8002f38:	009b      	lsls	r3, r3, #2
 8002f3a:	18e9      	adds	r1, r5, r3
 8002f3c:	3330      	adds	r3, #48	; 0x30
 8002f3e:	50e1      	str	r1, [r4, r3]
 8002f40:	4641      	mov	r1, r8
 8002f42:	3329      	adds	r3, #41	; 0x29
 8002f44:	33ff      	adds	r3, #255	; 0xff
 8002f46:	50e1      	str	r1, [r4, r3]
 8002f48:	4929      	ldr	r1, [pc, #164]	; (8002ff0 <thd2_execute.lto_priv.75+0x140>)
 8002f4a:	3304      	adds	r3, #4
 8002f4c:	50e1      	str	r1, [r4, r3]
 8002f4e:	4929      	ldr	r1, [pc, #164]	; (8002ff4 <thd2_execute.lto_priv.75+0x144>)
 8002f50:	330c      	adds	r3, #12
 8002f52:	50e1      	str	r1, [r4, r3]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002f54:	2102      	movs	r1, #2
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002f56:	3b3d      	subs	r3, #61	; 0x3d
 8002f58:	3a03      	subs	r2, #3
 8002f5a:	3bff      	subs	r3, #255	; 0xff
 8002f5c:	50e2      	str	r2, [r4, r3]
  tp->p_state = CH_STATE_WTSTART;
 8002f5e:	3314      	adds	r3, #20
 8002f60:	54e1      	strb	r1, [r4, r3]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002f62:	2300      	movs	r3, #0
 8002f64:	4924      	ldr	r1, [pc, #144]	; (8002ff8 <thd2_execute.lto_priv.75+0x148>)
 8002f66:	5463      	strb	r3, [r4, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002f68:	311f      	adds	r1, #31
 8002f6a:	5062      	str	r2, [r4, r1]
  tp->p_mtxlist = NULL;
 8002f6c:	22b2      	movs	r2, #178	; 0xb2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002f6e:	2101      	movs	r1, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002f70:	0092      	lsls	r2, r2, #2
 8002f72:	50a3      	str	r3, [r4, r2]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002f74:	3a04      	subs	r2, #4
 8002f76:	50a3      	str	r3, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002f78:	4a20      	ldr	r2, [pc, #128]	; (8002ffc <thd2_execute.lto_priv.75+0x14c>)
 8002f7a:	54a1      	strb	r1, [r4, r2]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002f7c:	3a06      	subs	r2, #6
 8002f7e:	50a3      	str	r3, [r4, r2]
  REG_INSERT(tp);
 8002f80:	23a8      	movs	r3, #168	; 0xa8
 8002f82:	6972      	ldr	r2, [r6, #20]
 8002f84:	009b      	lsls	r3, r3, #2
 8002f86:	50e6      	str	r6, [r4, r3]
 8002f88:	3304      	adds	r3, #4
 8002f8a:	50e2      	str	r2, [r4, r3]
 8002f8c:	002b      	movs	r3, r5
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002f8e:	0029      	movs	r1, r5
 8002f90:	444b      	add	r3, r9
 8002f92:	6113      	str	r3, [r2, #16]
 8002f94:	22ad      	movs	r2, #173	; 0xad
 8002f96:	316d      	adds	r1, #109	; 0x6d
 8002f98:	31ff      	adds	r1, #255	; 0xff
 8002f9a:	0092      	lsls	r2, r2, #2
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002f9c:	3571      	adds	r5, #113	; 0x71
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002f9e:	50a1      	str	r1, [r4, r2]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002fa0:	35ff      	adds	r5, #255	; 0xff
 8002fa2:	3204      	adds	r2, #4
 8002fa4:	50a5      	str	r5, [r4, r2]
  tqp->p_prev = (thread_t *)tqp;
 8002fa6:	3204      	adds	r2, #4
 8002fa8:	6173      	str	r3, [r6, #20]
 8002faa:	50a5      	str	r5, [r4, r2]
 8002fac:	60bb      	str	r3, [r7, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002fae:	b662      	cpsie	i
  chSysUnlock();
  chThdStart(threads[2]);
 8002fb0:	68b8      	ldr	r0, [r7, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002fb2:	b672      	cpsid	i
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8002fb4:	f7fd fd2c 	bl	8000a10 <chSchReadyI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002fb8:	b662      	cpsie	i
  test_wait_threads();
 8002fba:	f7fe f821 	bl	8001000 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8002fbe:	4910      	ldr	r1, [pc, #64]	; (8003000 <thd2_execute.lto_priv.75+0x150>)
 8002fc0:	2001      	movs	r0, #1
 8002fc2:	f7fd facd 	bl	8000560 <_test_assert_sequence>
}
 8002fc6:	b003      	add	sp, #12
 8002fc8:	bc0c      	pop	{r2, r3}
 8002fca:	4690      	mov	r8, r2
 8002fcc:	4699      	mov	r9, r3
 8002fce:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8002fd0:	080029b1 	.word	0x080029b1
 8002fd4:	20000ac0 	.word	0x20000ac0
 8002fd8:	20000da0 	.word	0x20000da0
 8002fdc:	080064d8 	.word	0x080064d8
 8002fe0:	20000a28 	.word	0x20000a28
 8002fe4:	080064e4 	.word	0x080064e4
 8002fe8:	080064d4 	.word	0x080064d4
 8002fec:	080064d0 	.word	0x080064d0
 8002ff0:	080064dc 	.word	0x080064dc
 8002ff4:	080001b1 	.word	0x080001b1
 8002ff8:	000002ad 	.word	0x000002ad
 8002ffc:	000002ae 	.word	0x000002ae
 8003000:	080064e0 	.word	0x080064e0
	...

08003010 <thd4_execute.lto_priv.77>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 8003010:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  test_wait_tick();
 8003012:	f7fe fa85 	bl	8001520 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003016:	b672      	cpsid	i
 8003018:	2580      	movs	r5, #128	; 0x80
 800301a:	05ed      	lsls	r5, r5, #23
 800301c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800301e:	b662      	cpsie	i

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMicroseconds(100000);
 8003020:	20fa      	movs	r0, #250	; 0xfa
 8003022:	0080      	lsls	r0, r0, #2
 8003024:	f7fe fa74 	bl	8001510 <chThdSleep>
  test_assert_time_window(1,
 8003028:	4b1f      	ldr	r3, [pc, #124]	; (80030a8 <thd4_execute.lto_priv.77+0x98>)
 800302a:	2001      	movs	r0, #1
 800302c:	18e2      	adds	r2, r4, r3
 800302e:	3b03      	subs	r3, #3
 8003030:	18e1      	adds	r1, r4, r3
 8003032:	f7fd fa75 	bl	8000520 <_test_assert_time_window>
 8003036:	2800      	cmp	r0, #0
 8003038:	d000      	beq.n	800303c <thd4_execute.lto_priv.77+0x2c>
  time = chVTGetSystemTime() + MS2ST(100);
  chThdSleepUntil(time);
  test_assert_time_window(4,
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800303a:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800303c:	b672      	cpsid	i
 800303e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003040:	b662      	cpsie	i
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
  chThdSleepMilliseconds(100);
 8003042:	20fa      	movs	r0, #250	; 0xfa
 8003044:	0080      	lsls	r0, r0, #2
 8003046:	f7fe fa63 	bl	8001510 <chThdSleep>
  test_assert_time_window(2,
 800304a:	4b17      	ldr	r3, [pc, #92]	; (80030a8 <thd4_execute.lto_priv.77+0x98>)
 800304c:	2002      	movs	r0, #2
 800304e:	18e2      	adds	r2, r4, r3
 8003050:	3b03      	subs	r3, #3
 8003052:	18e1      	adds	r1, r4, r3
 8003054:	f7fd fa64 	bl	8000520 <_test_assert_time_window>
 8003058:	2800      	cmp	r0, #0
 800305a:	d1ee      	bne.n	800303a <thd4_execute.lto_priv.77+0x2a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800305c:	b672      	cpsid	i
 800305e:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003060:	b662      	cpsie	i
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
  chThdSleepSeconds(1);
 8003062:	4812      	ldr	r0, [pc, #72]	; (80030ac <thd4_execute.lto_priv.77+0x9c>)
 8003064:	f7fe fa54 	bl	8001510 <chThdSleep>
  test_assert_time_window(3,
 8003068:	4b11      	ldr	r3, [pc, #68]	; (80030b0 <thd4_execute.lto_priv.77+0xa0>)
 800306a:	2003      	movs	r0, #3
 800306c:	18e2      	adds	r2, r4, r3
 800306e:	4b0f      	ldr	r3, [pc, #60]	; (80030ac <thd4_execute.lto_priv.77+0x9c>)
 8003070:	18e1      	adds	r1, r4, r3
 8003072:	f7fd fa55 	bl	8000520 <_test_assert_time_window>
 8003076:	2800      	cmp	r0, #0
 8003078:	d1df      	bne.n	800303a <thd4_execute.lto_priv.77+0x2a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800307a:	b672      	cpsid	i
 800307c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800307e:	b662      	cpsie	i
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 8003080:	23fa      	movs	r3, #250	; 0xfa
 8003082:	009b      	lsls	r3, r3, #2
 8003084:	18e6      	adds	r6, r4, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003086:	b672      	cpsid	i
 8003088:	6a69      	ldr	r1, [r5, #36]	; 0x24
 * @api
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
 800308a:	1a71      	subs	r1, r6, r1
  if (time > (systime_t)0) {
 800308c:	d107      	bne.n	800309e <thd4_execute.lto_priv.77+0x8e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800308e:	b662      	cpsie	i
  chThdSleepUntil(time);
  test_assert_time_window(4,
 8003090:	4b05      	ldr	r3, [pc, #20]	; (80030a8 <thd4_execute.lto_priv.77+0x98>)
 8003092:	0031      	movs	r1, r6
 8003094:	18e2      	adds	r2, r4, r3
 8003096:	2004      	movs	r0, #4
 8003098:	f7fd fa42 	bl	8000520 <_test_assert_time_window>
 800309c:	e7cd      	b.n	800303a <thd4_execute.lto_priv.77+0x2a>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800309e:	3008      	adds	r0, #8
 80030a0:	f7fe f8de 	bl	8001260 <chSchGoSleepTimeoutS>
 80030a4:	e7f3      	b.n	800308e <thd4_execute.lto_priv.77+0x7e>
 80030a6:	46c0      	nop			; (mov r8, r8)
 80030a8:	000003eb 	.word	0x000003eb
 80030ac:	00002710 	.word	0x00002710
 80030b0:	00002713 	.word	0x00002713
	...

080030c0 <thd3_execute.lto_priv.76>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 80030c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80030c2:	4e49      	ldr	r6, [pc, #292]	; (80031e8 <thd3_execute.lto_priv.76+0x128>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80030c4:	69b3      	ldr	r3, [r6, #24]
 80030c6:	689c      	ldr	r4, [r3, #8]
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80030c8:	1c65      	adds	r5, r4, #1
 80030ca:	0028      	movs	r0, r5
 80030cc:	f7fd fbc8 	bl	8000860 <chThdSetPriority>
  test_assert(1, p1 == prio,
 80030d0:	1b01      	subs	r1, r0, r4
 80030d2:	424a      	negs	r2, r1
 80030d4:	414a      	adcs	r2, r1

static void thd3_execute(void) {
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
 80030d6:	0007      	movs	r7, r0
  test_assert(1, p1 == prio,
 80030d8:	b2d1      	uxtb	r1, r2
 80030da:	2001      	movs	r0, #1
 80030dc:	f7fd fa70 	bl	80005c0 <_test_assert>
 80030e0:	2800      	cmp	r0, #0
 80030e2:	d000      	beq.n	80030e6 <thd3_execute.lto_priv.76+0x26>
  chSysLock();
  chThdGetSelfX()->p_prio = prio;
  chThdGetSelfX()->p_realprio = prio;
  chSysUnlock();
#endif
}
 80030e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80030e6:	69b3      	ldr	r3, [r6, #24]

  prio = chThdGetPriorityX();
  p1 = chThdSetPriority(prio + 1);
  test_assert(1, p1 == prio,
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 80030e8:	3002      	adds	r0, #2
 80030ea:	6899      	ldr	r1, [r3, #8]
 80030ec:	1b49      	subs	r1, r1, r5
 80030ee:	424a      	negs	r2, r1
 80030f0:	414a      	adcs	r2, r1
 80030f2:	b2d1      	uxtb	r1, r2
 80030f4:	f7fd fa64 	bl	80005c0 <_test_assert>
 80030f8:	2800      	cmp	r0, #0
 80030fa:	d1f3      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 80030fc:	0038      	movs	r0, r7
 80030fe:	f7fd fbaf 	bl	8000860 <chThdSetPriority>
  test_assert(3, p1 == prio + 1,
 8003102:	1a29      	subs	r1, r5, r0
 8003104:	424b      	negs	r3, r1
 8003106:	414b      	adcs	r3, r1
 8003108:	2003      	movs	r0, #3
 800310a:	b2d9      	uxtb	r1, r3
 800310c:	f7fd fa58 	bl	80005c0 <_test_assert>
 8003110:	2800      	cmp	r0, #0
 8003112:	d1e7      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
 8003114:	69b3      	ldr	r3, [r6, #24]
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 8003116:	3004      	adds	r0, #4
 8003118:	6899      	ldr	r1, [r3, #8]
 800311a:	1b09      	subs	r1, r1, r4
 800311c:	424a      	negs	r2, r1
 800311e:	414a      	adcs	r2, r1
 8003120:	b2d1      	uxtb	r1, r2
 8003122:	f7fd fa4d 	bl	80005c0 <_test_assert>
 8003126:	2800      	cmp	r0, #0
 8003128:	d1dc      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800312a:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800312c:	69b2      	ldr	r2, [r6, #24]
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
  chThdGetSelfX()->p_prio += 2;
 800312e:	6893      	ldr	r3, [r2, #8]
 8003130:	3302      	adds	r3, #2
 8003132:	6093      	str	r3, [r2, #8]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003134:	b662      	cpsie	i
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003136:	69b3      	ldr	r3, [r6, #24]
  chSysUnlock();
  test_assert(5, chThdGetPriorityX() == prio + 2,
 8003138:	1ca7      	adds	r7, r4, #2
 800313a:	6899      	ldr	r1, [r3, #8]
 800313c:	3005      	adds	r0, #5
 800313e:	1bc9      	subs	r1, r1, r7
 8003140:	424a      	negs	r2, r1
 8003142:	414a      	adcs	r2, r1
 8003144:	b2d1      	uxtb	r1, r2
 8003146:	f7fd fa3b 	bl	80005c0 <_test_assert>
 800314a:	2800      	cmp	r0, #0
 800314c:	d1ca      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 800314e:	0028      	movs	r0, r5
 8003150:	f7fd fb86 	bl	8000860 <chThdSetPriority>
  test_assert(6, p1 == prio,
 8003154:	1b01      	subs	r1, r0, r4
 8003156:	424b      	negs	r3, r1
 8003158:	414b      	adcs	r3, r1
 800315a:	2006      	movs	r0, #6
 800315c:	b2d9      	uxtb	r1, r3
 800315e:	f7fd fa2f 	bl	80005c0 <_test_assert>
 8003162:	2800      	cmp	r0, #0
 8003164:	d1be      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 8003166:	69b3      	ldr	r3, [r6, #24]
 8003168:	3007      	adds	r0, #7
 800316a:	6899      	ldr	r1, [r3, #8]
 800316c:	1bc9      	subs	r1, r1, r7
 800316e:	424b      	negs	r3, r1
 8003170:	414b      	adcs	r3, r1
 8003172:	b2d9      	uxtb	r1, r3
 8003174:	f7fd fa24 	bl	80005c0 <_test_assert>
 8003178:	2800      	cmp	r0, #0
 800317a:	d1b3      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800317c:	69b3      	ldr	r3, [r6, #24]
 800317e:	3008      	adds	r0, #8
 8003180:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 8003182:	1b49      	subs	r1, r1, r5
 8003184:	424a      	negs	r2, r1
 8003186:	414a      	adcs	r2, r1
 8003188:	b2d1      	uxtb	r1, r2
 800318a:	f7fd fa19 	bl	80005c0 <_test_assert>
 800318e:	2800      	cmp	r0, #0
 8003190:	d1a8      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 8003192:	1ce7      	adds	r7, r4, #3
 8003194:	0038      	movs	r0, r7
 8003196:	f7fd fb63 	bl	8000860 <chThdSetPriority>
  test_assert(9, p1 == prio + 1,
 800319a:	1a29      	subs	r1, r5, r0
 800319c:	424b      	negs	r3, r1
 800319e:	414b      	adcs	r3, r1
 80031a0:	2009      	movs	r0, #9
 80031a2:	b2d9      	uxtb	r1, r3
 80031a4:	f7fd fa0c 	bl	80005c0 <_test_assert>
 80031a8:	2800      	cmp	r0, #0
 80031aa:	d19b      	bne.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 80031ac:	69b3      	ldr	r3, [r6, #24]
 80031ae:	300a      	adds	r0, #10
 80031b0:	6899      	ldr	r1, [r3, #8]
 80031b2:	1bc9      	subs	r1, r1, r7
 80031b4:	424a      	negs	r2, r1
 80031b6:	414a      	adcs	r2, r1
 80031b8:	b2d1      	uxtb	r1, r2
 80031ba:	f7fd fa01 	bl	80005c0 <_test_assert>
 80031be:	2800      	cmp	r0, #0
 80031c0:	d000      	beq.n	80031c4 <thd3_execute.lto_priv.76+0x104>
 80031c2:	e78f      	b.n	80030e4 <thd3_execute.lto_priv.76+0x24>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 80031c4:	69b3      	ldr	r3, [r6, #24]
 80031c6:	300b      	adds	r0, #11
 80031c8:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
 80031ca:	1bc9      	subs	r1, r1, r7
 80031cc:	424a      	negs	r2, r1
 80031ce:	414a      	adcs	r2, r1
 80031d0:	b2d1      	uxtb	r1, r2
 80031d2:	f7fd f9f5 	bl	80005c0 <_test_assert>
 80031d6:	2800      	cmp	r0, #0
 80031d8:	d000      	beq.n	80031dc <thd3_execute.lto_priv.76+0x11c>
 80031da:	e783      	b.n	80030e4 <thd3_execute.lto_priv.76+0x24>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80031dc:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80031de:	69b3      	ldr	r3, [r6, #24]
              "unexpected real priority level");

  chSysLock();
  chThdGetSelfX()->p_prio = prio;
 80031e0:	609c      	str	r4, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 80031e2:	63dc      	str	r4, [r3, #60]	; 0x3c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80031e4:	b662      	cpsie	i
 80031e6:	e77d      	b.n	80030e4 <thd3_execute.lto_priv.76+0x24>
 80031e8:	20000ac0 	.word	0x20000ac0
 80031ec:	00000000 	.word	0x00000000

080031f0 <print_line.lto_priv.124>:
    tcp->teardown();

  test_wait_threads();
}

static void print_line(void) {
 80031f0:	b570      	push	{r4, r5, r6, lr}
 80031f2:	244c      	movs	r4, #76	; 0x4c
 80031f4:	4d07      	ldr	r5, [pc, #28]	; (8003214 <print_line.lto_priv.124+0x24>)
  unsigned i;

  for (i = 0; i < 76; i++)
    chSequentialStreamPut(chp, '-');
 80031f6:	6828      	ldr	r0, [r5, #0]
 80031f8:	212d      	movs	r1, #45	; 0x2d
 80031fa:	6803      	ldr	r3, [r0, #0]
 80031fc:	3c01      	subs	r4, #1
 80031fe:	689b      	ldr	r3, [r3, #8]
 8003200:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8003202:	2c00      	cmp	r4, #0
 8003204:	d1f7      	bne.n	80031f6 <print_line.lto_priv.124+0x6>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 8003206:	6828      	ldr	r0, [r5, #0]
 8003208:	2202      	movs	r2, #2
 800320a:	6803      	ldr	r3, [r0, #0]
 800320c:	4902      	ldr	r1, [pc, #8]	; (8003218 <print_line.lto_priv.124+0x28>)
 800320e:	681b      	ldr	r3, [r3, #0]
 8003210:	4798      	blx	r3
}
 8003212:	bd70      	pop	{r4, r5, r6, pc}
 8003214:	200006bc 	.word	0x200006bc
 8003218:	080057d0 	.word	0x080057d0
 800321c:	00000000 	.word	0x00000000

08003220 <sys2_execute.lto_priv.72>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003220:	b672      	cpsid	i
 8003222:	b672      	cpsid	i
 8003224:	b672      	cpsid	i
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003226:	b662      	cpsie	i

  chSysSuspend();
  chSysDisable();
  chSysSuspend();
  chSysEnable();
}
 8003228:	4770      	bx	lr
 800322a:	46c0      	nop			; (mov r8, r8)
 800322c:	0000      	movs	r0, r0
	...

08003230 <notify.lto_priv.61>:

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
  (void)qp;
}
 8003230:	4770      	bx	lr
 8003232:	46c0      	nop			; (mov r8, r8)
	...

08003240 <queues2_setup.lto_priv.118>:
 8003240:	2204      	movs	r2, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003242:	4b07      	ldr	r3, [pc, #28]	; (8003260 <queues2_setup.lto_priv.118+0x20>)
 8003244:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 8003246:	4a07      	ldr	r2, [pc, #28]	; (8003264 <queues2_setup.lto_priv.118+0x24>)
 8003248:	601b      	str	r3, [r3, #0]
 800324a:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 800324c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 800324e:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 8003250:	3204      	adds	r2, #4
 8003252:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 8003254:	4a04      	ldr	r2, [pc, #16]	; (8003268 <queues2_setup.lto_priv.118+0x28>)
  tqp->p_prev = (thread_t *)tqp;
 8003256:	605b      	str	r3, [r3, #4]
 8003258:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 800325a:	2200      	movs	r2, #0
 800325c:	621a      	str	r2, [r3, #32]
 */

static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 800325e:	4770      	bx	lr
 8003260:	20000600 	.word	0x20000600
 8003264:	20000c58 	.word	0x20000c58
 8003268:	08003231 	.word	0x08003231
 800326c:	00000000 	.word	0x00000000

08003270 <queues1_setup.lto_priv.116>:
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8003270:	2100      	movs	r1, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003272:	4b07      	ldr	r3, [pc, #28]	; (8003290 <queues1_setup.lto_priv.116+0x20>)
  iqp->q_buffer  = bp;
 8003274:	4a07      	ldr	r2, [pc, #28]	; (8003294 <queues1_setup.lto_priv.116+0x24>)
 8003276:	601b      	str	r3, [r3, #0]
 8003278:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 800327a:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 800327c:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 800327e:	3204      	adds	r2, #4
 8003280:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 8003282:	4a05      	ldr	r2, [pc, #20]	; (8003298 <queues1_setup.lto_priv.116+0x28>)
  tqp->p_prev = (thread_t *)tqp;
 8003284:	605b      	str	r3, [r3, #4]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8003286:	6099      	str	r1, [r3, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8003288:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 800328a:	6219      	str	r1, [r3, #32]
 */

static void queues1_setup(void) {

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}
 800328c:	4770      	bx	lr
 800328e:	46c0      	nop			; (mov r8, r8)
 8003290:	20000624 	.word	0x20000624
 8003294:	20000c58 	.word	0x20000c58
 8003298:	08003231 	.word	0x08003231
 800329c:	00000000 	.word	0x00000000

080032a0 <dyn2_setup.lto_priv.112>:
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 80032a0:	21a4      	movs	r1, #164	; 0xa4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80032a2:	2200      	movs	r2, #0
 80032a4:	4b02      	ldr	r3, [pc, #8]	; (80032b0 <dyn2_setup.lto_priv.112+0x10>)
  mp->mp_object_size = size;
 80032a6:	0049      	lsls	r1, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80032a8:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 80032aa:	6059      	str	r1, [r3, #4]
  mp->mp_provider = provider;
 80032ac:	609a      	str	r2, [r3, #8]
 */

static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 80032ae:	4770      	bx	lr
 80032b0:	20000c14 	.word	0x20000c14
	...

080032c0 <bmk4_execute.lto_priv.123>:
 80032c0:	4b20      	ldr	r3, [pc, #128]	; (8003344 <bmk4_execute.lto_priv.123+0x84>)

static void bmk4_execute(void) {
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80032c2:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80032c4:	699b      	ldr	r3, [r3, #24]
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 80032c6:	b570      	push	{r4, r5, r6, lr}
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80032c8:	689a      	ldr	r2, [r3, #8]
 80032ca:	2300      	movs	r3, #0
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
  chSysUnlock();
}

static void bmk4_execute(void) {
 80032cc:	b082      	sub	sp, #8
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80032ce:	3201      	adds	r2, #1
 80032d0:	0049      	lsls	r1, r1, #1
 80032d2:	9300      	str	r3, [sp, #0]
 80032d4:	481c      	ldr	r0, [pc, #112]	; (8003348 <bmk4_execute.lto_priv.123+0x88>)
 80032d6:	4b1d      	ldr	r3, [pc, #116]	; (800334c <bmk4_execute.lto_priv.123+0x8c>)
 80032d8:	f7fd fb1a 	bl	8000910 <chThdCreateStatic>
                                      thread4, NULL);
  n = 0;
 80032dc:	2500      	movs	r5, #0

static void bmk4_execute(void) {
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80032de:	4b1c      	ldr	r3, [pc, #112]	; (8003350 <bmk4_execute.lto_priv.123+0x90>)
 80032e0:	0004      	movs	r4, r0
 80032e2:	6018      	str	r0, [r3, #0]
                                      thread4, NULL);
  n = 0;
  test_wait_tick();
 80032e4:	f7fe f91c 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 80032e8:	f002 fa42 	bl	8005770 <test_start_timer.constprop.1>
 80032ec:	4e19      	ldr	r6, [pc, #100]	; (8003354 <bmk4_execute.lto_priv.123+0x94>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80032ee:	b672      	cpsid	i
  do {
    chSysLock();
    chSchWakeupS(tp, MSG_OK);
 80032f0:	2100      	movs	r1, #0
 80032f2:	0020      	movs	r0, r4
 80032f4:	f7fd facc 	bl	8000890 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 80032f8:	0020      	movs	r0, r4
 80032fa:	2100      	movs	r1, #0
 80032fc:	f7fd fac8 	bl	8000890 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8003300:	0020      	movs	r0, r4
 8003302:	2100      	movs	r1, #0
 8003304:	f7fd fac4 	bl	8000890 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8003308:	2100      	movs	r1, #0
 800330a:	0020      	movs	r0, r4
 800330c:	f7fd fac0 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003310:	b662      	cpsie	i
    chSysUnlock();
    n += 4;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003312:	7833      	ldrb	r3, [r6, #0]
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSchWakeupS(tp, MSG_OK);
    chSysUnlock();
    n += 4;
 8003314:	3504      	adds	r5, #4
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8003316:	2b00      	cmp	r3, #0
 8003318:	d0e9      	beq.n	80032ee <bmk4_execute.lto_priv.123+0x2e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800331a:	b672      	cpsid	i
  chSysLock();
  chSchWakeupS(tp, MSG_TIMEOUT);
 800331c:	2101      	movs	r1, #1
 800331e:	0020      	movs	r0, r4
 8003320:	4249      	negs	r1, r1
 8003322:	f7fd fab5 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003326:	b662      	cpsie	i
  chSysUnlock();

  test_wait_threads();
 8003328:	f7fd fe6a 	bl	8001000 <test_wait_threads>
  test_print("--- Score : ");
 800332c:	480a      	ldr	r0, [pc, #40]	; (8003358 <bmk4_execute.lto_priv.123+0x98>)
 800332e:	f7fd f98f 	bl	8000650 <test_print>
  test_printn(n * 2);
 8003332:	0068      	lsls	r0, r5, #1
 8003334:	f7fd f9a4 	bl	8000680 <test_printn>
  test_println(" ctxswc/S");
 8003338:	4808      	ldr	r0, [pc, #32]	; (800335c <bmk4_execute.lto_priv.123+0x9c>)
 800333a:	f7fd f969 	bl	8000610 <test_println>
}
 800333e:	b002      	add	sp, #8
 8003340:	bd70      	pop	{r4, r5, r6, pc}
 8003342:	46c0      	nop			; (mov r8, r8)
 8003344:	20000ac0 	.word	0x20000ac0
 8003348:	20000c58 	.word	0x20000c58
 800334c:	08003361 	.word	0x08003361
 8003350:	20000a28 	.word	0x20000a28
 8003354:	20000c10 	.word	0x20000c10
 8003358:	08005d60 	.word	0x08005d60
 800335c:	08005db4 	.word	0x08005db4

08003360 <thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003360:	4b05      	ldr	r3, [pc, #20]	; (8003378 <thread4+0x18>)
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8003362:	b510      	push	{r4, lr}
 8003364:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003366:	b672      	cpsid	i
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8003368:	2003      	movs	r0, #3
 800336a:	f7fd fb01 	bl	8000970 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
  } while (msg == MSG_OK);
 800336e:	6a23      	ldr	r3, [r4, #32]
 8003370:	2b00      	cmp	r3, #0
 8003372:	d0f9      	beq.n	8003368 <thread4+0x8>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003374:	b662      	cpsie	i
  chSysUnlock();
}
 8003376:	bd10      	pop	{r4, pc}
 8003378:	20000ac0 	.word	0x20000ac0
 800337c:	00000000 	.word	0x00000000

08003380 <thread2.lto_priv.126>:

  chThdExit((msg_t)p);
}

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8003380:	b510      	push	{r4, lr}
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8003382:	f7fd fb05 	bl	8000990 <chMsgWait>
 8003386:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003388:	b672      	cpsid	i
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 800338a:	0021      	movs	r1, r4
 800338c:	f7fd fa80 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003390:	b662      	cpsie	i
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 8003392:	2c00      	cmp	r4, #0
 8003394:	d1f5      	bne.n	8003382 <thread2.lto_priv.126+0x2>
}
 8003396:	bd10      	pop	{r4, pc}
	...

080033a0 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80033a0:	b570      	push	{r4, r5, r6, lr}

  uint32_t n = 0;
 80033a2:	2400      	movs	r4, #0
}

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80033a4:	0005      	movs	r5, r0

  uint32_t n = 0;
  test_wait_tick();
 80033a6:	f7fe f8bb 	bl	8001520 <test_wait_tick>
  test_start_timer(1000);
 80033aa:	f002 f9e1 	bl	8005770 <test_start_timer.constprop.1>
 80033ae:	4e07      	ldr	r6, [pc, #28]	; (80033cc <msg_loop_test+0x2c>)
  do {
    (void)chMsgSend(tp, 1);
 80033b0:	2101      	movs	r1, #1
 80033b2:	0028      	movs	r0, r5
 80033b4:	f7fd fb94 	bl	8000ae0 <chMsgSend>
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80033b8:	7833      	ldrb	r3, [r6, #0]
  uint32_t n = 0;
  test_wait_tick();
  test_start_timer(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 80033ba:	3401      	adds	r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80033bc:	2b00      	cmp	r3, #0
 80033be:	d0f7      	beq.n	80033b0 <msg_loop_test+0x10>
  (void)chMsgSend(tp, 0);
 80033c0:	0028      	movs	r0, r5
 80033c2:	2100      	movs	r1, #0
 80033c4:	f7fd fb8c 	bl	8000ae0 <chMsgSend>
  return n;
}
 80033c8:	0020      	movs	r0, r4
 80033ca:	bd70      	pop	{r4, r5, r6, pc}
 80033cc:	20000c10 	.word	0x20000c10

080033d0 <bmk3_execute.lto_priv.122>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 80033d0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80033d2:	464f      	mov	r7, r9
 80033d4:	4646      	mov	r6, r8
 80033d6:	b4c0      	push	{r6, r7}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80033d8:	26a4      	movs	r6, #164	; 0xa4
 80033da:	2700      	movs	r7, #0
 80033dc:	4b2e      	ldr	r3, [pc, #184]	; (8003498 <bmk3_execute.lto_priv.122+0xc8>)
 80033de:	4c2f      	ldr	r4, [pc, #188]	; (800349c <bmk3_execute.lto_priv.122+0xcc>)
 80033e0:	4698      	mov	r8, r3
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80033e2:	699b      	ldr	r3, [r3, #24]
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 80033e4:	b083      	sub	sp, #12
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80033e6:	689a      	ldr	r2, [r3, #8]
 80033e8:	0076      	lsls	r6, r6, #1
 80033ea:	0031      	movs	r1, r6
 80033ec:	3201      	adds	r2, #1
 80033ee:	9700      	str	r7, [sp, #0]
 80033f0:	4b2b      	ldr	r3, [pc, #172]	; (80034a0 <bmk3_execute.lto_priv.122+0xd0>)
 80033f2:	0020      	movs	r0, r4
 80033f4:	f7fd fa8c 	bl	8000910 <chThdCreateStatic>
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 80033f8:	4b2a      	ldr	r3, [pc, #168]	; (80034a4 <bmk3_execute.lto_priv.122+0xd4>)
 */

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80033fa:	4d2b      	ldr	r5, [pc, #172]	; (80034a8 <bmk3_execute.lto_priv.122+0xd8>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 80033fc:	4699      	mov	r9, r3
 80033fe:	4643      	mov	r3, r8
 8003400:	699b      	ldr	r3, [r3, #24]
 */

static void bmk3_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8003402:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8003404:	689a      	ldr	r2, [r3, #8]
 8003406:	19a0      	adds	r0, r4, r6
 8003408:	464b      	mov	r3, r9
 800340a:	0031      	movs	r1, r6
 800340c:	3a02      	subs	r2, #2
 800340e:	9700      	str	r7, [sp, #0]
 8003410:	f7fd fa7e 	bl	8000910 <chThdCreateStatic>
 8003414:	4643      	mov	r3, r8
 8003416:	699b      	ldr	r3, [r3, #24]
 8003418:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 800341a:	689a      	ldr	r2, [r3, #8]
 800341c:	23a4      	movs	r3, #164	; 0xa4
 800341e:	009b      	lsls	r3, r3, #2
 8003420:	18e0      	adds	r0, r4, r3
 8003422:	0031      	movs	r1, r6
 8003424:	464b      	mov	r3, r9
 8003426:	3a03      	subs	r2, #3
 8003428:	9700      	str	r7, [sp, #0]
 800342a:	f7fd fa71 	bl	8000910 <chThdCreateStatic>
 800342e:	4643      	mov	r3, r8
 8003430:	699b      	ldr	r3, [r3, #24]
 8003432:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8003434:	689a      	ldr	r2, [r3, #8]
 8003436:	23f6      	movs	r3, #246	; 0xf6
 8003438:	009b      	lsls	r3, r3, #2
 800343a:	18e0      	adds	r0, r4, r3
 800343c:	0031      	movs	r1, r6
 800343e:	464b      	mov	r3, r9
 8003440:	3a04      	subs	r2, #4
 8003442:	9700      	str	r7, [sp, #0]
 8003444:	f7fd fa64 	bl	8000910 <chThdCreateStatic>
 8003448:	4643      	mov	r3, r8
 800344a:	699b      	ldr	r3, [r3, #24]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 800344c:	0031      	movs	r1, r6
 800344e:	689a      	ldr	r2, [r3, #8]
 8003450:	23a4      	movs	r3, #164	; 0xa4
 8003452:	00db      	lsls	r3, r3, #3
 8003454:	3a05      	subs	r2, #5
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8003456:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8003458:	18e0      	adds	r0, r4, r3
 800345a:	9700      	str	r7, [sp, #0]
 800345c:	464b      	mov	r3, r9
 800345e:	f7fd fa57 	bl	8000910 <chThdCreateStatic>
 8003462:	6128      	str	r0, [r5, #16]
  n = msg_loop_test(threads[0]);
 8003464:	6828      	ldr	r0, [r5, #0]
 8003466:	f7ff ff9b 	bl	80033a0 <msg_loop_test>
 800346a:	0004      	movs	r4, r0
  test_wait_threads();
 800346c:	f7fd fdc8 	bl	8001000 <test_wait_threads>
  test_print("--- Score : ");
 8003470:	480e      	ldr	r0, [pc, #56]	; (80034ac <bmk3_execute.lto_priv.122+0xdc>)
 8003472:	f7fd f8ed 	bl	8000650 <test_print>
  test_printn(n);
 8003476:	0020      	movs	r0, r4
 8003478:	f7fd f902 	bl	8000680 <test_printn>
  test_print(" msgs/S, ");
 800347c:	480c      	ldr	r0, [pc, #48]	; (80034b0 <bmk3_execute.lto_priv.122+0xe0>)
 800347e:	f7fd f8e7 	bl	8000650 <test_print>
  test_printn(n << 1);
 8003482:	0060      	lsls	r0, r4, #1
 8003484:	f7fd f8fc 	bl	8000680 <test_printn>
  test_println(" ctxswc/S");
 8003488:	480a      	ldr	r0, [pc, #40]	; (80034b4 <bmk3_execute.lto_priv.122+0xe4>)
 800348a:	f7fd f8c1 	bl	8000610 <test_println>
}
 800348e:	b003      	add	sp, #12
 8003490:	bc0c      	pop	{r2, r3}
 8003492:	4690      	mov	r8, r2
 8003494:	4699      	mov	r9, r3
 8003496:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003498:	20000ac0 	.word	0x20000ac0
 800349c:	20000c58 	.word	0x20000c58
 80034a0:	08003381 	.word	0x08003381
 80034a4:	08003db1 	.word	0x08003db1
 80034a8:	20000a28 	.word	0x20000a28
 80034ac:	08005d60 	.word	0x08005d60
 80034b0:	080064f0 	.word	0x080064f0
 80034b4:	08005db4 	.word	0x08005db4
	...

080034c0 <bmk2_execute.lto_priv.121>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80034c0:	4b12      	ldr	r3, [pc, #72]	; (800350c <bmk2_execute.lto_priv.121+0x4c>)
 */

static void bmk2_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80034c2:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80034c4:	699b      	ldr	r3, [r3, #24]
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 80034c6:	b510      	push	{r4, lr}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80034c8:	689a      	ldr	r2, [r3, #8]
 80034ca:	2300      	movs	r3, #0
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 80034cc:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80034ce:	3201      	adds	r2, #1
 80034d0:	0049      	lsls	r1, r1, #1
 80034d2:	9300      	str	r3, [sp, #0]
 80034d4:	480e      	ldr	r0, [pc, #56]	; (8003510 <bmk2_execute.lto_priv.121+0x50>)
 80034d6:	4b0f      	ldr	r3, [pc, #60]	; (8003514 <bmk2_execute.lto_priv.121+0x54>)
 80034d8:	f7fd fa1a 	bl	8000910 <chThdCreateStatic>
 80034dc:	4b0e      	ldr	r3, [pc, #56]	; (8003518 <bmk2_execute.lto_priv.121+0x58>)
 80034de:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 80034e0:	f7ff ff5e 	bl	80033a0 <msg_loop_test>
 80034e4:	0004      	movs	r4, r0
  test_wait_threads();
 80034e6:	f7fd fd8b 	bl	8001000 <test_wait_threads>
  test_print("--- Score : ");
 80034ea:	480c      	ldr	r0, [pc, #48]	; (800351c <bmk2_execute.lto_priv.121+0x5c>)
 80034ec:	f7fd f8b0 	bl	8000650 <test_print>
  test_printn(n);
 80034f0:	0020      	movs	r0, r4
 80034f2:	f7fd f8c5 	bl	8000680 <test_printn>
  test_print(" msgs/S, ");
 80034f6:	480a      	ldr	r0, [pc, #40]	; (8003520 <bmk2_execute.lto_priv.121+0x60>)
 80034f8:	f7fd f8aa 	bl	8000650 <test_print>
  test_printn(n << 1);
 80034fc:	0060      	lsls	r0, r4, #1
 80034fe:	f7fd f8bf 	bl	8000680 <test_printn>
  test_println(" ctxswc/S");
 8003502:	4808      	ldr	r0, [pc, #32]	; (8003524 <bmk2_execute.lto_priv.121+0x64>)
 8003504:	f7fd f884 	bl	8000610 <test_println>
}
 8003508:	b002      	add	sp, #8
 800350a:	bd10      	pop	{r4, pc}
 800350c:	20000ac0 	.word	0x20000ac0
 8003510:	20000c58 	.word	0x20000c58
 8003514:	08003381 	.word	0x08003381
 8003518:	20000a28 	.word	0x20000a28
 800351c:	08005d60 	.word	0x08005d60
 8003520:	080064f0 	.word	0x080064f0
 8003524:	08005db4 	.word	0x08005db4
	...

08003530 <bmk1_execute.lto_priv.120>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003530:	4b12      	ldr	r3, [pc, #72]	; (800357c <bmk1_execute.lto_priv.120+0x4c>)
 */

static void bmk1_execute(void) {
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8003532:	21a4      	movs	r1, #164	; 0xa4
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003534:	699b      	ldr	r3, [r3, #24]
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8003536:	b510      	push	{r4, lr}
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8003538:	689a      	ldr	r2, [r3, #8]
 800353a:	2300      	movs	r3, #0
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 800353c:	b082      	sub	sp, #8
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 800353e:	3a01      	subs	r2, #1
 8003540:	0049      	lsls	r1, r1, #1
 8003542:	9300      	str	r3, [sp, #0]
 8003544:	480e      	ldr	r0, [pc, #56]	; (8003580 <bmk1_execute.lto_priv.120+0x50>)
 8003546:	4b0f      	ldr	r3, [pc, #60]	; (8003584 <bmk1_execute.lto_priv.120+0x54>)
 8003548:	f7fd f9e2 	bl	8000910 <chThdCreateStatic>
 800354c:	4b0e      	ldr	r3, [pc, #56]	; (8003588 <bmk1_execute.lto_priv.120+0x58>)
 800354e:	6018      	str	r0, [r3, #0]
  n = msg_loop_test(threads[0]);
 8003550:	f7ff ff26 	bl	80033a0 <msg_loop_test>
 8003554:	0004      	movs	r4, r0
  test_wait_threads();
 8003556:	f7fd fd53 	bl	8001000 <test_wait_threads>
  test_print("--- Score : ");
 800355a:	480c      	ldr	r0, [pc, #48]	; (800358c <bmk1_execute.lto_priv.120+0x5c>)
 800355c:	f7fd f878 	bl	8000650 <test_print>
  test_printn(n);
 8003560:	0020      	movs	r0, r4
 8003562:	f7fd f88d 	bl	8000680 <test_printn>
  test_print(" msgs/S, ");
 8003566:	480a      	ldr	r0, [pc, #40]	; (8003590 <bmk1_execute.lto_priv.120+0x60>)
 8003568:	f7fd f872 	bl	8000650 <test_print>
  test_printn(n << 1);
 800356c:	0060      	lsls	r0, r4, #1
 800356e:	f7fd f887 	bl	8000680 <test_printn>
  test_println(" ctxswc/S");
 8003572:	4808      	ldr	r0, [pc, #32]	; (8003594 <bmk1_execute.lto_priv.120+0x64>)
 8003574:	f7fd f84c 	bl	8000610 <test_println>
}
 8003578:	b002      	add	sp, #8
 800357a:	bd10      	pop	{r4, pc}
 800357c:	20000ac0 	.word	0x20000ac0
 8003580:	20000c58 	.word	0x20000c58
 8003584:	08003381 	.word	0x08003381
 8003588:	20000a28 	.word	0x20000a28
 800358c:	08005d60 	.word	0x08005d60
 8003590:	080064f0 	.word	0x080064f0
 8003594:	08005db4 	.word	0x08005db4
	...

080035a0 <sys3_execute.lto_priv.73>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 80035a0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80035a2:	b672      	cpsid	i
  bool result;

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80035a4:	2001      	movs	r0, #1
 80035a6:	f7fd ffe3 	bl	8001570 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80035aa:	b662      	cpsie	i
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");
 80035ac:	2401      	movs	r4, #1
 80035ae:	4060      	eors	r0, r4
 80035b0:	b2c1      	uxtb	r1, r0
 80035b2:	2001      	movs	r0, #1
 80035b4:	f7fd f804 	bl	80005c0 <_test_assert>
 80035b8:	2800      	cmp	r0, #0
 80035ba:	d000      	beq.n	80035be <sys3_execute.lto_priv.73+0x1e>

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
}
 80035bc:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80035be:	b672      	cpsid	i
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
  chSysUnlock();
  test_assert(1, result == false, "ready list check failed");

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 80035c0:	3002      	adds	r0, #2
 80035c2:	f7fd ffd5 	bl	8001570 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80035c6:	b662      	cpsie	i
  chSysUnlock();
  test_assert(2, result == false, "virtual timers list check failed");
 80035c8:	4060      	eors	r0, r4
 80035ca:	b2c1      	uxtb	r1, r0
 80035cc:	2002      	movs	r0, #2
 80035ce:	f7fc fff7 	bl	80005c0 <_test_assert>
 80035d2:	2800      	cmp	r0, #0
 80035d4:	d1f2      	bne.n	80035bc <sys3_execute.lto_priv.73+0x1c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80035d6:	b672      	cpsid	i

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80035d8:	3004      	adds	r0, #4
 80035da:	f7fd ffc9 	bl	8001570 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80035de:	b662      	cpsie	i
  chSysUnlock();
  test_assert(3, result == false, "registry list check failed");
 80035e0:	4060      	eors	r0, r4
 80035e2:	b2c1      	uxtb	r1, r0
 80035e4:	2003      	movs	r0, #3
 80035e6:	f7fc ffeb 	bl	80005c0 <_test_assert>
 80035ea:	2800      	cmp	r0, #0
 80035ec:	d1e6      	bne.n	80035bc <sys3_execute.lto_priv.73+0x1c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80035ee:	b672      	cpsid	i

  chSysLock();
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80035f0:	3008      	adds	r0, #8
 80035f2:	f7fd ffbd 	bl	8001570 <chSysIntegrityCheckI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80035f6:	b662      	cpsie	i
  chSysUnlock();
  test_assert(4, result == false, "port layer check failed");
 80035f8:	4044      	eors	r4, r0
 80035fa:	b2e1      	uxtb	r1, r4
 80035fc:	2004      	movs	r0, #4
 80035fe:	f7fc ffdf 	bl	80005c0 <_test_assert>
 8003602:	e7db      	b.n	80035bc <sys3_execute.lto_priv.73+0x1c>
	...

08003610 <sys1_execute.lto_priv.71>:
  sts = chSysGetStatusAndLockX();
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}

static void sys1_execute(void) {
 8003610:	b510      	push	{r4, lr}
 8003612:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 8003614:	f7fd ffa4 	bl	8001560 <chSysGetStatusAndLockX>
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {

  if (port_irq_enabled(sts)) {
 8003618:	07c3      	lsls	r3, r0, #31
 800361a:	d401      	bmi.n	8003620 <sys1_execute.lto_priv.71+0x10>
 800361c:	f7fd ff90 	bl	8001540 <chSysRestoreStatusX.part.3.lto_priv.129>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003620:	b672      	cpsid	i
  chSysRestoreStatusX(sts);

  /* Reentrant case.*/
  chSysLock();
  sts = chSysGetStatusAndLockX();
 8003622:	f7fd ff9d 	bl	8001560 <chSysGetStatusAndLockX>
 8003626:	07c3      	lsls	r3, r0, #31
 8003628:	d401      	bmi.n	800362e <sys1_execute.lto_priv.71+0x1e>
 800362a:	f7fd ff89 	bl	8001540 <chSysRestoreStatusX.part.3.lto_priv.129>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800362e:	b662      	cpsie	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003630:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8003634:	07db      	lsls	r3, r3, #31
 8003636:	d400      	bmi.n	800363a <sys1_execute.lto_priv.71+0x2a>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003638:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 800363a:	f3ef 8310 	mrs	r3, PRIMASK
 800363e:	07db      	lsls	r3, r3, #31
 8003640:	d400      	bmi.n	8003644 <sys1_execute.lto_priv.71+0x34>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003642:	b672      	cpsid	i
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003644:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003646:	b672      	cpsid	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003648:	f3ef 8310 	mrs	r3, PRIMASK
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 800364c:	07db      	lsls	r3, r3, #31
 800364e:	d500      	bpl.n	8003652 <sys1_execute.lto_priv.71+0x42>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003650:	b662      	cpsie	i
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) );
 8003652:	f3ef 8310 	mrs	r3, PRIMASK
 8003656:	07db      	lsls	r3, r3, #31
 8003658:	d500      	bpl.n	800365c <sys1_execute.lto_priv.71+0x4c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800365a:	b662      	cpsie	i
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->vt_func = NULL;
 800365c:	2300      	movs	r3, #0
 800365e:	9304      	str	r3, [sp, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003660:	b672      	cpsid	i
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003662:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8003664:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003666:	2b00      	cmp	r3, #0
 8003668:	d002      	beq.n	8003670 <sys1_execute.lto_priv.71+0x60>
    chVTDoResetI(vtp);
 800366a:	0020      	movs	r0, r4
 800366c:	f7fd fd78 	bl	8001160 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8003670:	2300      	movs	r3, #0
 8003672:	4a0a      	ldr	r2, [pc, #40]	; (800369c <sys1_execute.lto_priv.71+0x8c>)
 8003674:	2101      	movs	r1, #1
 8003676:	0020      	movs	r0, r4
 8003678:	f7fd fdb2 	bl	80011e0 <chVTDoSetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800367c:	b662      	cpsie	i
  chSysUnconditionalUnlock();

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
  chVTSet(&vt, 1, vtcb, NULL);
  chThdSleep(10);
 800367e:	200a      	movs	r0, #10
 8003680:	f7fd ff46 	bl	8001510 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003684:	b672      	cpsid	i
 8003686:	9904      	ldr	r1, [sp, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003688:	b662      	cpsie	i

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 800368a:	424b      	negs	r3, r1
 800368c:	4159      	adcs	r1, r3
 800368e:	2001      	movs	r0, #1
 8003690:	b2c9      	uxtb	r1, r1
 8003692:	f7fc ff95 	bl	80005c0 <_test_assert>
}
 8003696:	b006      	add	sp, #24
 8003698:	bd10      	pop	{r4, pc}
 800369a:	46c0      	nop			; (mov r8, r8)
 800369c:	080036a1 	.word	0x080036a1

080036a0 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 80036a0:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80036a2:	b672      	cpsid	i
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80036a4:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80036a6:	b672      	cpsid	i
  chSysLockFromISR();
  chSysUnlockFromISR();

  /* Reentrant case.*/
  chSysLockFromISR();
  sts = chSysGetStatusAndLockX();
 80036a8:	f7fd ff5a 	bl	8001560 <chSysGetStatusAndLockX>
 80036ac:	07c3      	lsls	r3, r0, #31
 80036ae:	d401      	bmi.n	80036b4 <vtcb+0x14>
 80036b0:	f7fd ff46 	bl	8001540 <chSysRestoreStatusX.part.3.lto_priv.129>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80036b4:	b662      	cpsie	i
  chSysRestoreStatusX(sts);
  chSysUnlockFromISR();
}
 80036b6:	bd10      	pop	{r4, pc}
	...

080036c0 <thread2.lto_priv.125>:
}

static THD_FUNCTION(thread2, p) {

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 80036c0:	22fa      	movs	r2, #250	; 0xfa
static void queues2_setup(void) {

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static THD_FUNCTION(thread2, p) {
 80036c2:	b510      	push	{r4, lr}

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 80036c4:	00d2      	lsls	r2, r2, #3
 80036c6:	2100      	movs	r1, #0
 80036c8:	4801      	ldr	r0, [pc, #4]	; (80036d0 <thread2.lto_priv.125+0x10>)
 80036ca:	f7fd fe71 	bl	80013b0 <chOQPutTimeout>
}
 80036ce:	bd10      	pop	{r4, pc}
 80036d0:	20000600 	.word	0x20000600
	...

080036e0 <queues2_execute.lto_priv.119>:

static void queues2_execute(void) {
 80036e0:	b570      	push	{r4, r5, r6, lr}
 80036e2:	b082      	sub	sp, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80036e4:	b672      	cpsid	i
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80036e6:	4d7b      	ldr	r5, [pc, #492]	; (80038d4 <queues2_execute.lto_priv.119+0x1f4>)
 80036e8:	2100      	movs	r1, #0
 80036ea:	696b      	ldr	r3, [r5, #20]
 80036ec:	69aa      	ldr	r2, [r5, #24]
 80036ee:	4293      	cmp	r3, r2
 80036f0:	d100      	bne.n	80036f4 <queues2_execute.lto_priv.119+0x14>
 80036f2:	e0e5      	b.n	80038c0 <queues2_execute.lto_priv.119+0x1e0>
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 80036f4:	2001      	movs	r0, #1
 80036f6:	f7fc ff63 	bl	80005c0 <_test_assert>
 80036fa:	2800      	cmp	r0, #0
 80036fc:	d12e      	bne.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80036fe:	b662      	cpsie	i
 8003700:	2441      	movs	r4, #65	; 0x41
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 8003702:	2201      	movs	r2, #1
 8003704:	0021      	movs	r1, r4
 8003706:	3401      	adds	r4, #1
 8003708:	4252      	negs	r2, r2
 800370a:	0028      	movs	r0, r5
 800370c:	b2e4      	uxtb	r4, r4
 800370e:	f7fd fe4f 	bl	80013b0 <chOQPutTimeout>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8003712:	2c45      	cmp	r4, #69	; 0x45
 8003714:	d1f5      	bne.n	8003702 <queues2_execute.lto_priv.119+0x22>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003716:	b672      	cpsid	i
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003718:	68ab      	ldr	r3, [r5, #8]
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 800371a:	2002      	movs	r0, #2
 800371c:	4259      	negs	r1, r3
 800371e:	4159      	adcs	r1, r3
 8003720:	b2c9      	uxtb	r1, r1
 8003722:	f7fc ff4d 	bl	80005c0 <_test_assert>
 8003726:	1e06      	subs	r6, r0, #0
 8003728:	d118      	bne.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800372a:	b662      	cpsie	i
 800372c:	2404      	movs	r4, #4
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800372e:	b672      	cpsid	i
  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
    char c;

    chSysLock();
    c = chOQGetI(&oq);
 8003730:	0028      	movs	r0, r5
 8003732:	f7fd f9ad 	bl	8000a90 <chOQGetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003736:	b662      	cpsie	i
    chSysUnlock();
    test_emit_token(c);
 8003738:	b2c0      	uxtb	r0, r0
 800373a:	3c01      	subs	r4, #1
 800373c:	f7fc ff58 	bl	80005f0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 8003740:	2c00      	cmp	r4, #0
 8003742:	d1f4      	bne.n	800372e <queues2_execute.lto_priv.119+0x4e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003744:	b672      	cpsid	i
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003746:	696b      	ldr	r3, [r5, #20]
 8003748:	69aa      	ldr	r2, [r5, #24]
 800374a:	4293      	cmp	r3, r2
 800374c:	d100      	bne.n	8003750 <queues2_execute.lto_priv.119+0x70>
 800374e:	e0bc      	b.n	80038ca <queues2_execute.lto_priv.119+0x1ea>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 8003750:	0031      	movs	r1, r6
 8003752:	2003      	movs	r0, #3
 8003754:	f7fc ff34 	bl	80005c0 <_test_assert>
 8003758:	2800      	cmp	r0, #0
 800375a:	d002      	beq.n	8003762 <queues2_execute.lto_priv.119+0x82>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800375c:	b662      	cpsie	i
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
  test_assert_lock(12, chOQIsFullI(&oq), "not full");

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
}
 800375e:	b002      	add	sp, #8
 8003760:	bd70      	pop	{r4, r5, r6, pc}
 8003762:	b662      	cpsie	i
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
  test_assert_sequence(4, "ABCD");
 8003764:	495c      	ldr	r1, [pc, #368]	; (80038d8 <queues2_execute.lto_priv.119+0x1f8>)
 8003766:	2004      	movs	r0, #4
 8003768:	f7fc fefa 	bl	8000560 <_test_assert_sequence>
 800376c:	2800      	cmp	r0, #0
 800376e:	d1f6      	bne.n	800375e <queues2_execute.lto_priv.119+0x7e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003770:	b672      	cpsid	i
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 8003772:	0028      	movs	r0, r5
 8003774:	f7fd f98c 	bl	8000a90 <chOQGetI>
 8003778:	3003      	adds	r0, #3
 800377a:	4241      	negs	r1, r0
 800377c:	4141      	adcs	r1, r0
 800377e:	2005      	movs	r0, #5
 8003780:	b2c9      	uxtb	r1, r1
 8003782:	f7fc ff1d 	bl	80005c0 <_test_assert>
 8003786:	2800      	cmp	r0, #0
 8003788:	d1e8      	bne.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800378a:	b662      	cpsie	i

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800378c:	4c53      	ldr	r4, [pc, #332]	; (80038dc <queues2_execute.lto_priv.119+0x1fc>)
 800378e:	2300      	movs	r3, #0
 8003790:	0021      	movs	r1, r4
 8003792:	2208      	movs	r2, #8
 8003794:	0028      	movs	r0, r5
 8003796:	f7fd fdbb 	bl	8001310 <chOQWriteTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800379a:	1f01      	subs	r1, r0, #4
 800379c:	424b      	negs	r3, r1
 800379e:	414b      	adcs	r3, r1
 80037a0:	2006      	movs	r0, #6
 80037a2:	b2d9      	uxtb	r1, r3
 80037a4:	f7fc ff0c 	bl	80005c0 <_test_assert>
 80037a8:	2800      	cmp	r0, #0
 80037aa:	d1d8      	bne.n	800375e <queues2_execute.lto_priv.119+0x7e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80037ac:	b672      	cpsid	i
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 80037ae:	68ab      	ldr	r3, [r5, #8]
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 80037b0:	3007      	adds	r0, #7
 80037b2:	4259      	negs	r1, r3
 80037b4:	4159      	adcs	r1, r3
 80037b6:	b2c9      	uxtb	r1, r1
 80037b8:	f7fc ff02 	bl	80005c0 <_test_assert>
 80037bc:	2800      	cmp	r0, #0
 80037be:	d1cd      	bne.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80037c0:	b662      	cpsie	i
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 80037c2:	0026      	movs	r6, r4
 80037c4:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80037c6:	4b46      	ldr	r3, [pc, #280]	; (80038e0 <queues2_execute.lto_priv.119+0x200>)
 80037c8:	3e49      	subs	r6, #73	; 0x49
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80037ca:	699b      	ldr	r3, [r3, #24]
 80037cc:	3eff      	subs	r6, #255	; 0xff
 80037ce:	689a      	ldr	r2, [r3, #8]
 80037d0:	0049      	lsls	r1, r1, #1
 80037d2:	9000      	str	r0, [sp, #0]
 80037d4:	3201      	adds	r2, #1
 80037d6:	4b43      	ldr	r3, [pc, #268]	; (80038e4 <queues2_execute.lto_priv.119+0x204>)
 80037d8:	0030      	movs	r0, r6
 80037da:	f7fd f899 	bl	8000910 <chThdCreateStatic>
 80037de:	4b42      	ldr	r3, [pc, #264]	; (80038e8 <queues2_execute.lto_priv.119+0x208>)
 80037e0:	6018      	str	r0, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80037e2:	b672      	cpsid	i
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 80037e4:	68ea      	ldr	r2, [r5, #12]
 80037e6:	692b      	ldr	r3, [r5, #16]
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 80037e8:	68a9      	ldr	r1, [r5, #8]
 80037ea:	1a9b      	subs	r3, r3, r2
 80037ec:	1a59      	subs	r1, r3, r1
 80037ee:	3904      	subs	r1, #4
 80037f0:	424a      	negs	r2, r1
 80037f2:	414a      	adcs	r2, r1
 80037f4:	2008      	movs	r0, #8
 80037f6:	b2d1      	uxtb	r1, r2
 80037f8:	f7fc fee2 	bl	80005c0 <_test_assert>
 80037fc:	2800      	cmp	r0, #0
 80037fe:	d1ad      	bne.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003800:	b662      	cpsie	i
  test_wait_threads();
 8003802:	f7fd fbfd 	bl	8001000 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003806:	b672      	cpsid	i

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8003808:	2602      	movs	r6, #2
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 800380a:	68eb      	ldr	r3, [r5, #12]
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 800380c:	692a      	ldr	r2, [r5, #16]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800380e:	6828      	ldr	r0, [r5, #0]
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8003810:	61ab      	str	r3, [r5, #24]
  oqp->q_wrptr = oqp->q_buffer;
 8003812:	616b      	str	r3, [r5, #20]
  oqp->q_counter = chQSizeX(oqp);
 8003814:	1ad3      	subs	r3, r2, r3
 8003816:	60ab      	str	r3, [r5, #8]
 8003818:	4276      	negs	r6, r6
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 800381a:	42a8      	cmp	r0, r5
 800381c:	d008      	beq.n	8003830 <queues2_execute.lto_priv.119+0x150>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800381e:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003820:	605d      	str	r5, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003822:	602b      	str	r3, [r5, #0]
 8003824:	6206      	str	r6, [r0, #32]
  (void) chSchReadyI(tp);
 8003826:	f7fd f8f3 	bl	8000a10 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800382a:	6828      	ldr	r0, [r5, #0]
 800382c:	42a8      	cmp	r0, r5
 800382e:	d1f6      	bne.n	800381e <queues2_execute.lto_priv.119+0x13e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003830:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003832:	b672      	cpsid	i

  /* Testing reset */
  chSysLock();
  chOQResetI(&oq);
  chSysUnlock();
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 8003834:	68ea      	ldr	r2, [r5, #12]
 8003836:	692b      	ldr	r3, [r5, #16]
 8003838:	68a9      	ldr	r1, [r5, #8]
 800383a:	1a9b      	subs	r3, r3, r2
 800383c:	1a59      	subs	r1, r3, r1
 800383e:	424a      	negs	r2, r1
 8003840:	414a      	adcs	r2, r1
 8003842:	2009      	movs	r0, #9
 8003844:	b2d1      	uxtb	r1, r2
 8003846:	f7fc febb 	bl	80005c0 <_test_assert>
 800384a:	2800      	cmp	r0, #0
 800384c:	d000      	beq.n	8003850 <queues2_execute.lto_priv.119+0x170>
 800384e:	e785      	b.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003850:	b662      	cpsie	i

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8003852:	2300      	movs	r3, #0
 8003854:	2202      	movs	r2, #2
 8003856:	0021      	movs	r1, r4
 8003858:	0028      	movs	r0, r5
 800385a:	f7fd fd59 	bl	8001310 <chOQWriteTimeout>
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800385e:	1e81      	subs	r1, r0, #2
 8003860:	424b      	negs	r3, r1
 8003862:	414b      	adcs	r3, r1
 8003864:	200a      	movs	r0, #10
 8003866:	b2d9      	uxtb	r1, r3
 8003868:	f7fc feaa 	bl	80005c0 <_test_assert>
 800386c:	1e03      	subs	r3, r0, #0
 800386e:	d000      	beq.n	8003872 <queues2_execute.lto_priv.119+0x192>
 8003870:	e775      	b.n	800375e <queues2_execute.lto_priv.119+0x7e>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8003872:	0021      	movs	r1, r4
 8003874:	2202      	movs	r2, #2
 8003876:	0028      	movs	r0, r5
 8003878:	f7fd fd4a 	bl	8001310 <chOQWriteTimeout>
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800387c:	1e81      	subs	r1, r0, #2
 800387e:	424b      	negs	r3, r1
 8003880:	414b      	adcs	r3, r1
 8003882:	200b      	movs	r0, #11
 8003884:	b2d9      	uxtb	r1, r3
 8003886:	f7fc fe9b 	bl	80005c0 <_test_assert>
 800388a:	2800      	cmp	r0, #0
 800388c:	d000      	beq.n	8003890 <queues2_execute.lto_priv.119+0x1b0>
 800388e:	e766      	b.n	800375e <queues2_execute.lto_priv.119+0x7e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003890:	b672      	cpsid	i
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003892:	68ab      	ldr	r3, [r5, #8]
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 8003894:	300c      	adds	r0, #12
 8003896:	4259      	negs	r1, r3
 8003898:	4159      	adcs	r1, r3
 800389a:	b2c9      	uxtb	r1, r1
 800389c:	f7fc fe90 	bl	80005c0 <_test_assert>
 80038a0:	1e01      	subs	r1, r0, #0
 80038a2:	d000      	beq.n	80038a6 <queues2_execute.lto_priv.119+0x1c6>
 80038a4:	e75a      	b.n	800375c <queues2_execute.lto_priv.119+0x7c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80038a6:	b662      	cpsie	i

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 80038a8:	220a      	movs	r2, #10
 80038aa:	0028      	movs	r0, r5
 80038ac:	f7fd fd80 	bl	80013b0 <chOQPutTimeout>
 80038b0:	1c41      	adds	r1, r0, #1
 80038b2:	424b      	negs	r3, r1
 80038b4:	414b      	adcs	r3, r1
 80038b6:	200d      	movs	r0, #13
 80038b8:	b2d9      	uxtb	r1, r3
 80038ba:	f7fc fe81 	bl	80005c0 <_test_assert>
 80038be:	e74e      	b.n	800375e <queues2_execute.lto_priv.119+0x7e>
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80038c0:	68a9      	ldr	r1, [r5, #8]
 80038c2:	1e4b      	subs	r3, r1, #1
 80038c4:	4199      	sbcs	r1, r3
 80038c6:	b2c9      	uxtb	r1, r1
 80038c8:	e714      	b.n	80036f4 <queues2_execute.lto_priv.119+0x14>
 80038ca:	68ae      	ldr	r6, [r5, #8]
 80038cc:	1e73      	subs	r3, r6, #1
 80038ce:	419e      	sbcs	r6, r3
 80038d0:	b2f6      	uxtb	r6, r6
 80038d2:	e73d      	b.n	8003750 <queues2_execute.lto_priv.119+0x70>
 80038d4:	20000600 	.word	0x20000600
 80038d8:	080064fc 	.word	0x080064fc
 80038dc:	20000da0 	.word	0x20000da0
 80038e0:	20000ac0 	.word	0x20000ac0
 80038e4:	080036c1 	.word	0x080036c1
 80038e8:	20000a28 	.word	0x20000a28
 80038ec:	00000000 	.word	0x00000000

080038f0 <thread1>:
}

static THD_FUNCTION(thread1, p) {

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 80038f0:	21fa      	movs	r1, #250	; 0xfa
static void queues1_setup(void) {

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
}

static THD_FUNCTION(thread1, p) {
 80038f2:	b510      	push	{r4, lr}

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 80038f4:	00c9      	lsls	r1, r1, #3
 80038f6:	4802      	ldr	r0, [pc, #8]	; (8003900 <thread1+0x10>)
 80038f8:	f7fd fdda 	bl	80014b0 <chIQGetTimeout>
}
 80038fc:	bd10      	pop	{r4, pc}
 80038fe:	46c0      	nop			; (mov r8, r8)
 8003900:	20000624 	.word	0x20000624
	...

08003910 <queues1_execute.lto_priv.117>:

static void queues1_execute(void) {
 8003910:	b570      	push	{r4, r5, r6, lr}
 8003912:	b082      	sub	sp, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003914:	b672      	cpsid	i
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003916:	4d7f      	ldr	r5, [pc, #508]	; (8003b14 <queues1_execute.lto_priv.117+0x204>)
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 8003918:	2001      	movs	r0, #1
 800391a:	68ab      	ldr	r3, [r5, #8]
 800391c:	4259      	negs	r1, r3
 800391e:	4159      	adcs	r1, r3
 8003920:	b2c9      	uxtb	r1, r1
 8003922:	f7fc fe4d 	bl	80005c0 <_test_assert>
 8003926:	1e06      	subs	r6, r0, #0
 8003928:	d117      	bne.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800392a:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800392c:	b672      	cpsid	i
 800392e:	2441      	movs	r4, #65	; 0x41

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8003930:	0021      	movs	r1, r4
 8003932:	3401      	adds	r4, #1
 8003934:	0028      	movs	r0, r5
 8003936:	b2e4      	uxtb	r4, r4
 8003938:	f7fd f87a 	bl	8000a30 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800393c:	2c45      	cmp	r4, #69	; 0x45
 800393e:	d1f7      	bne.n	8003930 <queues1_execute.lto_priv.117+0x20>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003940:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003942:	b672      	cpsid	i
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003944:	696b      	ldr	r3, [r5, #20]
 8003946:	69aa      	ldr	r2, [r5, #24]
 8003948:	4293      	cmp	r3, r2
 800394a:	d100      	bne.n	800394e <queues1_execute.lto_priv.117+0x3e>
 800394c:	e0dd      	b.n	8003b0a <queues1_execute.lto_priv.117+0x1fa>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800394e:	0031      	movs	r1, r6
 8003950:	2002      	movs	r0, #2
 8003952:	f7fc fe35 	bl	80005c0 <_test_assert>
 8003956:	2800      	cmp	r0, #0
 8003958:	d002      	beq.n	8003960 <queues1_execute.lto_priv.117+0x50>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800395a:	b662      	cpsie	i
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
  test_wait_threads();

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
}
 800395c:	b002      	add	sp, #8
 800395e:	bd70      	pop	{r4, r5, r6, pc}
 8003960:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003962:	b672      	cpsid	i
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 8003964:	2100      	movs	r1, #0
 8003966:	0028      	movs	r0, r5
 8003968:	f7fd f862 	bl	8000a30 <chIQPutI>
 800396c:	1d01      	adds	r1, r0, #4
 800396e:	424b      	negs	r3, r1
 8003970:	414b      	adcs	r3, r1
 8003972:	2003      	movs	r0, #3
 8003974:	b2d9      	uxtb	r1, r3
 8003976:	f7fc fe23 	bl	80005c0 <_test_assert>
 800397a:	2800      	cmp	r0, #0
 800397c:	d1ed      	bne.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800397e:	b662      	cpsie	i
 8003980:	2404      	movs	r4, #4
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8003982:	2101      	movs	r1, #1
 8003984:	0028      	movs	r0, r5
 8003986:	4249      	negs	r1, r1
 8003988:	f7fd fd92 	bl	80014b0 <chIQGetTimeout>
 800398c:	3c01      	subs	r4, #1

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    test_emit_token(chIQGet(&iq));
 800398e:	b2c0      	uxtb	r0, r0
 8003990:	f7fc fe2e 	bl	80005f0 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8003994:	2c00      	cmp	r4, #0
 8003996:	d1f4      	bne.n	8003982 <queues1_execute.lto_priv.117+0x72>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003998:	b672      	cpsid	i
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800399a:	68ab      	ldr	r3, [r5, #8]
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 800399c:	2004      	movs	r0, #4
 800399e:	4259      	negs	r1, r3
 80039a0:	4159      	adcs	r1, r3
 80039a2:	b2c9      	uxtb	r1, r1
 80039a4:	f7fc fe0c 	bl	80005c0 <_test_assert>
 80039a8:	2800      	cmp	r0, #0
 80039aa:	d1d6      	bne.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80039ac:	b662      	cpsie	i
  test_assert_sequence(5, "ABCD");
 80039ae:	495a      	ldr	r1, [pc, #360]	; (8003b18 <queues1_execute.lto_priv.117+0x208>)
 80039b0:	2005      	movs	r0, #5
 80039b2:	f7fc fdd5 	bl	8000560 <_test_assert_sequence>
 80039b6:	2800      	cmp	r0, #0
 80039b8:	d1d0      	bne.n	800395c <queues1_execute.lto_priv.117+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80039ba:	b672      	cpsid	i
 80039bc:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 80039be:	0021      	movs	r1, r4
 80039c0:	3401      	adds	r4, #1
 80039c2:	0028      	movs	r0, r5
 80039c4:	b2e4      	uxtb	r4, r4
 80039c6:	f7fd f833 	bl	8000a30 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 80039ca:	2c45      	cmp	r4, #69	; 0x45
 80039cc:	d1f7      	bne.n	80039be <queues1_execute.lto_priv.117+0xae>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80039ce:	b662      	cpsie	i
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 80039d0:	4e52      	ldr	r6, [pc, #328]	; (8003b1c <queues1_execute.lto_priv.117+0x20c>)
 80039d2:	2300      	movs	r3, #0
 80039d4:	0031      	movs	r1, r6
 80039d6:	2208      	movs	r2, #8
 80039d8:	0028      	movs	r0, r5
 80039da:	f7fd fd21 	bl	8001420 <chIQReadTimeout>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 80039de:	1f01      	subs	r1, r0, #4
 80039e0:	424b      	negs	r3, r1
 80039e2:	414b      	adcs	r3, r1
 80039e4:	2006      	movs	r0, #6
 80039e6:	b2d9      	uxtb	r1, r3
 80039e8:	f7fc fdea 	bl	80005c0 <_test_assert>
 80039ec:	2800      	cmp	r0, #0
 80039ee:	d1b5      	bne.n	800395c <queues1_execute.lto_priv.117+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80039f0:	b672      	cpsid	i
 80039f2:	68ab      	ldr	r3, [r5, #8]
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 80039f4:	3007      	adds	r0, #7
 80039f6:	4259      	negs	r1, r3
 80039f8:	4159      	adcs	r1, r3
 80039fa:	b2c9      	uxtb	r1, r1
 80039fc:	f7fc fde0 	bl	80005c0 <_test_assert>
 8003a00:	2800      	cmp	r0, #0
 8003a02:	d1aa      	bne.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a04:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a06:	b672      	cpsid	i
 8003a08:	2441      	movs	r4, #65	; 0x41

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chIQPutI(&iq, 'A' + i);
 8003a0a:	0021      	movs	r1, r4
 8003a0c:	3401      	adds	r4, #1
 8003a0e:	0028      	movs	r0, r5
 8003a10:	b2e4      	uxtb	r4, r4
 8003a12:	f7fd f80d 	bl	8000a30 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 8003a16:	2c45      	cmp	r4, #69	; 0x45
 8003a18:	d1f7      	bne.n	8003a0a <queues1_execute.lto_priv.117+0xfa>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a1a:	b662      	cpsie	i
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8003a1c:	2300      	movs	r3, #0
 8003a1e:	0031      	movs	r1, r6
 8003a20:	2202      	movs	r2, #2
 8003a22:	0028      	movs	r0, r5
 8003a24:	f7fd fcfc 	bl	8001420 <chIQReadTimeout>
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8003a28:	1e81      	subs	r1, r0, #2
 8003a2a:	424b      	negs	r3, r1
 8003a2c:	414b      	adcs	r3, r1
 8003a2e:	2008      	movs	r0, #8
 8003a30:	b2d9      	uxtb	r1, r3
 8003a32:	f7fc fdc5 	bl	80005c0 <_test_assert>
 8003a36:	2800      	cmp	r0, #0
 8003a38:	d000      	beq.n	8003a3c <queues1_execute.lto_priv.117+0x12c>
 8003a3a:	e78f      	b.n	800395c <queues1_execute.lto_priv.117+0x4c>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 8003a3c:	2300      	movs	r3, #0
 8003a3e:	0031      	movs	r1, r6
 8003a40:	2202      	movs	r2, #2
 8003a42:	0028      	movs	r0, r5
 8003a44:	f7fd fcec 	bl	8001420 <chIQReadTimeout>
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 8003a48:	1e81      	subs	r1, r0, #2
 8003a4a:	424b      	negs	r3, r1
 8003a4c:	414b      	adcs	r3, r1
 8003a4e:	2009      	movs	r0, #9
 8003a50:	b2d9      	uxtb	r1, r3
 8003a52:	f7fc fdb5 	bl	80005c0 <_test_assert>
 8003a56:	2800      	cmp	r0, #0
 8003a58:	d000      	beq.n	8003a5c <queues1_execute.lto_priv.117+0x14c>
 8003a5a:	e77f      	b.n	800395c <queues1_execute.lto_priv.117+0x4c>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a5c:	b672      	cpsid	i
 8003a5e:	68ab      	ldr	r3, [r5, #8]
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 8003a60:	300a      	adds	r0, #10
 8003a62:	4259      	negs	r1, r3
 8003a64:	4159      	adcs	r1, r3
 8003a66:	b2c9      	uxtb	r1, r1
 8003a68:	f7fc fdaa 	bl	80005c0 <_test_assert>
 8003a6c:	1e04      	subs	r4, r0, #0
 8003a6e:	d000      	beq.n	8003a72 <queues1_execute.lto_priv.117+0x162>
 8003a70:	e773      	b.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003a72:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003a74:	b672      	cpsid	i

  /* Testing reset */
  chSysLock();
  chIQPutI(&iq, 0);
 8003a76:	2100      	movs	r1, #0
 8003a78:	0028      	movs	r0, r5
 8003a7a:	f7fc ffd9 	bl	8000a30 <chIQPutI>

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 8003a7e:	60ac      	str	r4, [r5, #8]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8003a80:	2402      	movs	r4, #2
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 8003a82:	68eb      	ldr	r3, [r5, #12]
 8003a84:	6828      	ldr	r0, [r5, #0]
 8003a86:	61ab      	str	r3, [r5, #24]
  iqp->q_wrptr = iqp->q_buffer;
 8003a88:	616b      	str	r3, [r5, #20]
 8003a8a:	4264      	negs	r4, r4
 8003a8c:	42a8      	cmp	r0, r5
 8003a8e:	d008      	beq.n	8003aa2 <queues1_execute.lto_priv.117+0x192>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003a90:	6803      	ldr	r3, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8003a92:	605d      	str	r5, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8003a94:	602b      	str	r3, [r5, #0]
 8003a96:	6204      	str	r4, [r0, #32]
  (void) chSchReadyI(tp);
 8003a98:	f7fc ffba 	bl	8000a10 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8003a9c:	6828      	ldr	r0, [r5, #0]
 8003a9e:	42a8      	cmp	r0, r5
 8003aa0:	d1f6      	bne.n	8003a90 <queues1_execute.lto_priv.117+0x180>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003aa2:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003aa4:	b672      	cpsid	i
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 8003aa6:	68ab      	ldr	r3, [r5, #8]
  chIQResetI(&iq);
  chSysUnlock();
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 8003aa8:	200b      	movs	r0, #11
 8003aaa:	4259      	negs	r1, r3
 8003aac:	4159      	adcs	r1, r3
 8003aae:	b2c9      	uxtb	r1, r1
 8003ab0:	f7fc fd86 	bl	80005c0 <_test_assert>
 8003ab4:	2800      	cmp	r0, #0
 8003ab6:	d000      	beq.n	8003aba <queues1_execute.lto_priv.117+0x1aa>
 8003ab8:	e74f      	b.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003aba:	b662      	cpsie	i
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 8003abc:	21a4      	movs	r1, #164	; 0xa4
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003abe:	4b18      	ldr	r3, [pc, #96]	; (8003b20 <queues1_execute.lto_priv.117+0x210>)
 8003ac0:	0049      	lsls	r1, r1, #1
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003ac2:	699b      	ldr	r3, [r3, #24]
 8003ac4:	689a      	ldr	r2, [r3, #8]
 8003ac6:	9000      	str	r0, [sp, #0]
 8003ac8:	3201      	adds	r2, #1
 8003aca:	4b16      	ldr	r3, [pc, #88]	; (8003b24 <queues1_execute.lto_priv.117+0x214>)
 8003acc:	4816      	ldr	r0, [pc, #88]	; (8003b28 <queues1_execute.lto_priv.117+0x218>)
 8003ace:	f7fc ff1f 	bl	8000910 <chThdCreateStatic>
 8003ad2:	4b16      	ldr	r3, [pc, #88]	; (8003b2c <queues1_execute.lto_priv.117+0x21c>)
 8003ad4:	6018      	str	r0, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ad6:	b672      	cpsid	i
 8003ad8:	68ab      	ldr	r3, [r5, #8]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 8003ada:	200c      	movs	r0, #12
 8003adc:	4259      	negs	r1, r3
 8003ade:	4159      	adcs	r1, r3
 8003ae0:	b2c9      	uxtb	r1, r1
 8003ae2:	f7fc fd6d 	bl	80005c0 <_test_assert>
 8003ae6:	2800      	cmp	r0, #0
 8003ae8:	d000      	beq.n	8003aec <queues1_execute.lto_priv.117+0x1dc>
 8003aea:	e736      	b.n	800395a <queues1_execute.lto_priv.117+0x4a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003aec:	b662      	cpsie	i
  test_wait_threads();
 8003aee:	f7fd fa87 	bl	8001000 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 8003af2:	210a      	movs	r1, #10
 8003af4:	0028      	movs	r0, r5
 8003af6:	f7fd fcdb 	bl	80014b0 <chIQGetTimeout>
 8003afa:	1c41      	adds	r1, r0, #1
 8003afc:	424b      	negs	r3, r1
 8003afe:	414b      	adcs	r3, r1
 8003b00:	200d      	movs	r0, #13
 8003b02:	b2d9      	uxtb	r1, r3
 8003b04:	f7fc fd5c 	bl	80005c0 <_test_assert>
 8003b08:	e728      	b.n	800395c <queues1_execute.lto_priv.117+0x4c>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003b0a:	68ae      	ldr	r6, [r5, #8]
 8003b0c:	1e73      	subs	r3, r6, #1
 8003b0e:	419e      	sbcs	r6, r3
 8003b10:	b2f6      	uxtb	r6, r6
 8003b12:	e71c      	b.n	800394e <queues1_execute.lto_priv.117+0x3e>
 8003b14:	20000624 	.word	0x20000624
 8003b18:	080064fc 	.word	0x080064fc
 8003b1c:	20000da0 	.word	0x20000da0
 8003b20:	20000ac0 	.word	0x20000ac0
 8003b24:	080038f1 	.word	0x080038f1
 8003b28:	20000c58 	.word	0x20000c58
 8003b2c:	20000a28 	.word	0x20000a28

08003b30 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 8003b30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003b32:	0007      	movs	r7, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b34:	b672      	cpsid	i
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8003b36:	4e0e      	ldr	r6, [pc, #56]	; (8003b70 <regfind+0x40>)
 8003b38:	6930      	ldr	r0, [r6, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 8003b3a:	7f83      	ldrb	r3, [r0, #30]
 8003b3c:	3301      	adds	r3, #1
 8003b3e:	7783      	strb	r3, [r0, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003b40:	b662      	cpsie	i
  thread_t *ftp;
  bool found = false;
 8003b42:	2500      	movs	r5, #0
 8003b44:	e000      	b.n	8003b48 <regfind+0x18>

  ftp = chRegFirstThread();
  do {
    found |= ftp == tp;
    ftp = chRegNextThread(ftp);
  } while (ftp != NULL);
 8003b46:	0020      	movs	r0, r4
 8003b48:	1bc3      	subs	r3, r0, r7
 8003b4a:	425a      	negs	r2, r3
 8003b4c:	4153      	adcs	r3, r2
 8003b4e:	431d      	orrs	r5, r3
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b50:	b672      	cpsid	i
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 8003b52:	6904      	ldr	r4, [r0, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8003b54:	42b4      	cmp	r4, r6
 8003b56:	d009      	beq.n	8003b6c <regfind+0x3c>
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 8003b58:	7fa3      	ldrb	r3, [r4, #30]
 8003b5a:	3301      	adds	r3, #1
 8003b5c:	77a3      	strb	r3, [r4, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003b5e:	b662      	cpsie	i
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8003b60:	f7fd fa06 	bl	8000f70 <chThdRelease>
 8003b64:	2c00      	cmp	r4, #0
 8003b66:	d1ee      	bne.n	8003b46 <regfind+0x16>
  return found;
}
 8003b68:	0028      	movs	r0, r5
 8003b6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8003b6c:	2400      	movs	r4, #0
 8003b6e:	e7f6      	b.n	8003b5e <regfind+0x2e>
 8003b70:	20000ac0 	.word	0x20000ac0
	...

08003b80 <dyn3_execute.lto_priv.115>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003b80:	4b45      	ldr	r3, [pc, #276]	; (8003c98 <dyn3_execute.lto_priv.115+0x118>)
static void dyn3_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn3_execute(void) {
 8003b82:	b510      	push	{r4, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003b84:	699b      	ldr	r3, [r3, #24]
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8003b86:	4945      	ldr	r1, [pc, #276]	; (8003c9c <dyn3_execute.lto_priv.115+0x11c>)
 8003b88:	6898      	ldr	r0, [r3, #8]
 8003b8a:	3801      	subs	r0, #1
 8003b8c:	f001 fb90 	bl	80052b0 <chThdCreateFromHeap.constprop.53>
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8003b90:	7f81      	ldrb	r1, [r0, #30]
static void dyn3_execute(void) {
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 8003b92:	0004      	movs	r4, r0
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 8003b94:	3901      	subs	r1, #1
 8003b96:	424b      	negs	r3, r1
 8003b98:	4159      	adcs	r1, r3
 8003b9a:	2001      	movs	r0, #1
 8003b9c:	b2c9      	uxtb	r1, r1
 8003b9e:	f7fc fd0f 	bl	80005c0 <_test_assert>
 8003ba2:	2800      	cmp	r0, #0
 8003ba4:	d000      	beq.n	8003ba8 <dyn3_execute.lto_priv.115+0x28>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
  test_assert(12, !regfind(tp), "thread still in registry");
}
 8003ba6:	bd10      	pop	{r4, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ba8:	b672      	cpsid	i
 */
thread_t *chThdAddRef(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 8003baa:	7fa3      	ldrb	r3, [r4, #30]
 8003bac:	3301      	adds	r3, #1
 8003bae:	77a3      	strb	r3, [r4, #30]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003bb0:	b662      	cpsie	i

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
  chThdAddRef(tp);
  test_assert(2, tp->p_refs == 2, "references increase failure");
 8003bb2:	7fa1      	ldrb	r1, [r4, #30]
 8003bb4:	3002      	adds	r0, #2
 8003bb6:	3902      	subs	r1, #2
 8003bb8:	424b      	negs	r3, r1
 8003bba:	4159      	adcs	r1, r3
 8003bbc:	b2c9      	uxtb	r1, r1
 8003bbe:	f7fc fcff 	bl	80005c0 <_test_assert>
 8003bc2:	2800      	cmp	r0, #0
 8003bc4:	d1ef      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  chThdRelease(tp);
 8003bc6:	0020      	movs	r0, r4
 8003bc8:	f7fd f9d2 	bl	8000f70 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 8003bcc:	7fa1      	ldrb	r1, [r4, #30]
 8003bce:	2003      	movs	r0, #3
 8003bd0:	3901      	subs	r1, #1
 8003bd2:	424b      	negs	r3, r1
 8003bd4:	4159      	adcs	r1, r3
 8003bd6:	b2c9      	uxtb	r1, r1
 8003bd8:	f7fc fcf2 	bl	80005c0 <_test_assert>
 8003bdc:	2800      	cmp	r0, #0
 8003bde:	d1e2      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 8003be0:	0020      	movs	r0, r4
 8003be2:	f7ff ffa5 	bl	8003b30 <regfind>
 8003be6:	0001      	movs	r1, r0
 8003be8:	2004      	movs	r0, #4
 8003bea:	f7fc fce9 	bl	80005c0 <_test_assert>
 8003bee:	2800      	cmp	r0, #0
 8003bf0:	d1d9      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  test_assert(5, regfind(tp), "thread disappeared");
 8003bf2:	0020      	movs	r0, r4
 8003bf4:	f7ff ff9c 	bl	8003b30 <regfind>
 8003bf8:	0001      	movs	r1, r0
 8003bfa:	2005      	movs	r0, #5
 8003bfc:	f7fc fce0 	bl	80005c0 <_test_assert>
 8003c00:	2800      	cmp	r0, #0
 8003c02:	d1d0      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 8003c04:	0020      	movs	r0, r4
 8003c06:	f7fd f9b3 	bl	8000f70 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 8003c0a:	7fa1      	ldrb	r1, [r4, #30]
 8003c0c:	2006      	movs	r0, #6
 8003c0e:	424b      	negs	r3, r1
 8003c10:	4159      	adcs	r1, r3
 8003c12:	b2c9      	uxtb	r1, r1
 8003c14:	f7fc fcd4 	bl	80005c0 <_test_assert>
 8003c18:	2800      	cmp	r0, #0
 8003c1a:	d1c4      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 8003c1c:	7f21      	ldrb	r1, [r4, #28]
 8003c1e:	3007      	adds	r0, #7
 8003c20:	424b      	negs	r3, r1
 8003c22:	4159      	adcs	r1, r3
 8003c24:	b2c9      	uxtb	r1, r1
 8003c26:	f7fc fccb 	bl	80005c0 <_test_assert>
 8003c2a:	2800      	cmp	r0, #0
 8003c2c:	d1bb      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  test_assert(8, regfind(tp), "thread disappeared");
 8003c2e:	0020      	movs	r0, r4
 8003c30:	f7ff ff7e 	bl	8003b30 <regfind>
 8003c34:	0001      	movs	r1, r0
 8003c36:	2008      	movs	r0, #8
 8003c38:	f7fc fcc2 	bl	80005c0 <_test_assert>
 8003c3c:	2800      	cmp	r0, #0
 8003c3e:	d1b2      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  test_assert(9, regfind(tp), "thread disappeared");
 8003c40:	0020      	movs	r0, r4
 8003c42:	f7ff ff75 	bl	8003b30 <regfind>
 8003c46:	0001      	movs	r1, r0
 8003c48:	2009      	movs	r0, #9
 8003c4a:	f7fc fcb9 	bl	80005c0 <_test_assert>
 8003c4e:	2800      	cmp	r0, #0
 8003c50:	d1a9      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 8003c52:	30f5      	adds	r0, #245	; 0xf5
 8003c54:	30ff      	adds	r0, #255	; 0xff
 8003c56:	f7fd fc5b 	bl	8001510 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 8003c5a:	7f21      	ldrb	r1, [r4, #28]
 8003c5c:	200a      	movs	r0, #10
 8003c5e:	390f      	subs	r1, #15
 8003c60:	424b      	negs	r3, r1
 8003c62:	4159      	adcs	r1, r3
 8003c64:	b2c9      	uxtb	r1, r1
 8003c66:	f7fc fcab 	bl	80005c0 <_test_assert>
 8003c6a:	2800      	cmp	r0, #0
 8003c6c:	d19b      	bne.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 8003c6e:	0020      	movs	r0, r4
 8003c70:	f7ff ff5e 	bl	8003b30 <regfind>
 8003c74:	0001      	movs	r1, r0
 8003c76:	200b      	movs	r0, #11
 8003c78:	f7fc fca2 	bl	80005c0 <_test_assert>
 8003c7c:	2800      	cmp	r0, #0
 8003c7e:	d000      	beq.n	8003c82 <dyn3_execute.lto_priv.115+0x102>
 8003c80:	e791      	b.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
  test_assert(12, !regfind(tp), "thread still in registry");
 8003c82:	0020      	movs	r0, r4
 8003c84:	f7ff ff54 	bl	8003b30 <regfind>
 8003c88:	2101      	movs	r1, #1
 8003c8a:	4041      	eors	r1, r0
 8003c8c:	b2c9      	uxtb	r1, r1
 8003c8e:	200c      	movs	r0, #12
 8003c90:	f7fc fc96 	bl	80005c0 <_test_assert>
 8003c94:	e787      	b.n	8003ba6 <dyn3_execute.lto_priv.115+0x26>
 8003c96:	46c0      	nop			; (mov r8, r8)
 8003c98:	20000ac0 	.word	0x20000ac0
 8003c9c:	080064d4 	.word	0x080064d4

08003ca0 <dyn3_setup.lto_priv.114>:
 8003ca0:	b510      	push	{r4, lr}
 8003ca2:	f000 f88d 	bl	8003dc0 <dyn1_setup.lto_priv.110>
 8003ca6:	bd10      	pop	{r4, pc}
	...

08003cb0 <dyn2_execute.lto_priv.113>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003cb0:	4b33      	ldr	r3, [pc, #204]	; (8003d80 <dyn2_execute.lto_priv.113+0xd0>)
static void dyn2_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void dyn2_execute(void) {
 8003cb2:	b570      	push	{r4, r5, r6, lr}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003cb4:	699b      	ldr	r3, [r3, #24]
 8003cb6:	4a33      	ldr	r2, [pc, #204]	; (8003d84 <dyn2_execute.lto_priv.113+0xd4>)
 8003cb8:	689e      	ldr	r6, [r3, #8]
 8003cba:	2300      	movs	r3, #0
 8003cbc:	4c32      	ldr	r4, [pc, #200]	; (8003d88 <dyn2_execute.lto_priv.113+0xd8>)
 8003cbe:	4933      	ldr	r1, [pc, #204]	; (8003d8c <dyn2_execute.lto_priv.113+0xdc>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003cc0:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8003cc2:	6820      	ldr	r0, [r4, #0]
 8003cc4:	6010      	str	r0, [r2, #0]
  mp->mp_next = php;
 8003cc6:	6022      	str	r2, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003cc8:	b662      	cpsie	i
 8003cca:	3304      	adds	r3, #4
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 8003ccc:	2b10      	cmp	r3, #16
 8003cce:	d001      	beq.n	8003cd4 <dyn2_execute.lto_priv.113+0x24>
 8003cd0:	58ca      	ldr	r2, [r1, r3]
 8003cd2:	e7f5      	b.n	8003cc0 <dyn2_execute.lto_priv.113+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8003cd4:	492e      	ldr	r1, [pc, #184]	; (8003d90 <dyn2_execute.lto_priv.113+0xe0>)
 8003cd6:	1e70      	subs	r0, r6, #1
 8003cd8:	f001 fb2a 	bl	8005330 <chThdCreateFromMemoryPool.constprop.52>
 8003cdc:	4d2d      	ldr	r5, [pc, #180]	; (8003d94 <dyn2_execute.lto_priv.113+0xe4>)
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8003cde:	492e      	ldr	r1, [pc, #184]	; (8003d98 <dyn2_execute.lto_priv.113+0xe8>)
  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 8003ce0:	6028      	str	r0, [r5, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8003ce2:	1eb0      	subs	r0, r6, #2
 8003ce4:	f001 fb24 	bl	8005330 <chThdCreateFromMemoryPool.constprop.52>
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8003ce8:	492c      	ldr	r1, [pc, #176]	; (8003d9c <dyn2_execute.lto_priv.113+0xec>)
  for (i = 0; i < 4; i++)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 8003cea:	6068      	str	r0, [r5, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8003cec:	1ef0      	subs	r0, r6, #3
 8003cee:	f001 fb1f 	bl	8005330 <chThdCreateFromMemoryPool.constprop.52>
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8003cf2:	492b      	ldr	r1, [pc, #172]	; (8003da0 <dyn2_execute.lto_priv.113+0xf0>)
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 8003cf4:	60a8      	str	r0, [r5, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8003cf6:	1f30      	subs	r0, r6, #4
 8003cf8:	f001 fb1a 	bl	8005330 <chThdCreateFromMemoryPool.constprop.52>
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8003cfc:	4929      	ldr	r1, [pc, #164]	; (8003da4 <dyn2_execute.lto_priv.113+0xf4>)

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 8003cfe:	60e8      	str	r0, [r5, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8003d00:	1f70      	subs	r0, r6, #5
 8003d02:	f001 fb15 	bl	8005330 <chThdCreateFromMemoryPool.constprop.52>

  test_assert(1, (threads[0] != NULL) &&
 8003d06:	682b      	ldr	r3, [r5, #0]
  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 8003d08:	6128      	str	r0, [r5, #16]

  test_assert(1, (threads[0] != NULL) &&
 8003d0a:	2b00      	cmp	r3, #0
 8003d0c:	d011      	beq.n	8003d32 <dyn2_execute.lto_priv.113+0x82>
 8003d0e:	686b      	ldr	r3, [r5, #4]
 8003d10:	2b00      	cmp	r3, #0
 8003d12:	d00e      	beq.n	8003d32 <dyn2_execute.lto_priv.113+0x82>
 8003d14:	68ab      	ldr	r3, [r5, #8]
 8003d16:	2b00      	cmp	r3, #0
 8003d18:	d00b      	beq.n	8003d32 <dyn2_execute.lto_priv.113+0x82>
 8003d1a:	68eb      	ldr	r3, [r5, #12]
 8003d1c:	2b00      	cmp	r3, #0
 8003d1e:	d008      	beq.n	8003d32 <dyn2_execute.lto_priv.113+0x82>
 8003d20:	4241      	negs	r1, r0
 8003d22:	4141      	adcs	r1, r0
 8003d24:	2001      	movs	r0, #1
 8003d26:	b2c9      	uxtb	r1, r1
 8003d28:	f7fc fc4a 	bl	80005c0 <_test_assert>
 8003d2c:	2800      	cmp	r0, #0
 8003d2e:	d006      	beq.n	8003d3e <dyn2_execute.lto_priv.113+0x8e>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
}
 8003d30:	bd70      	pop	{r4, r5, r6, pc}
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");

  test_assert(1, (threads[0] != NULL) &&
 8003d32:	2100      	movs	r1, #0
 8003d34:	2001      	movs	r0, #1
 8003d36:	f7fc fc43 	bl	80005c0 <_test_assert>
 8003d3a:	2800      	cmp	r0, #0
 8003d3c:	d1f8      	bne.n	8003d30 <dyn2_execute.lto_priv.113+0x80>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8003d3e:	f7fd f95f 	bl	8001000 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 8003d42:	4919      	ldr	r1, [pc, #100]	; (8003da8 <dyn2_execute.lto_priv.113+0xf8>)
 8003d44:	2002      	movs	r0, #2
 8003d46:	f7fc fc0b 	bl	8000560 <_test_assert_sequence>
 8003d4a:	2800      	cmp	r0, #0
 8003d4c:	d1f0      	bne.n	8003d30 <dyn2_execute.lto_priv.113+0x80>
 8003d4e:	2504      	movs	r5, #4

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 8003d50:	0020      	movs	r0, r4
 8003d52:	f7fc fd25 	bl	80007a0 <chPoolAlloc>
 8003d56:	1e41      	subs	r1, r0, #1
 8003d58:	4188      	sbcs	r0, r1
 8003d5a:	b2c1      	uxtb	r1, r0
 8003d5c:	2003      	movs	r0, #3
 8003d5e:	f7fc fc2f 	bl	80005c0 <_test_assert>
 8003d62:	2800      	cmp	r0, #0
 8003d64:	d1e4      	bne.n	8003d30 <dyn2_execute.lto_priv.113+0x80>
 8003d66:	3d01      	subs	r5, #1
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 8003d68:	2d00      	cmp	r5, #0
 8003d6a:	d1f1      	bne.n	8003d50 <dyn2_execute.lto_priv.113+0xa0>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 8003d6c:	0020      	movs	r0, r4
 8003d6e:	f7fc fd17 	bl	80007a0 <chPoolAlloc>
 8003d72:	4241      	negs	r1, r0
 8003d74:	4141      	adcs	r1, r0
 8003d76:	2004      	movs	r0, #4
 8003d78:	b2c9      	uxtb	r1, r1
 8003d7a:	f7fc fc21 	bl	80005c0 <_test_assert>
 8003d7e:	e7d7      	b.n	8003d30 <dyn2_execute.lto_priv.113+0x80>
 8003d80:	20000ac0 	.word	0x20000ac0
 8003d84:	20000c58 	.word	0x20000c58
 8003d88:	20000c14 	.word	0x20000c14
 8003d8c:	080064b0 	.word	0x080064b0
 8003d90:	080064d4 	.word	0x080064d4
 8003d94:	20000a28 	.word	0x20000a28
 8003d98:	080064d0 	.word	0x080064d0
 8003d9c:	080064dc 	.word	0x080064dc
 8003da0:	080064d8 	.word	0x080064d8
 8003da4:	080064e4 	.word	0x080064e4
 8003da8:	080064fc 	.word	0x080064fc
 8003dac:	00000000 	.word	0x00000000

08003db0 <thread1.lto_priv.62>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 8003db0:	b510      	push	{r4, lr}

  chThdExit((msg_t)p);
 8003db2:	f7fd f9b5 	bl	8001120 <chThdExit>
}
 8003db6:	bd10      	pop	{r4, pc}
	...

08003dc0 <dyn1_setup.lto_priv.110>:

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003dc0:	20cc      	movs	r0, #204	; 0xcc
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8003dc2:	2200      	movs	r2, #0
 8003dc4:	4b06      	ldr	r3, [pc, #24]	; (8003de0 <dyn1_setup.lto_priv.110+0x20>)
  heapp->h_free.h.u.next = hp;
 8003dc6:	4907      	ldr	r1, [pc, #28]	; (8003de4 <dyn1_setup.lto_priv.110+0x24>)
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003dc8:	00c0      	lsls	r0, r0, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8003dca:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 8003dcc:	600a      	str	r2, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003dce:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003dd0:	0019      	movs	r1, r3
 8003dd2:	3110      	adds	r1, #16
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8003dd4:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8003dd6:	60da      	str	r2, [r3, #12]
 8003dd8:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003dda:	6159      	str	r1, [r3, #20]
 8003ddc:	619a      	str	r2, [r3, #24]

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}
 8003dde:	4770      	bx	lr
 8003de0:	20000c38 	.word	0x20000c38
 8003de4:	20000c58 	.word	0x20000c58
	...

08003df0 <null_provider>:

static void *null_provider(size_t size) {

  (void)size;
  return NULL;
}
 8003df0:	2000      	movs	r0, #0
 8003df2:	4770      	bx	lr
	...

08003e00 <pools1_setup.lto_priv.108>:
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 8003e00:	21a4      	movs	r1, #164	; 0xa4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8003e02:	2200      	movs	r2, #0
 8003e04:	4b02      	ldr	r3, [pc, #8]	; (8003e10 <pools1_setup.lto_priv.108+0x10>)
  mp->mp_object_size = size;
 8003e06:	0049      	lsls	r1, r1, #1
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 8003e08:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 8003e0a:	6059      	str	r1, [r3, #4]
  mp->mp_provider = provider;
 8003e0c:	609a      	str	r2, [r3, #8]

static void pools1_setup(void) {

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}
 8003e0e:	4770      	bx	lr
 8003e10:	20000648 	.word	0x20000648
	...

08003e20 <heap1_setup.lto_priv.106>:
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003e20:	20cc      	movs	r0, #204	; 0xcc
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8003e22:	2200      	movs	r2, #0
 8003e24:	4b06      	ldr	r3, [pc, #24]	; (8003e40 <heap1_setup.lto_priv.106+0x20>)
  heapp->h_free.h.u.next = hp;
 8003e26:	4907      	ldr	r1, [pc, #28]	; (8003e44 <heap1_setup.lto_priv.106+0x24>)
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
  hp->h.size = size - sizeof(union heap_header);
 8003e28:	00c0      	lsls	r0, r0, #3
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
  heapp->h_free.h.u.next = hp;
 8003e2a:	6099      	str	r1, [r3, #8]
  heapp->h_free.h.size = 0;
  hp->h.u.next = NULL;
 8003e2c:	600a      	str	r2, [r1, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003e2e:	6048      	str	r0, [r1, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003e30:	0019      	movs	r1, r3
 8003e32:	3110      	adds	r1, #16
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
  union heap_header *hp = buf;

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 8003e34:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
  heapp->h_free.h.size = 0;
 8003e36:	60da      	str	r2, [r3, #12]
 8003e38:	6119      	str	r1, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003e3a:	6159      	str	r1, [r3, #20]
 8003e3c:	619a      	str	r2, [r3, #24]
 */

static void heap1_setup(void) {

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
}
 8003e3e:	4770      	bx	lr
 8003e40:	20000aa0 	.word	0x20000aa0
 8003e44:	20000c58 	.word	0x20000c58
	...

08003e50 <dyn1_execute.lto_priv.111>:

static void dyn1_execute(void) {
 8003e50:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8003e52:	4b2f      	ldr	r3, [pc, #188]	; (8003f10 <dyn1_execute.lto_priv.111+0xc0>)
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8003e54:	4e2f      	ldr	r6, [pc, #188]	; (8003f14 <dyn1_execute.lto_priv.111+0xc4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8003e56:	699b      	ldr	r3, [r3, #24]
static void dyn1_setup(void) {

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
}

static void dyn1_execute(void) {
 8003e58:	b083      	sub	sp, #12
 8003e5a:	689d      	ldr	r5, [r3, #8]
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
 8003e5c:	4669      	mov	r1, sp
 8003e5e:	0030      	movs	r0, r6
 8003e60:	f7fd f816 	bl	8000e90 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8003e64:	492c      	ldr	r1, [pc, #176]	; (8003f18 <dyn1_execute.lto_priv.111+0xc8>)
 8003e66:	1e68      	subs	r0, r5, #1
 8003e68:	f001 fa22 	bl	80052b0 <chThdCreateFromHeap.constprop.53>
 8003e6c:	4c2b      	ldr	r4, [pc, #172]	; (8003f1c <dyn1_execute.lto_priv.111+0xcc>)
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8003e6e:	492c      	ldr	r1, [pc, #176]	; (8003f20 <dyn1_execute.lto_priv.111+0xd0>)
  void *p1;
  tprio_t prio = chThdGetPriorityX();

  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 8003e70:	6020      	str	r0, [r4, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8003e72:	1ea8      	subs	r0, r5, #2
 8003e74:	f001 fa1c 	bl	80052b0 <chThdCreateFromHeap.constprop.53>
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8003e78:	a901      	add	r1, sp, #4
  (void)chHeapStatus(&heap1, &sz);
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 8003e7a:	6060      	str	r0, [r4, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 8003e7c:	0030      	movs	r0, r6
 8003e7e:	f7fd f807 	bl	8000e90 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 8003e82:	9901      	ldr	r1, [sp, #4]
 8003e84:	0030      	movs	r0, r6
 8003e86:	f7fd f8d3 	bl	8001030 <chHeapAlloc>
  threads[2] = chThdCreateFromHeap(&heap1,
 8003e8a:	4926      	ldr	r1, [pc, #152]	; (8003f24 <dyn1_execute.lto_priv.111+0xd4>)
  threads[1] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
  p1 = chHeapAlloc(&heap1, n);
 8003e8c:	0007      	movs	r7, r0
  threads[2] = chThdCreateFromHeap(&heap1,
 8003e8e:	1ee8      	subs	r0, r5, #3
 8003e90:	f001 fa0e 	bl	80052b0 <chThdCreateFromHeap.constprop.53>
 8003e94:	60a0      	str	r0, [r4, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 8003e96:	0038      	movs	r0, r7
 8003e98:	f7fd f822 	bl	8000ee0 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 8003e9c:	6823      	ldr	r3, [r4, #0]
 8003e9e:	2b00      	cmp	r3, #0
 8003ea0:	d02c      	beq.n	8003efc <dyn1_execute.lto_priv.111+0xac>
 8003ea2:	6863      	ldr	r3, [r4, #4]
 8003ea4:	2100      	movs	r1, #0
 8003ea6:	2b00      	cmp	r3, #0
 8003ea8:	d002      	beq.n	8003eb0 <dyn1_execute.lto_priv.111+0x60>
 8003eaa:	68a3      	ldr	r3, [r4, #8]
 8003eac:	2b00      	cmp	r3, #0
 8003eae:	d027      	beq.n	8003f00 <dyn1_execute.lto_priv.111+0xb0>
 8003eb0:	2001      	movs	r0, #1
 8003eb2:	f7fc fb85 	bl	80005c0 <_test_assert>
 8003eb6:	2800      	cmp	r0, #0
 8003eb8:	d001      	beq.n	8003ebe <dyn1_execute.lto_priv.111+0x6e>
  test_assert_sequence(2, "AB");

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
  test_assert(4, n == sz, "heap size changed");
}
 8003eba:	b003      	add	sp, #12
 8003ebc:	bdf0      	pop	{r4, r5, r6, r7, pc}
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 8003ebe:	f7fd f89f 	bl	8001000 <test_wait_threads>
  test_assert_sequence(2, "AB");
 8003ec2:	4919      	ldr	r1, [pc, #100]	; (8003f28 <dyn1_execute.lto_priv.111+0xd8>)
 8003ec4:	2002      	movs	r0, #2
 8003ec6:	f7fc fb4b 	bl	8000560 <_test_assert_sequence>
 8003eca:	2800      	cmp	r0, #0
 8003ecc:	d1f5      	bne.n	8003eba <dyn1_execute.lto_priv.111+0x6a>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 8003ece:	a901      	add	r1, sp, #4
 8003ed0:	0030      	movs	r0, r6
 8003ed2:	f7fc ffdd 	bl	8000e90 <chHeapStatus>
 8003ed6:	3801      	subs	r0, #1
 8003ed8:	4241      	negs	r1, r0
 8003eda:	4141      	adcs	r1, r0
 8003edc:	2003      	movs	r0, #3
 8003ede:	b2c9      	uxtb	r1, r1
 8003ee0:	f7fc fb6e 	bl	80005c0 <_test_assert>
 8003ee4:	2800      	cmp	r0, #0
 8003ee6:	d1e8      	bne.n	8003eba <dyn1_execute.lto_priv.111+0x6a>
  test_assert(4, n == sz, "heap size changed");
 8003ee8:	9b01      	ldr	r3, [sp, #4]
 8003eea:	9a00      	ldr	r2, [sp, #0]
 8003eec:	3004      	adds	r0, #4
 8003eee:	1a99      	subs	r1, r3, r2
 8003ef0:	424a      	negs	r2, r1
 8003ef2:	414a      	adcs	r2, r1
 8003ef4:	b2d1      	uxtb	r1, r2
 8003ef6:	f7fc fb63 	bl	80005c0 <_test_assert>
 8003efa:	e7de      	b.n	8003eba <dyn1_execute.lto_priv.111+0x6a>
  threads[2] = chThdCreateFromHeap(&heap1,
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);

  test_assert(1, (threads[0] != NULL) &&
 8003efc:	2100      	movs	r1, #0
 8003efe:	e7d7      	b.n	8003eb0 <dyn1_execute.lto_priv.111+0x60>
 8003f00:	68e3      	ldr	r3, [r4, #12]
 8003f02:	2b00      	cmp	r3, #0
 8003f04:	d1d4      	bne.n	8003eb0 <dyn1_execute.lto_priv.111+0x60>
 8003f06:	6923      	ldr	r3, [r4, #16]
 8003f08:	4259      	negs	r1, r3
 8003f0a:	4159      	adcs	r1, r3
 8003f0c:	b2c9      	uxtb	r1, r1
 8003f0e:	e7cf      	b.n	8003eb0 <dyn1_execute.lto_priv.111+0x60>
 8003f10:	20000ac0 	.word	0x20000ac0
 8003f14:	20000c38 	.word	0x20000c38
 8003f18:	080064d4 	.word	0x080064d4
 8003f1c:	20000a28 	.word	0x20000a28
 8003f20:	080064d0 	.word	0x080064d0
 8003f24:	080064dc 	.word	0x080064dc
 8003f28:	08006510 	.word	0x08006510
 8003f2c:	00000000 	.word	0x00000000

08003f30 <heap1_execute.lto_priv.107>:

static void heap1_execute(void) {
 8003f30:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003f32:	b083      	sub	sp, #12

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 8003f34:	4669      	mov	r1, sp
 8003f36:	2000      	movs	r0, #0
 8003f38:	f7fc ffaa 	bl	8000e90 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 8003f3c:	2110      	movs	r1, #16
 8003f3e:	2000      	movs	r0, #0
 8003f40:	f7fd f876 	bl	8001030 <chHeapAlloc>
  test_assert(1, p1 != NULL, "allocation failed");
 8003f44:	0001      	movs	r1, r0
 8003f46:	1e4b      	subs	r3, r1, #1
 8003f48:	4199      	sbcs	r1, r3
  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
 8003f4a:	0004      	movs	r4, r0
  test_assert(1, p1 != NULL, "allocation failed");
 8003f4c:	b2c9      	uxtb	r1, r1
 8003f4e:	2001      	movs	r0, #1
 8003f50:	f7fc fb36 	bl	80005c0 <_test_assert>
 8003f54:	2800      	cmp	r0, #0
 8003f56:	d001      	beq.n	8003f5c <heap1_execute.lto_priv.107+0x2c>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
  chHeapFree(p1);

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
  test_assert(12, n == sz, "size changed");
}
 8003f58:	b003      	add	sp, #12
 8003f5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
  p1 = chHeapAlloc(NULL, SIZE);
  test_assert(1, p1 != NULL, "allocation failed");
  chHeapFree(p1);
 8003f5c:	0020      	movs	r0, r4
 8003f5e:	f7fc ffbf 	bl	8000ee0 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 8003f62:	4982      	ldr	r1, [pc, #520]	; (800416c <heap1_execute.lto_priv.107+0x23c>)
 8003f64:	2000      	movs	r0, #0
 8003f66:	f7fd f863 	bl	8001030 <chHeapAlloc>
  test_assert(2, p1 == NULL, "allocation not failed");
 8003f6a:	4241      	negs	r1, r0
 8003f6c:	4141      	adcs	r1, r0
 8003f6e:	2002      	movs	r0, #2
 8003f70:	b2c9      	uxtb	r1, r1
 8003f72:	f7fc fb25 	bl	80005c0 <_test_assert>
 8003f76:	2800      	cmp	r0, #0
 8003f78:	d1ee      	bne.n	8003f58 <heap1_execute.lto_priv.107+0x28>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 8003f7a:	4c7d      	ldr	r4, [pc, #500]	; (8004170 <heap1_execute.lto_priv.107+0x240>)
 8003f7c:	4669      	mov	r1, sp
 8003f7e:	0020      	movs	r0, r4
 8003f80:	f7fc ff86 	bl	8000e90 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8003f84:	2110      	movs	r1, #16
 8003f86:	0020      	movs	r0, r4
 8003f88:	f7fd f852 	bl	8001030 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8003f8c:	2110      	movs	r1, #16

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8003f8e:	0007      	movs	r7, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8003f90:	0020      	movs	r0, r4
 8003f92:	f7fd f84d 	bl	8001030 <chHeapAlloc>
  p3 = chHeapAlloc(&test_heap, SIZE);
 8003f96:	2110      	movs	r1, #16
  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
  p2 = chHeapAlloc(&test_heap, SIZE);
 8003f98:	0006      	movs	r6, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8003f9a:	0020      	movs	r0, r4
 8003f9c:	f7fd f848 	bl	8001030 <chHeapAlloc>
 8003fa0:	0005      	movs	r5, r0
  chHeapFree(p1);                               /* Does not merge.*/
 8003fa2:	0038      	movs	r0, r7
 8003fa4:	f7fc ff9c 	bl	8000ee0 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 8003fa8:	0030      	movs	r0, r6
 8003faa:	f7fc ff99 	bl	8000ee0 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 8003fae:	0028      	movs	r0, r5
 8003fb0:	f7fc ff96 	bl	8000ee0 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8003fb4:	a901      	add	r1, sp, #4
 8003fb6:	0020      	movs	r0, r4
 8003fb8:	f7fc ff6a 	bl	8000e90 <chHeapStatus>
 8003fbc:	3801      	subs	r0, #1
 8003fbe:	4241      	negs	r1, r0
 8003fc0:	4141      	adcs	r1, r0
 8003fc2:	2003      	movs	r0, #3
 8003fc4:	b2c9      	uxtb	r1, r1
 8003fc6:	f7fc fafb 	bl	80005c0 <_test_assert>
 8003fca:	2800      	cmp	r0, #0
 8003fcc:	d1c4      	bne.n	8003f58 <heap1_execute.lto_priv.107+0x28>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8003fce:	2110      	movs	r1, #16
 8003fd0:	0020      	movs	r0, r4
 8003fd2:	f7fd f82d 	bl	8001030 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 8003fd6:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges backward.*/
  chHeapFree(p3);                               /* Merges both sides.*/
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 8003fd8:	0005      	movs	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8003fda:	0020      	movs	r0, r4
 8003fdc:	f7fd f828 	bl	8001030 <chHeapAlloc>
 8003fe0:	0006      	movs	r6, r0
  p3 = chHeapAlloc(&test_heap, SIZE);
 8003fe2:	2110      	movs	r1, #16
 8003fe4:	0020      	movs	r0, r4
 8003fe6:	f7fd f823 	bl	8001030 <chHeapAlloc>
  chHeapFree(p3);                               /* Merges forward.*/
 8003fea:	f7fc ff79 	bl	8000ee0 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 8003fee:	0030      	movs	r0, r6
 8003ff0:	f7fc ff76 	bl	8000ee0 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 8003ff4:	0028      	movs	r0, r5
 8003ff6:	f7fc ff73 	bl	8000ee0 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 8003ffa:	a901      	add	r1, sp, #4
 8003ffc:	0020      	movs	r0, r4
 8003ffe:	f7fc ff47 	bl	8000e90 <chHeapStatus>
 8004002:	3801      	subs	r0, #1
 8004004:	4241      	negs	r1, r0
 8004006:	4141      	adcs	r1, r0
 8004008:	2004      	movs	r0, #4
 800400a:	b2c9      	uxtb	r1, r1
 800400c:	f7fc fad8 	bl	80005c0 <_test_assert>
 8004010:	2800      	cmp	r0, #0
 8004012:	d1a1      	bne.n	8003f58 <heap1_execute.lto_priv.107+0x28>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 8004014:	2111      	movs	r1, #17
 8004016:	0020      	movs	r0, r4
 8004018:	f7fd f80a 	bl	8001030 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 800401c:	2110      	movs	r1, #16
  chHeapFree(p2);                               /* Merges forward.*/
  chHeapFree(p1);                               /* Merges forward.*/
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 800401e:	0005      	movs	r5, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 8004020:	0020      	movs	r0, r4
 8004022:	f7fd f805 	bl	8001030 <chHeapAlloc>
 8004026:	0006      	movs	r6, r0
  chHeapFree(p1);
 8004028:	0028      	movs	r0, r5
 800402a:	f7fc ff59 	bl	8000ee0 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800402e:	a901      	add	r1, sp, #4
 8004030:	0020      	movs	r0, r4
 8004032:	f7fc ff2d 	bl	8000e90 <chHeapStatus>
 8004036:	3802      	subs	r0, #2
 8004038:	4241      	negs	r1, r0
 800403a:	4141      	adcs	r1, r0
 800403c:	2005      	movs	r0, #5
 800403e:	b2c9      	uxtb	r1, r1
 8004040:	f7fc fabe 	bl	80005c0 <_test_assert>
 8004044:	2800      	cmp	r0, #0
 8004046:	d000      	beq.n	800404a <heap1_execute.lto_priv.107+0x11a>
 8004048:	e786      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>
  p1 = chHeapAlloc(&test_heap, SIZE);
 800404a:	2110      	movs	r1, #16
 800404c:	0020      	movs	r0, r4
 800404e:	f7fc ffef 	bl	8001030 <chHeapAlloc>
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004052:	a901      	add	r1, sp, #4
  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
  p2 = chHeapAlloc(&test_heap, SIZE);
  chHeapFree(p1);
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
  p1 = chHeapAlloc(&test_heap, SIZE);
 8004054:	0005      	movs	r5, r0
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 8004056:	0020      	movs	r0, r4
 8004058:	f7fc ff1a 	bl	8000e90 <chHeapStatus>
 800405c:	2101      	movs	r1, #1
 800405e:	2801      	cmp	r0, #1
 8004060:	d007      	beq.n	8004072 <heap1_execute.lto_priv.107+0x142>
 8004062:	a901      	add	r1, sp, #4
 8004064:	0020      	movs	r0, r4
 8004066:	f7fc ff13 	bl	8000e90 <chHeapStatus>
 800406a:	1e81      	subs	r1, r0, #2
 800406c:	4248      	negs	r0, r1
 800406e:	4141      	adcs	r1, r0
 8004070:	b2c9      	uxtb	r1, r1
 8004072:	2006      	movs	r0, #6
 8004074:	f7fc faa4 	bl	80005c0 <_test_assert>
 8004078:	2800      	cmp	r0, #0
 800407a:	d000      	beq.n	800407e <heap1_execute.lto_priv.107+0x14e>
 800407c:	e76c      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 800407e:	0030      	movs	r0, r6
 8004080:	f7fc ff2e 	bl	8000ee0 <chHeapFree>
  chHeapFree(p1);
 8004084:	0028      	movs	r0, r5
 8004086:	f7fc ff2b 	bl	8000ee0 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800408a:	a901      	add	r1, sp, #4
 800408c:	0020      	movs	r0, r4
 800408e:	f7fc feff 	bl	8000e90 <chHeapStatus>
 8004092:	1e41      	subs	r1, r0, #1
 8004094:	4248      	negs	r0, r1
 8004096:	4141      	adcs	r1, r0
 8004098:	2007      	movs	r0, #7
 800409a:	b2c9      	uxtb	r1, r1
 800409c:	f7fc fa90 	bl	80005c0 <_test_assert>
 80040a0:	2800      	cmp	r0, #0
 80040a2:	d000      	beq.n	80040a6 <heap1_execute.lto_priv.107+0x176>
 80040a4:	e758      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 80040a6:	2110      	movs	r1, #16
 80040a8:	0020      	movs	r0, r4
 80040aa:	f7fc ffc1 	bl	8001030 <chHeapAlloc>
  p2 = chHeapAlloc(&test_heap, SIZE);
 80040ae:	2110      	movs	r1, #16
  chHeapFree(p2);
  chHeapFree(p1);
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 80040b0:	0006      	movs	r6, r0
  p2 = chHeapAlloc(&test_heap, SIZE);
 80040b2:	0020      	movs	r0, r4
 80040b4:	f7fc ffbc 	bl	8001030 <chHeapAlloc>
 80040b8:	0005      	movs	r5, r0
  chHeapFree(p1);
 80040ba:	0030      	movs	r0, r6
 80040bc:	f7fc ff10 	bl	8000ee0 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 80040c0:	a901      	add	r1, sp, #4
 80040c2:	0020      	movs	r0, r4
 80040c4:	f7fc fee4 	bl	8000e90 <chHeapStatus>
 80040c8:	1e81      	subs	r1, r0, #2
 80040ca:	4248      	negs	r0, r1
 80040cc:	4141      	adcs	r1, r0
 80040ce:	2008      	movs	r0, #8
 80040d0:	b2c9      	uxtb	r1, r1
 80040d2:	f7fc fa75 	bl	80005c0 <_test_assert>
 80040d6:	2800      	cmp	r0, #0
 80040d8:	d000      	beq.n	80040dc <heap1_execute.lto_priv.107+0x1ac>
 80040da:	e73d      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 80040dc:	2120      	movs	r1, #32
 80040de:	0020      	movs	r0, r4
 80040e0:	f7fc ffa6 	bl	8001030 <chHeapAlloc>
  chHeapFree(p1);
 80040e4:	f7fc fefc 	bl	8000ee0 <chHeapFree>
  chHeapFree(p2);
 80040e8:	0028      	movs	r0, r5
 80040ea:	f7fc fef9 	bl	8000ee0 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 80040ee:	a901      	add	r1, sp, #4
 80040f0:	0020      	movs	r0, r4
 80040f2:	f7fc fecd 	bl	8000e90 <chHeapStatus>
 80040f6:	1e41      	subs	r1, r0, #1
 80040f8:	4248      	negs	r0, r1
 80040fa:	4141      	adcs	r1, r0
 80040fc:	2009      	movs	r0, #9
 80040fe:	b2c9      	uxtb	r1, r1
 8004100:	f7fc fa5e 	bl	80005c0 <_test_assert>
 8004104:	2800      	cmp	r0, #0
 8004106:	d000      	beq.n	800410a <heap1_execute.lto_priv.107+0x1da>
 8004108:	e726      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800410a:	a901      	add	r1, sp, #4
 800410c:	0020      	movs	r0, r4
 800410e:	f7fc febf 	bl	8000e90 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 8004112:	9901      	ldr	r1, [sp, #4]
 8004114:	0020      	movs	r0, r4
 8004116:	f7fc ff8b 	bl	8001030 <chHeapAlloc>
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800411a:	a901      	add	r1, sp, #4
  chHeapFree(p2);
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
  p1 = chHeapAlloc(&test_heap, n);
 800411c:	0005      	movs	r5, r0
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800411e:	0020      	movs	r0, r4
 8004120:	f7fc feb6 	bl	8000e90 <chHeapStatus>
 8004124:	4241      	negs	r1, r0
 8004126:	4141      	adcs	r1, r0
 8004128:	200a      	movs	r0, #10
 800412a:	b2c9      	uxtb	r1, r1
 800412c:	f7fc fa48 	bl	80005c0 <_test_assert>
 8004130:	2800      	cmp	r0, #0
 8004132:	d000      	beq.n	8004136 <heap1_execute.lto_priv.107+0x206>
 8004134:	e710      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>
  chHeapFree(p1);
 8004136:	0028      	movs	r0, r5
 8004138:	f7fc fed2 	bl	8000ee0 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800413c:	a901      	add	r1, sp, #4
 800413e:	0020      	movs	r0, r4
 8004140:	f7fc fea6 	bl	8000e90 <chHeapStatus>
 8004144:	1e41      	subs	r1, r0, #1
 8004146:	4248      	negs	r0, r1
 8004148:	4141      	adcs	r1, r0
 800414a:	200b      	movs	r0, #11
 800414c:	b2c9      	uxtb	r1, r1
 800414e:	f7fc fa37 	bl	80005c0 <_test_assert>
 8004152:	2800      	cmp	r0, #0
 8004154:	d000      	beq.n	8004158 <heap1_execute.lto_priv.107+0x228>
 8004156:	e6ff      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>
  test_assert(12, n == sz, "size changed");
 8004158:	9b01      	ldr	r3, [sp, #4]
 800415a:	9a00      	ldr	r2, [sp, #0]
 800415c:	300c      	adds	r0, #12
 800415e:	1a99      	subs	r1, r3, r2
 8004160:	424b      	negs	r3, r1
 8004162:	4159      	adcs	r1, r3
 8004164:	b2c9      	uxtb	r1, r1
 8004166:	f7fc fa2b 	bl	80005c0 <_test_assert>
 800416a:	e6f5      	b.n	8003f58 <heap1_execute.lto_priv.107+0x28>
 800416c:	ffffff00 	.word	0xffffff00
 8004170:	20000aa0 	.word	0x20000aa0
	...

08004180 <thread.lto_priv.57>:
 8004180:	b510      	push	{r4, lr}
 8004182:	f7fe fc15 	bl	80029b0 <thread.lto_priv.132>
 8004186:	bd10      	pop	{r4, pc}
	...

08004190 <pools1_execute.lto_priv.109>:

static void pools1_execute(void) {
 8004190:	b570      	push	{r4, r5, r6, lr}
 8004192:	4e2f      	ldr	r6, [pc, #188]	; (8004250 <pools1_execute.lto_priv.109+0xc0>)
 8004194:	2205      	movs	r2, #5
 8004196:	0033      	movs	r3, r6
 8004198:	4c2e      	ldr	r4, [pc, #184]	; (8004254 <pools1_execute.lto_priv.109+0xc4>)
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800419a:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 800419c:	6821      	ldr	r1, [r4, #0]
  mp->mp_next = php;
 800419e:	6023      	str	r3, [r4, #0]
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 80041a0:	6019      	str	r1, [r3, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80041a2:	b662      	cpsie	i
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 80041a4:	6861      	ldr	r1, [r4, #4]
 80041a6:	3a01      	subs	r2, #1
 80041a8:	468c      	mov	ip, r1
 80041aa:	4463      	add	r3, ip
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 80041ac:	2a00      	cmp	r2, #0
 80041ae:	d1f4      	bne.n	800419a <pools1_execute.lto_priv.109+0xa>
 80041b0:	2505      	movs	r5, #5
  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 80041b2:	0020      	movs	r0, r4
 80041b4:	f7fc faf4 	bl	80007a0 <chPoolAlloc>
 80041b8:	1e41      	subs	r1, r0, #1
 80041ba:	4188      	sbcs	r0, r1
 80041bc:	b2c1      	uxtb	r1, r0
 80041be:	2001      	movs	r0, #1
 80041c0:	f7fc f9fe 	bl	80005c0 <_test_assert>
 80041c4:	2800      	cmp	r0, #0
 80041c6:	d133      	bne.n	8004230 <pools1_execute.lto_priv.109+0xa0>
 80041c8:	3d01      	subs	r5, #1

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 80041ca:	2d00      	cmp	r5, #0
 80041cc:	d1f1      	bne.n	80041b2 <pools1_execute.lto_priv.109+0x22>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 80041ce:	0020      	movs	r0, r4
 80041d0:	f7fc fae6 	bl	80007a0 <chPoolAlloc>
 80041d4:	4241      	negs	r1, r0
 80041d6:	4141      	adcs	r1, r0
 80041d8:	2002      	movs	r0, #2
 80041da:	b2c9      	uxtb	r1, r1
 80041dc:	f7fc f9f0 	bl	80005c0 <_test_assert>
 80041e0:	2800      	cmp	r0, #0
 80041e2:	d125      	bne.n	8004230 <pools1_execute.lto_priv.109+0xa0>
 80041e4:	0033      	movs	r3, r6
 80041e6:	4a1c      	ldr	r2, [pc, #112]	; (8004258 <pools1_execute.lto_priv.109+0xc8>)
 80041e8:	e000      	b.n	80041ec <pools1_execute.lto_priv.109+0x5c>
 80041ea:	5953      	ldr	r3, [r2, r5]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80041ec:	b672      	cpsid	i
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 80041ee:	6821      	ldr	r1, [r4, #0]
 80041f0:	6019      	str	r1, [r3, #0]
  mp->mp_next = php;
 80041f2:	6023      	str	r3, [r4, #0]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80041f4:	b662      	cpsie	i
 80041f6:	3504      	adds	r5, #4

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 80041f8:	2d14      	cmp	r5, #20
 80041fa:	d1f6      	bne.n	80041ea <pools1_execute.lto_priv.109+0x5a>
 80041fc:	2505      	movs	r5, #5
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 80041fe:	0020      	movs	r0, r4
 8004200:	f7fc face 	bl	80007a0 <chPoolAlloc>
 8004204:	1e41      	subs	r1, r0, #1
 8004206:	4188      	sbcs	r0, r1
 8004208:	b2c1      	uxtb	r1, r0
 800420a:	2003      	movs	r0, #3
 800420c:	f7fc f9d8 	bl	80005c0 <_test_assert>
 8004210:	2800      	cmp	r0, #0
 8004212:	d10d      	bne.n	8004230 <pools1_execute.lto_priv.109+0xa0>
 8004214:	3d01      	subs	r5, #1
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 8004216:	2d00      	cmp	r5, #0
 8004218:	d1f1      	bne.n	80041fe <pools1_execute.lto_priv.109+0x6e>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 800421a:	0020      	movs	r0, r4
 800421c:	f7fc fac0 	bl	80007a0 <chPoolAlloc>
 8004220:	4241      	negs	r1, r0
 8004222:	4141      	adcs	r1, r0
 8004224:	2004      	movs	r0, #4
 8004226:	b2c9      	uxtb	r1, r1
 8004228:	f7fc f9ca 	bl	80005c0 <_test_assert>
 800422c:	2800      	cmp	r0, #0
 800422e:	d000      	beq.n	8004232 <pools1_execute.lto_priv.109+0xa2>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
}
 8004230:	bd70      	pop	{r4, r5, r6, pc}
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
  mp->mp_object_size = size;
 8004232:	2310      	movs	r3, #16
 8004234:	6063      	str	r3, [r4, #4]
  mp->mp_provider = provider;
 8004236:	4b09      	ldr	r3, [pc, #36]	; (800425c <pools1_execute.lto_priv.109+0xcc>)
  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8004238:	0020      	movs	r0, r4
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 800423a:	6025      	str	r5, [r4, #0]
  mp->mp_object_size = size;
  mp->mp_provider = provider;
 800423c:	60a3      	str	r3, [r4, #8]
 800423e:	f7fc faaf 	bl	80007a0 <chPoolAlloc>
 8004242:	4241      	negs	r1, r0
 8004244:	4141      	adcs	r1, r0
 8004246:	2005      	movs	r0, #5
 8004248:	b2c9      	uxtb	r1, r1
 800424a:	f7fc f9b9 	bl	80005c0 <_test_assert>
 800424e:	e7ef      	b.n	8004230 <pools1_execute.lto_priv.109+0xa0>
 8004250:	20000c58 	.word	0x20000c58
 8004254:	20000648 	.word	0x20000648
 8004258:	080064b0 	.word	0x080064b0
 800425c:	08003df1 	.word	0x08003df1

08004260 <evt3_execute.lto_priv.105>:
static void evt3_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void evt3_execute(void) {
 8004260:	b570      	push	{r4, r5, r6, lr}
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8004262:	4c48      	ldr	r4, [pc, #288]	; (8004384 <evt3_execute.lto_priv.105+0x124>)
 8004264:	69a2      	ldr	r2, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004266:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 8004268:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800426a:	2b00      	cmp	r3, #0
 800426c:	d107      	bne.n	800427e <evt3_execute.lto_priv.105+0x1e>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800426e:	b662      	cpsie	i
 8004270:	2101      	movs	r1, #1

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
 8004272:	2001      	movs	r0, #1
 8004274:	f7fc f9a4 	bl	80005c0 <_test_assert>
 8004278:	2800      	cmp	r0, #0
 800427a:	d00e      	beq.n	800429a <evt3_execute.lto_priv.105+0x3a>
  test_assert(4, m == 0, "spurious event");
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
}
 800427c:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 800427e:	4259      	negs	r1, r3
 8004280:	4019      	ands	r1, r3
  ctp->p_epending &= ~m;
 8004282:	438b      	bics	r3, r1
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8004284:	0008      	movs	r0, r1
  ctp->p_epending &= ~m;
 8004286:	6353      	str	r3, [r2, #52]	; 0x34
 8004288:	b662      	cpsie	i
 800428a:	4241      	negs	r1, r0
 800428c:	4141      	adcs	r1, r0

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(1, m == 0, "spurious event");
 800428e:	2001      	movs	r0, #1
 8004290:	b2c9      	uxtb	r1, r1
 8004292:	f7fc f995 	bl	80005c0 <_test_assert>
 8004296:	2800      	cmp	r0, #0
 8004298:	d1f0      	bne.n	800427c <evt3_execute.lto_priv.105+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 800429a:	69a3      	ldr	r3, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800429c:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
 800429e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80042a0:	2a00      	cmp	r2, #0
 80042a2:	d05f      	beq.n	8004364 <evt3_execute.lto_priv.105+0x104>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
  }
  ctp->p_epending &= ~m;
 80042a4:	6358      	str	r0, [r3, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042a6:	b662      	cpsie	i
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(2, m == 0, "spurious event");
 80042a8:	0001      	movs	r1, r0
 80042aa:	2002      	movs	r0, #2
 80042ac:	f7fc f988 	bl	80005c0 <_test_assert>
 80042b0:	2800      	cmp	r0, #0
 80042b2:	d1e3      	bne.n	800427c <evt3_execute.lto_priv.105+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80042b4:	69a3      	ldr	r3, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042b6:	b672      	cpsid	i

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80042b8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80042ba:	3201      	adds	r2, #1
 80042bc:	d055      	beq.n	800436a <evt3_execute.lto_priv.105+0x10a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042be:	b662      	cpsie	i
 80042c0:	3001      	adds	r0, #1
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
  test_assert(3, m == 0, "spurious event");
 80042c2:	0001      	movs	r1, r0
 80042c4:	2003      	movs	r0, #3
 80042c6:	f7fc f97b 	bl	80005c0 <_test_assert>
 80042ca:	2800      	cmp	r0, #0
 80042cc:	d1d6      	bne.n	800427c <evt3_execute.lto_priv.105+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80042ce:	69a5      	ldr	r5, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80042d0:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80042d2:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80042d4:	2b00      	cmp	r3, #0
 80042d6:	d108      	bne.n	80042ea <evt3_execute.lto_priv.105+0x8a>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 80042d8:	3b01      	subs	r3, #1
 80042da:	622b      	str	r3, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80042dc:	210a      	movs	r1, #10
 80042de:	300a      	adds	r0, #10
 80042e0:	f7fc ffbe 	bl	8001260 <chSchGoSleepTimeoutS>
 80042e4:	2800      	cmp	r0, #0
 80042e6:	db43      	blt.n	8004370 <evt3_execute.lto_priv.105+0x110>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 80042e8:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80042ea:	4259      	negs	r1, r3
 80042ec:	000a      	movs	r2, r1
 80042ee:	401a      	ands	r2, r3
  ctp->p_epending &= ~m;
 80042f0:	4393      	bics	r3, r2
 80042f2:	636b      	str	r3, [r5, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80042f4:	b662      	cpsie	i
 80042f6:	4251      	negs	r1, r2
 80042f8:	4151      	adcs	r1, r2
 80042fa:	b2c9      	uxtb	r1, r1
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
  test_assert(4, m == 0, "spurious event");
 80042fc:	2004      	movs	r0, #4
 80042fe:	f7fc f95f 	bl	80005c0 <_test_assert>
 8004302:	2800      	cmp	r0, #0
 8004304:	d1ba      	bne.n	800427c <evt3_execute.lto_priv.105+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8004306:	69a5      	ldr	r5, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004308:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 800430a:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800430c:	2b00      	cmp	r3, #0
 800430e:	d108      	bne.n	8004322 <evt3_execute.lto_priv.105+0xc2>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8004310:	3b01      	subs	r3, #1
 8004312:	622b      	str	r3, [r5, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8004314:	210a      	movs	r1, #10
 8004316:	300a      	adds	r0, #10
 8004318:	f7fc ffa2 	bl	8001260 <chSchGoSleepTimeoutS>
 800431c:	2800      	cmp	r0, #0
 800431e:	db2a      	blt.n	8004376 <evt3_execute.lto_priv.105+0x116>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->p_epending & events;
 8004320:	6b6b      	ldr	r3, [r5, #52]	; 0x34
  }
  ctp->p_epending &= ~m;
 8004322:	2200      	movs	r2, #0
 8004324:	636a      	str	r2, [r5, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004326:	b662      	cpsie	i
 8004328:	4259      	negs	r1, r3
 800432a:	4159      	adcs	r1, r3
 800432c:	b2c9      	uxtb	r1, r1
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
  test_assert(5, m == 0, "spurious event");
 800432e:	2005      	movs	r0, #5
 8004330:	f7fc f946 	bl	80005c0 <_test_assert>
 8004334:	1e05      	subs	r5, r0, #0
 8004336:	d1a1      	bne.n	800427c <evt3_execute.lto_priv.105+0x1c>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8004338:	69a4      	ldr	r4, [r4, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800433a:	b672      	cpsid	i

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 800433c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800433e:	3301      	adds	r3, #1
 8004340:	d008      	beq.n	8004354 <evt3_execute.lto_priv.105+0xf4>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->p_u.ewmask = events;
 8004342:	2301      	movs	r3, #1
 8004344:	425b      	negs	r3, r3
 8004346:	6223      	str	r3, [r4, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8004348:	210a      	movs	r1, #10
 800434a:	200b      	movs	r0, #11
 800434c:	f7fc ff88 	bl	8001260 <chSchGoSleepTimeoutS>
 8004350:	2800      	cmp	r0, #0
 8004352:	db13      	blt.n	800437c <evt3_execute.lto_priv.105+0x11c>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->p_epending &= ~events;
 8004354:	2300      	movs	r3, #0
 8004356:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004358:	b662      	cpsie	i
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
  test_assert(6, m == 0, "spurious event");
 800435a:	0029      	movs	r1, r5
 800435c:	2006      	movs	r0, #6
 800435e:	f7fc f92f 	bl	80005c0 <_test_assert>
 8004362:	e78b      	b.n	800427c <evt3_execute.lto_priv.105+0x1c>
 8004364:	b662      	cpsie	i
 8004366:	3001      	adds	r0, #1
 8004368:	e79e      	b.n	80042a8 <evt3_execute.lto_priv.105+0x48>
 800436a:	6358      	str	r0, [r3, #52]	; 0x34
 800436c:	b662      	cpsie	i
 800436e:	e7a8      	b.n	80042c2 <evt3_execute.lto_priv.105+0x62>
 8004370:	b662      	cpsie	i
 8004372:	2101      	movs	r1, #1
 8004374:	e7c2      	b.n	80042fc <evt3_execute.lto_priv.105+0x9c>
 8004376:	b662      	cpsie	i
 8004378:	2101      	movs	r1, #1
 800437a:	e7d8      	b.n	800432e <evt3_execute.lto_priv.105+0xce>
 800437c:	b662      	cpsie	i
 800437e:	3501      	adds	r5, #1
 8004380:	e7eb      	b.n	800435a <evt3_execute.lto_priv.105+0xfa>
 8004382:	46c0      	nop			; (mov r8, r8)
 8004384:	20000ac0 	.word	0x20000ac0
	...

08004390 <evt3_setup.lto_priv.104>:
 8004390:	b510      	push	{r4, lr}
 8004392:	f000 fa7d 	bl	8004890 <evt1_setup.lto_priv.100>
 8004396:	bd10      	pop	{r4, pc}
	...

080043a0 <evt2_setup.lto_priv.102>:
 80043a0:	b510      	push	{r4, lr}
 80043a2:	f000 fa75 	bl	8004890 <evt1_setup.lto_priv.100>
 80043a6:	bd10      	pop	{r4, pc}
	...

080043b0 <evt1_execute.lto_priv.101>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 80043b0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80043b2:	4c31      	ldr	r4, [pc, #196]	; (8004478 <evt1_execute.lto_priv.101+0xc8>)
 80043b4:	b08d      	sub	sp, #52	; 0x34
 80043b6:	6024      	str	r4, [r4, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043b8:	b672      	cpsid	i
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 80043ba:	4930      	ldr	r1, [pc, #192]	; (800447c <evt1_execute.lto_priv.101+0xcc>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80043bc:	6823      	ldr	r3, [r4, #0]
 80043be:	ad07      	add	r5, sp, #28
 80043c0:	9307      	str	r3, [sp, #28]
  esp->es_next     = elp;
  elp->el_listener = currp;
 80043c2:	698b      	ldr	r3, [r1, #24]
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80043c4:	2200      	movs	r2, #0
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 80043c6:	606b      	str	r3, [r5, #4]
  elp->el_events   = events;
 80043c8:	2301      	movs	r3, #1
 80043ca:	60ab      	str	r3, [r5, #8]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80043cc:	3b02      	subs	r3, #2

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 80043ce:	6025      	str	r5, [r4, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80043d0:	60ea      	str	r2, [r5, #12]
  elp->el_wflags   = wflags;
 80043d2:	612b      	str	r3, [r5, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80043d4:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043d6:	b672      	cpsid	i
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
 80043d8:	6989      	ldr	r1, [r1, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80043da:	6820      	ldr	r0, [r4, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 80043dc:	9101      	str	r1, [sp, #4]
 80043de:	9103      	str	r1, [sp, #12]
  elp->el_events   = events;
 80043e0:	2102      	movs	r1, #2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80043e2:	9002      	str	r0, [sp, #8]
  esp->es_next     = elp;
 80043e4:	a802      	add	r0, sp, #8
 80043e6:	6020      	str	r0, [r4, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
 80043e8:	9104      	str	r1, [sp, #16]
  elp->el_flags    = (eventflags_t)0;
 80043ea:	9205      	str	r2, [sp, #20]
  elp->el_wflags   = wflags;
 80043ec:	9306      	str	r3, [sp, #24]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80043ee:	b662      	cpsie	i
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 80043f0:	6823      	ldr	r3, [r4, #0]
 80043f2:	2001      	movs	r0, #1
 80043f4:	1b19      	subs	r1, r3, r4
 80043f6:	1e4b      	subs	r3, r1, #1
 80043f8:	4199      	sbcs	r1, r3
 80043fa:	b2c9      	uxtb	r1, r1
 80043fc:	f7fc f8e0 	bl	80005c0 <_test_assert>
 8004400:	2800      	cmp	r0, #0
 8004402:	d001      	beq.n	8004408 <evt1_execute.lto_priv.101+0x58>
  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
}
 8004404:	b00d      	add	sp, #52	; 0x34
 8004406:	bdf0      	pop	{r4, r5, r6, r7, pc}
   */
  chEvtObjectInit(&es1);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es1, &el2, 2);
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
  chEvtUnregister(&es1, &el1);
 8004408:	0029      	movs	r1, r5
 800440a:	0020      	movs	r0, r4
 800440c:	f7fc f9d8 	bl	80007c0 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 8004410:	6823      	ldr	r3, [r4, #0]
 8004412:	2002      	movs	r0, #2
 8004414:	1b19      	subs	r1, r3, r4
 8004416:	1e4b      	subs	r3, r1, #1
 8004418:	4199      	sbcs	r1, r3
 800441a:	b2c9      	uxtb	r1, r1
 800441c:	f7fc f8d0 	bl	80005c0 <_test_assert>
 8004420:	2800      	cmp	r0, #0
 8004422:	d1ef      	bne.n	8004404 <evt1_execute.lto_priv.101+0x54>
  chEvtUnregister(&es1, &el2);
 8004424:	0020      	movs	r0, r4
 8004426:	a902      	add	r1, sp, #8
 8004428:	f7fc f9ca 	bl	80007c0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800442c:	6823      	ldr	r3, [r4, #0]
 800442e:	2003      	movs	r0, #3
 8004430:	1b19      	subs	r1, r3, r4
 8004432:	424b      	negs	r3, r1
 8004434:	414b      	adcs	r3, r1
 8004436:	b2d9      	uxtb	r1, r3
 8004438:	f7fc f8c2 	bl	80005c0 <_test_assert>
 800443c:	2800      	cmp	r0, #0
 800443e:	d1e1      	bne.n	8004404 <evt1_execute.lto_priv.101+0x54>
 8004440:	2507      	movs	r5, #7
 8004442:	2400      	movs	r4, #0

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004444:	2601      	movs	r6, #1
 8004446:	4f0e      	ldr	r7, [pc, #56]	; (8004480 <evt1_execute.lto_priv.101+0xd0>)
 8004448:	002b      	movs	r3, r5
 800444a:	40e3      	lsrs	r3, r4
 800444c:	421e      	tst	r6, r3
 800444e:	d104      	bne.n	800445a <evt1_execute.lto_priv.101+0xaa>
 8004450:	002b      	movs	r3, r5
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 8004452:	3401      	adds	r4, #1

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8004454:	40e3      	lsrs	r3, r4
 8004456:	421e      	tst	r6, r3
 8004458:	d0fa      	beq.n	8004450 <evt1_execute.lto_priv.101+0xa0>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800445a:	0033      	movs	r3, r6
 800445c:	40a3      	lsls	r3, r4
 800445e:	439d      	bics	r5, r3
      handlers[eid](eid);
 8004460:	00a3      	lsls	r3, r4, #2
 8004462:	0020      	movs	r0, r4
 8004464:	58fb      	ldr	r3, [r7, r3]
 8004466:	4798      	blx	r3
    }
    eid++;
 8004468:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 800446a:	2d00      	cmp	r5, #0
 800446c:	d1ec      	bne.n	8004448 <evt1_execute.lto_priv.101+0x98>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
  test_assert_sequence(4, "ABC");
 800446e:	4905      	ldr	r1, [pc, #20]	; (8004484 <evt1_execute.lto_priv.101+0xd4>)
 8004470:	2004      	movs	r0, #4
 8004472:	f7fc f875 	bl	8000560 <_test_assert_sequence>
 8004476:	e7c5      	b.n	8004404 <evt1_execute.lto_priv.101+0x54>
 8004478:	20000654 	.word	0x20000654
 800447c:	20000ac0 	.word	0x20000ac0
 8004480:	08006520 	.word	0x08006520
 8004484:	08006514 	.word	0x08006514
	...

08004490 <evt2_execute.lto_priv.103>:
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
  chEvtBroadcast(&es2);
}

static void evt2_execute(void) {
 8004490:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004492:	465f      	mov	r7, fp
 8004494:	4656      	mov	r6, sl
 8004496:	464d      	mov	r5, r9
 8004498:	4644      	mov	r4, r8
 800449a:	b4f0      	push	{r4, r5, r6, r7}
 800449c:	b08f      	sub	sp, #60	; 0x3c
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800449e:	b672      	cpsid	i
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->p_epending |= events;
 80044a0:	2307      	movs	r3, #7
 80044a2:	4ca8      	ldr	r4, [pc, #672]	; (8004744 <evt2_execute.lto_priv.103+0x2b4>)
 80044a4:	69a2      	ldr	r2, [r4, #24]
 80044a6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80044a8:	430b      	orrs	r3, r1
 80044aa:	6353      	str	r3, [r2, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80044ac:	b662      	cpsie	i

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
 80044ae:	f001 f807 	bl	80054c0 <chEvtWaitOne.constprop.32>
  test_assert(1, m == 1, "single event error");
 80044b2:	3801      	subs	r0, #1
 80044b4:	4241      	negs	r1, r0
 80044b6:	4141      	adcs	r1, r0
 80044b8:	2001      	movs	r0, #1
 80044ba:	b2c9      	uxtb	r1, r1
 80044bc:	f7fc f880 	bl	80005c0 <_test_assert>
 80044c0:	2800      	cmp	r0, #0
 80044c2:	d006      	beq.n	80044d2 <evt2_execute.lto_priv.103+0x42>
  test_wait_threads();
  chEvtUnregister(&es1, &el1);
  chEvtUnregister(&es2, &el2);
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
}
 80044c4:	b00f      	add	sp, #60	; 0x3c
 80044c6:	bc3c      	pop	{r2, r3, r4, r5}
 80044c8:	4690      	mov	r8, r2
 80044ca:	4699      	mov	r9, r3
 80044cc:	46a2      	mov	sl, r4
 80044ce:	46ab      	mov	fp, r5
 80044d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
  m = chEvtWaitOne(ALL_EVENTS);
  test_assert(1, m == 1, "single event error");
  m = chEvtWaitOne(ALL_EVENTS);
 80044d2:	f000 fff5 	bl	80054c0 <chEvtWaitOne.constprop.32>
  test_assert(2, m == 2, "single event error");
 80044d6:	3802      	subs	r0, #2
 80044d8:	4241      	negs	r1, r0
 80044da:	4141      	adcs	r1, r0
 80044dc:	2002      	movs	r0, #2
 80044de:	b2c9      	uxtb	r1, r1
 80044e0:	f7fc f86e 	bl	80005c0 <_test_assert>
 80044e4:	2800      	cmp	r0, #0
 80044e6:	d1ed      	bne.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  m = chEvtWaitOne(ALL_EVENTS);
 80044e8:	f000 ffea 	bl	80054c0 <chEvtWaitOne.constprop.32>
  test_assert(3, m == 4, "single event error");
 80044ec:	1f01      	subs	r1, r0, #4
 80044ee:	424b      	negs	r3, r1
 80044f0:	414b      	adcs	r3, r1
 80044f2:	2003      	movs	r0, #3
 80044f4:	b2d9      	uxtb	r1, r3
 80044f6:	f7fc f863 	bl	80005c0 <_test_assert>
 80044fa:	2800      	cmp	r0, #0
 80044fc:	d1e2      	bne.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80044fe:	f000 ffcf 	bl	80054a0 <chEvtGetAndClearEvents.constprop.36>
  test_assert(4, m == 0, "stuck event");
 8004502:	4241      	negs	r1, r0
 8004504:	4141      	adcs	r1, r0
 8004506:	2004      	movs	r0, #4
 8004508:	b2c9      	uxtb	r1, r1
 800450a:	f7fc f859 	bl	80005c0 <_test_assert>
 800450e:	2800      	cmp	r0, #0
 8004510:	d1d8      	bne.n	80044c4 <evt2_execute.lto_priv.103+0x34>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 8004512:	f7fd f805 	bl	8001520 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004516:	b672      	cpsid	i
 8004518:	2380      	movs	r3, #128	; 0x80
 800451a:	05db      	lsls	r3, r3, #23
 800451c:	4699      	mov	r9, r3
 800451e:	6a5f      	ldr	r7, [r3, #36]	; 0x24
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004520:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8004522:	4a89      	ldr	r2, [pc, #548]	; (8004748 <evt2_execute.lto_priv.103+0x2b8>)
 8004524:	21a4      	movs	r1, #164	; 0xa4
 8004526:	4690      	mov	r8, r2
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004528:	69a3      	ldr	r3, [r4, #24]
 800452a:	4e88      	ldr	r6, [pc, #544]	; (800474c <evt2_execute.lto_priv.103+0x2bc>)
 800452c:	689a      	ldr	r2, [r3, #8]
 800452e:	0049      	lsls	r1, r1, #1
 8004530:	3a01      	subs	r2, #1
 8004532:	9300      	str	r3, [sp, #0]
 8004534:	0030      	movs	r0, r6
 8004536:	4643      	mov	r3, r8
 8004538:	f7fc f9ea 	bl	8000910 <chThdCreateStatic>
 800453c:	4d84      	ldr	r5, [pc, #528]	; (8004750 <evt2_execute.lto_priv.103+0x2c0>)
 800453e:	6028      	str	r0, [r5, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 8004540:	f000 ffbe 	bl	80054c0 <chEvtWaitOne.constprop.32>
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 8004544:	0039      	movs	r1, r7
 8004546:	4b83      	ldr	r3, [pc, #524]	; (8004754 <evt2_execute.lto_priv.103+0x2c4>)
 8004548:	31f5      	adds	r1, #245	; 0xf5
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800454a:	4682      	mov	sl, r0
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800454c:	18fa      	adds	r2, r7, r3
 800454e:	31ff      	adds	r1, #255	; 0xff
 8004550:	2005      	movs	r0, #5
 8004552:	f7fb ffe5 	bl	8000520 <_test_assert_time_window>
 8004556:	2800      	cmp	r0, #0
 8004558:	d1b4      	bne.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  test_assert(6, m == 1, "single event error");
 800455a:	4651      	mov	r1, sl
 800455c:	3901      	subs	r1, #1
 800455e:	424a      	negs	r2, r1
 8004560:	414a      	adcs	r2, r1
 8004562:	3006      	adds	r0, #6
 8004564:	b2d1      	uxtb	r1, r2
 8004566:	f7fc f82b 	bl	80005c0 <_test_assert>
 800456a:	2800      	cmp	r0, #0
 800456c:	d1aa      	bne.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800456e:	f000 ff97 	bl	80054a0 <chEvtGetAndClearEvents.constprop.36>
  test_assert(7, m == 0, "stuck event");
 8004572:	4241      	negs	r1, r0
 8004574:	4141      	adcs	r1, r0
 8004576:	2007      	movs	r0, #7
 8004578:	b2c9      	uxtb	r1, r1
 800457a:	f7fc f821 	bl	80005c0 <_test_assert>
 800457e:	2800      	cmp	r0, #0
 8004580:	d1a0      	bne.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  test_wait_threads();
 8004582:	f7fc fd3d 	bl	8001000 <test_wait_threads>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004586:	b672      	cpsid	i
 8004588:	2305      	movs	r3, #5
 800458a:	69a2      	ldr	r2, [r4, #24]
 800458c:	6b51      	ldr	r1, [r2, #52]	; 0x34
 800458e:	430b      	orrs	r3, r1
 8004590:	6353      	str	r3, [r2, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004592:	b662      	cpsie	i

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
  m = chEvtWaitAny(ALL_EVENTS);
 8004594:	f000 ffac 	bl	80054f0 <chEvtWaitAny.constprop.31>
  test_assert(8, m == 5, "unexpected pending bit");
 8004598:	1f41      	subs	r1, r0, #5
 800459a:	424b      	negs	r3, r1
 800459c:	414b      	adcs	r3, r1
 800459e:	2008      	movs	r0, #8
 80045a0:	b2d9      	uxtb	r1, r3
 80045a2:	f7fc f80d 	bl	80005c0 <_test_assert>
 80045a6:	2800      	cmp	r0, #0
 80045a8:	d000      	beq.n	80045ac <evt2_execute.lto_priv.103+0x11c>
 80045aa:	e78b      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80045ac:	f000 ff78 	bl	80054a0 <chEvtGetAndClearEvents.constprop.36>
  test_assert(9, m == 0, "stuck event");
 80045b0:	4241      	negs	r1, r0
 80045b2:	4141      	adcs	r1, r0
 80045b4:	2009      	movs	r0, #9
 80045b6:	b2c9      	uxtb	r1, r1
 80045b8:	f7fc f802 	bl	80005c0 <_test_assert>
 80045bc:	2800      	cmp	r0, #0
 80045be:	d000      	beq.n	80045c2 <evt2_execute.lto_priv.103+0x132>
 80045c0:	e780      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 80045c2:	f7fc ffad 	bl	8001520 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80045c6:	b672      	cpsid	i
 80045c8:	464b      	mov	r3, r9
 80045ca:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045cc:	4699      	mov	r9, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80045ce:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80045d0:	21a4      	movs	r1, #164	; 0xa4
 80045d2:	69a3      	ldr	r3, [r4, #24]
 80045d4:	0049      	lsls	r1, r1, #1
 80045d6:	689a      	ldr	r2, [r3, #8]
 80045d8:	0030      	movs	r0, r6
 80045da:	3a01      	subs	r2, #1
 80045dc:	9300      	str	r3, [sp, #0]
 80045de:	4643      	mov	r3, r8
 80045e0:	f7fc f996 	bl	8000910 <chThdCreateStatic>
 80045e4:	6028      	str	r0, [r5, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80045e6:	f000 ff83 	bl	80054f0 <chEvtWaitAny.constprop.31>
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80045ea:	4649      	mov	r1, r9
 80045ec:	4a59      	ldr	r2, [pc, #356]	; (8004754 <evt2_execute.lto_priv.103+0x2c4>)
 80045ee:	31f5      	adds	r1, #245	; 0xf5
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 80045f0:	0007      	movs	r7, r0
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 80045f2:	444a      	add	r2, r9
 80045f4:	31ff      	adds	r1, #255	; 0xff
 80045f6:	200a      	movs	r0, #10
 80045f8:	f7fb ff92 	bl	8000520 <_test_assert_time_window>
 80045fc:	2800      	cmp	r0, #0
 80045fe:	d000      	beq.n	8004602 <evt2_execute.lto_priv.103+0x172>
 8004600:	e760      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  test_assert(11, m == 1, "single event error");
 8004602:	1e79      	subs	r1, r7, #1
 8004604:	424b      	negs	r3, r1
 8004606:	414b      	adcs	r3, r1
 8004608:	300b      	adds	r0, #11
 800460a:	b2d9      	uxtb	r1, r3
 800460c:	f7fb ffd8 	bl	80005c0 <_test_assert>
 8004610:	2800      	cmp	r0, #0
 8004612:	d000      	beq.n	8004616 <evt2_execute.lto_priv.103+0x186>
 8004614:	e756      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 8004616:	f000 ff43 	bl	80054a0 <chEvtGetAndClearEvents.constprop.36>
  test_assert(12, m == 0, "stuck event");
 800461a:	4241      	negs	r1, r0
 800461c:	4141      	adcs	r1, r0
 800461e:	200c      	movs	r0, #12
 8004620:	b2c9      	uxtb	r1, r1
 8004622:	f7fb ffcd 	bl	80005c0 <_test_assert>
 8004626:	4683      	mov	fp, r0
 8004628:	2800      	cmp	r0, #0
 800462a:	d000      	beq.n	800462e <evt2_execute.lto_priv.103+0x19e>
 800462c:	e74a      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  test_wait_threads();
 800462e:	f7fc fce7 	bl	8001000 <test_wait_threads>
 8004632:	4b49      	ldr	r3, [pc, #292]	; (8004758 <evt2_execute.lto_priv.103+0x2c8>)
 8004634:	4f49      	ldr	r7, [pc, #292]	; (800475c <evt2_execute.lto_priv.103+0x2cc>)
 8004636:	4698      	mov	r8, r3
 8004638:	601b      	str	r3, [r3, #0]
 800463a:	603f      	str	r7, [r7, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800463c:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800463e:	ab09      	add	r3, sp, #36	; 0x24
 8004640:	469a      	mov	sl, r3
 8004642:	4643      	mov	r3, r8
 8004644:	681b      	ldr	r3, [r3, #0]
  esp->es_next     = elp;
 8004646:	4652      	mov	r2, sl
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8004648:	9309      	str	r3, [sp, #36]	; 0x24
  esp->es_next     = elp;
 800464a:	4643      	mov	r3, r8
 800464c:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800464e:	4653      	mov	r3, sl
 8004650:	69a2      	ldr	r2, [r4, #24]
 8004652:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8004654:	4652      	mov	r2, sl
 8004656:	2301      	movs	r3, #1
 8004658:	6093      	str	r3, [r2, #8]
  elp->el_flags    = (eventflags_t)0;
 800465a:	4653      	mov	r3, sl
 800465c:	465a      	mov	r2, fp
 800465e:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 8004660:	2301      	movs	r3, #1
 8004662:	4652      	mov	r2, sl
 8004664:	425b      	negs	r3, r3
 8004666:	6113      	str	r3, [r2, #16]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004668:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800466a:	b672      	cpsid	i
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 800466c:	aa04      	add	r2, sp, #16
 800466e:	4691      	mov	r9, r2
 8004670:	683a      	ldr	r2, [r7, #0]
  esp->es_next     = elp;
  elp->el_listener = currp;
 8004672:	69a1      	ldr	r1, [r4, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 8004674:	9204      	str	r2, [sp, #16]
  esp->es_next     = elp;
 8004676:	464a      	mov	r2, r9
  elp->el_listener = currp;
 8004678:	6051      	str	r1, [r2, #4]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 800467a:	603a      	str	r2, [r7, #0]
  elp->el_listener = currp;
  elp->el_events   = events;
 800467c:	4649      	mov	r1, r9
 800467e:	2204      	movs	r2, #4
 8004680:	608a      	str	r2, [r1, #8]
  elp->el_flags    = (eventflags_t)0;
 8004682:	464a      	mov	r2, r9
 8004684:	4659      	mov	r1, fp
  elp->el_wflags   = wflags;
 8004686:	6113      	str	r3, [r2, #16]
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 8004688:	60d1      	str	r1, [r2, #12]
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800468a:	b662      	cpsie	i
   */
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
 800468c:	f7fc ff48 	bl	8001520 <test_wait_tick>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004690:	b672      	cpsid	i
 8004692:	2380      	movs	r3, #128	; 0x80
 8004694:	05db      	lsls	r3, r3, #23
 8004696:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004698:	469b      	mov	fp, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800469a:	b662      	cpsie	i
  target_time = chVTGetSystemTime() + MS2ST(50);
 800469c:	23fa      	movs	r3, #250	; 0xfa
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800469e:	21a4      	movs	r1, #164	; 0xa4
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
  chEvtRegisterMask(&es1, &el1, 1);
  chEvtRegisterMask(&es2, &el2, 4);
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
 80046a0:	005b      	lsls	r3, r3, #1
 80046a2:	445b      	add	r3, fp
 80046a4:	9303      	str	r3, [sp, #12]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80046a6:	69a3      	ldr	r3, [r4, #24]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80046a8:	0049      	lsls	r1, r1, #1
 80046aa:	689a      	ldr	r2, [r3, #8]
 80046ac:	4b2c      	ldr	r3, [pc, #176]	; (8004760 <evt2_execute.lto_priv.103+0x2d0>)
 80046ae:	3a01      	subs	r2, #1
 80046b0:	9300      	str	r3, [sp, #0]
 80046b2:	0030      	movs	r0, r6
 80046b4:	4b2b      	ldr	r3, [pc, #172]	; (8004764 <evt2_execute.lto_priv.103+0x2d4>)
 80046b6:	f7fc f92b 	bl	8000910 <chThdCreateStatic>
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 80046ba:	69a4      	ldr	r4, [r4, #24]
 80046bc:	6028      	str	r0, [r5, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80046be:	b672      	cpsid	i

  chSysLock();
  if ((ctp->p_epending & events) != events) {
 80046c0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80046c2:	2205      	movs	r2, #5
 80046c4:	0019      	movs	r1, r3
 80046c6:	4011      	ands	r1, r2
 80046c8:	4291      	cmp	r1, r2
 80046ca:	d004      	beq.n	80046d6 <evt2_execute.lto_priv.103+0x246>
    ctp->p_u.ewmask = events;
 80046cc:	6222      	str	r2, [r4, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80046ce:	200b      	movs	r0, #11
 80046d0:	f7fc f94e 	bl	8000970 <chSchGoSleepS>
 80046d4:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->p_epending &= ~events;
 80046d6:	2205      	movs	r2, #5
 80046d8:	4393      	bics	r3, r2
 80046da:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80046dc:	b662      	cpsie	i
                                 thread2, "A");
  m = chEvtWaitAll(5);
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 80046de:	4a1d      	ldr	r2, [pc, #116]	; (8004754 <evt2_execute.lto_priv.103+0x2c4>)
 80046e0:	9903      	ldr	r1, [sp, #12]
 80046e2:	445a      	add	r2, fp
 80046e4:	200d      	movs	r0, #13
 80046e6:	f7fb ff1b 	bl	8000520 <_test_assert_time_window>
 80046ea:	2800      	cmp	r0, #0
 80046ec:	d000      	beq.n	80046f0 <evt2_execute.lto_priv.103+0x260>
 80046ee:	e6e9      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 80046f0:	f000 fed6 	bl	80054a0 <chEvtGetAndClearEvents.constprop.36>
  test_assert(14, m == 0, "stuck event");
 80046f4:	4241      	negs	r1, r0
 80046f6:	4141      	adcs	r1, r0
 80046f8:	200e      	movs	r0, #14
 80046fa:	b2c9      	uxtb	r1, r1
 80046fc:	f7fb ff60 	bl	80005c0 <_test_assert>
 8004700:	2800      	cmp	r0, #0
 8004702:	d000      	beq.n	8004706 <evt2_execute.lto_priv.103+0x276>
 8004704:	e6de      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  test_wait_threads();
 8004706:	f7fc fc7b 	bl	8001000 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 800470a:	4651      	mov	r1, sl
 800470c:	4640      	mov	r0, r8
 800470e:	f7fc f857 	bl	80007c0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 8004712:	4649      	mov	r1, r9
 8004714:	0038      	movs	r0, r7
 8004716:	f7fc f853 	bl	80007c0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800471a:	4643      	mov	r3, r8
 800471c:	681a      	ldr	r2, [r3, #0]
 800471e:	200f      	movs	r0, #15
 8004720:	1ad1      	subs	r1, r2, r3
 8004722:	424a      	negs	r2, r1
 8004724:	414a      	adcs	r2, r1
 8004726:	b2d1      	uxtb	r1, r2
 8004728:	f7fb ff4a 	bl	80005c0 <_test_assert>
 800472c:	2800      	cmp	r0, #0
 800472e:	d000      	beq.n	8004732 <evt2_execute.lto_priv.103+0x2a2>
 8004730:	e6c8      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 8004732:	683b      	ldr	r3, [r7, #0]
 8004734:	3010      	adds	r0, #16
 8004736:	1bd9      	subs	r1, r3, r7
 8004738:	424b      	negs	r3, r1
 800473a:	414b      	adcs	r3, r1
 800473c:	b2d9      	uxtb	r1, r3
 800473e:	f7fb ff3f 	bl	80005c0 <_test_assert>
 8004742:	e6bf      	b.n	80044c4 <evt2_execute.lto_priv.103+0x34>
 8004744:	20000ac0 	.word	0x20000ac0
 8004748:	080047b1 	.word	0x080047b1
 800474c:	20000c58 	.word	0x20000c58
 8004750:	20000a28 	.word	0x20000a28
 8004754:	00000226 	.word	0x00000226
 8004758:	20000654 	.word	0x20000654
 800475c:	20000658 	.word	0x20000658
 8004760:	080064d4 	.word	0x080064d4
 8004764:	08004771 	.word	0x08004771
	...

08004770 <thread2>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(thread2, p) {
 8004770:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004772:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8004774:	2100      	movs	r1, #0
 8004776:	4809      	ldr	r0, [pc, #36]	; (800479c <thread2+0x2c>)
 8004778:	f7fc f9f2 	bl	8000b60 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800477c:	f7fc f860 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004780:	b662      	cpsie	i

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8004782:	20fa      	movs	r0, #250	; 0xfa
 8004784:	0040      	lsls	r0, r0, #1
 8004786:	f7fc fec3 	bl	8001510 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800478a:	b672      	cpsid	i
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 800478c:	2100      	movs	r1, #0
 800478e:	4804      	ldr	r0, [pc, #16]	; (80047a0 <thread2+0x30>)
 8004790:	f7fc f9e6 	bl	8000b60 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8004794:	f7fc f854 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004798:	b662      	cpsie	i
  chEvtBroadcast(&es2);
}
 800479a:	bd10      	pop	{r4, pc}
 800479c:	20000654 	.word	0x20000654
 80047a0:	20000658 	.word	0x20000658
	...

080047b0 <thread1>:
static void evt2_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static THD_FUNCTION(thread1, p) {
 80047b0:	b510      	push	{r4, lr}
 80047b2:	0004      	movs	r4, r0

  chThdSleepMilliseconds(50);
 80047b4:	20fa      	movs	r0, #250	; 0xfa
 80047b6:	0040      	lsls	r0, r0, #1
 80047b8:	f7fc feaa 	bl	8001510 <chThdSleep>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047bc:	b672      	cpsid	i
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 80047be:	2101      	movs	r1, #1
 80047c0:	0020      	movs	r0, r4
 80047c2:	f7fc f9ad 	bl	8000b20 <chEvtSignalI>
  chSchRescheduleS();
 80047c6:	f7fc f83b 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80047ca:	b662      	cpsie	i
  chEvtSignal((thread_t *)p, 1);
}
 80047cc:	bd10      	pop	{r4, pc}
 80047ce:	46c0      	nop			; (mov r8, r8)

080047d0 <h3>:
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 80047d0:	b510      	push	{r4, lr}
 80047d2:	2043      	movs	r0, #67	; 0x43
 80047d4:	f7fb ff0c 	bl	80005f0 <test_emit_token>
 80047d8:	bd10      	pop	{r4, pc}
 80047da:	46c0      	nop			; (mov r8, r8)
 80047dc:	0000      	movs	r0, r0
	...

080047e0 <h2>:

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 80047e0:	b510      	push	{r4, lr}
 80047e2:	2042      	movs	r0, #66	; 0x42
 80047e4:	f7fb ff04 	bl	80005f0 <test_emit_token>
 80047e8:	bd10      	pop	{r4, pc}
 80047ea:	46c0      	nop			; (mov r8, r8)
 80047ec:	0000      	movs	r0, r0
	...

080047f0 <h1>:
static void evt1_setup(void) {

  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80047f0:	b510      	push	{r4, lr}
 80047f2:	2041      	movs	r0, #65	; 0x41
 80047f4:	f7fb fefc 	bl	80005f0 <test_emit_token>
 80047f8:	bd10      	pop	{r4, pc}
 80047fa:	46c0      	nop			; (mov r8, r8)
 80047fc:	0000      	movs	r0, r0
	...

08004800 <mbox1_setup.lto_priv.98>:
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8004800:	4b09      	ldr	r3, [pc, #36]	; (8004828 <mbox1_setup.lto_priv.98+0x28>)
 8004802:	4a0a      	ldr	r2, [pc, #40]	; (800482c <mbox1_setup.lto_priv.98+0x2c>)
 8004804:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8004806:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8004808:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 800480a:	3214      	adds	r2, #20
 800480c:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800480e:	001a      	movs	r2, r3
 8004810:	321c      	adds	r2, #28
 8004812:	61da      	str	r2, [r3, #28]
  tqp->p_prev = (thread_t *)tqp;
 8004814:	621a      	str	r2, [r3, #32]
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8004816:	2205      	movs	r2, #5
 8004818:	625a      	str	r2, [r3, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800481a:	001a      	movs	r2, r3
 800481c:	3210      	adds	r2, #16
 800481e:	611a      	str	r2, [r3, #16]
  tqp->p_prev = (thread_t *)tqp;
 8004820:	615a      	str	r2, [r3, #20]
 8004822:	2200      	movs	r2, #0
 8004824:	619a      	str	r2, [r3, #24]
 */

static void mbox1_setup(void) {

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
}
 8004826:	4770      	bx	lr
 8004828:	2000067c 	.word	0x2000067c
 800482c:	20000c58 	.word	0x20000c58

08004830 <mtx8_setup.lto_priv.95>:
 8004830:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004832:	4b06      	ldr	r3, [pc, #24]	; (800484c <mtx8_setup.lto_priv.95+0x1c>)
 8004834:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8004836:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004838:	4b05      	ldr	r3, [pc, #20]	; (8004850 <mtx8_setup.lto_priv.95+0x20>)
 800483a:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800483c:	605b      	str	r3, [r3, #4]
 800483e:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004840:	4b04      	ldr	r3, [pc, #16]	; (8004854 <mtx8_setup.lto_priv.95+0x24>)
 8004842:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8004844:	605b      	str	r3, [r3, #4]
 8004846:	609a      	str	r2, [r3, #8]
static void mtx8_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}
 8004848:	4770      	bx	lr
 800484a:	46c0      	nop			; (mov r8, r8)
 800484c:	200006a4 	.word	0x200006a4
 8004850:	2000066c 	.word	0x2000066c
 8004854:	2000065c 	.word	0x2000065c
	...

08004860 <mtx6_setup.lto_priv.91>:
 8004860:	2200      	movs	r2, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004862:	4b04      	ldr	r3, [pc, #16]	; (8004874 <mtx6_setup.lto_priv.91+0x14>)
 8004864:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8004866:	605b      	str	r3, [r3, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8004868:	4b03      	ldr	r3, [pc, #12]	; (8004878 <mtx6_setup.lto_priv.91+0x18>)
 800486a:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800486c:	605b      	str	r3, [r3, #4]
 800486e:	609a      	str	r2, [r3, #8]

static void mtx6_setup(void) {

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}
 8004870:	4770      	bx	lr
 8004872:	46c0      	nop			; (mov r8, r8)
 8004874:	200006a4 	.word	0x200006a4
 8004878:	2000066c 	.word	0x2000066c
 800487c:	00000000 	.word	0x00000000

08004880 <mtx7_setup.lto_priv.93>:
 8004880:	b510      	push	{r4, lr}
 8004882:	f7ff ffed 	bl	8004860 <mtx6_setup.lto_priv.91>
 8004886:	bd10      	pop	{r4, pc}
	...

08004890 <evt1_setup.lto_priv.100>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 8004890:	b510      	push	{r4, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 8004892:	f000 fe05 	bl	80054a0 <chEvtGetAndClearEvents.constprop.36>
}
 8004896:	bd10      	pop	{r4, pc}
	...

080048a0 <mbox1_execute.lto_priv.99>:

static void mbox1_execute(void) {
 80048a0:	b570      	push	{r4, r5, r6, lr}
 80048a2:	b082      	sub	sp, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80048a4:	b672      	cpsid	i
 80048a6:	4d17      	ldr	r5, [pc, #92]	; (8004904 <mbox1_execute.lto_priv.99+0x64>)
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80048a8:	2001      	movs	r0, #1
 80048aa:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80048ac:	1f59      	subs	r1, r3, #5
 80048ae:	424a      	negs	r2, r1
 80048b0:	414a      	adcs	r2, r1
 80048b2:	b2d1      	uxtb	r1, r2
 80048b4:	f7fb fe84 	bl	80005c0 <_test_assert>
 80048b8:	2800      	cmp	r0, #0
 80048ba:	d000      	beq.n	80048be <mbox1_execute.lto_priv.99+0x1e>
 80048bc:	e1f9      	b.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80048be:	b662      	cpsie	i
 80048c0:	2442      	movs	r4, #66	; 0x42

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80048c2:	2101      	movs	r1, #1
 80048c4:	0020      	movs	r0, r4
 80048c6:	4249      	negs	r1, r1
 80048c8:	f000 fe2a 	bl	8005520 <chMBPost.constprop.20>
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 80048cc:	4241      	negs	r1, r0
 80048ce:	4141      	adcs	r1, r0
 80048d0:	2002      	movs	r0, #2
 80048d2:	b2c9      	uxtb	r1, r1
 80048d4:	f7fb fe74 	bl	80005c0 <_test_assert>
 80048d8:	2800      	cmp	r0, #0
 80048da:	d110      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
 80048dc:	3401      	adds	r4, #1
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 80048de:	2c46      	cmp	r4, #70	; 0x46
 80048e0:	d1ef      	bne.n	80048c2 <mbox1_execute.lto_priv.99+0x22>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 80048e2:	2101      	movs	r1, #1
 80048e4:	3041      	adds	r0, #65	; 0x41
 80048e6:	4249      	negs	r1, r1
 80048e8:	f000 fe5a 	bl	80055a0 <chMBPostAhead.constprop.18>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 80048ec:	4241      	negs	r1, r0
 80048ee:	4141      	adcs	r1, r0
 80048f0:	2003      	movs	r0, #3
 80048f2:	b2c9      	uxtb	r1, r1
 80048f4:	f7fb fe64 	bl	80005c0 <_test_assert>
 80048f8:	2800      	cmp	r0, #0
 80048fa:	d100      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
 80048fc:	e1db      	b.n	8004cb6 <mbox1_execute.lto_priv.99+0x416>
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
}
 80048fe:	b002      	add	sp, #8
 8004900:	bd70      	pop	{r4, r5, r6, pc}
 8004902:	46c0      	nop			; (mov r8, r8)
 8004904:	2000067c 	.word	0x2000067c
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 8004908:	4ed5      	ldr	r6, [pc, #852]	; (8004c60 <mbox1_execute.lto_priv.99+0x3c0>)
 800490a:	200c      	movs	r0, #12
 800490c:	0031      	movs	r1, r6
 800490e:	f7fb fe27 	bl	8000560 <_test_assert_sequence>
 8004912:	2800      	cmp	r0, #0
 8004914:	d1f3      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8004916:	2101      	movs	r1, #1
 8004918:	3047      	adds	r0, #71	; 0x47
 800491a:	4249      	negs	r1, r1
 800491c:	f000 fe00 	bl	8005520 <chMBPost.constprop.20>
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 8004920:	4241      	negs	r1, r0
 8004922:	4141      	adcs	r1, r0
 8004924:	200d      	movs	r0, #13
 8004926:	b2c9      	uxtb	r1, r1
 8004928:	f7fb fe4a 	bl	80005c0 <_test_assert>
 800492c:	2800      	cmp	r0, #0
 800492e:	d1e6      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8004930:	2101      	movs	r1, #1
 8004932:	a801      	add	r0, sp, #4
 8004934:	4249      	negs	r1, r1
 8004936:	f000 fe73 	bl	8005620 <chMBFetch.constprop.16>
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800493a:	4241      	negs	r1, r0
 800493c:	4141      	adcs	r1, r0
 800493e:	200e      	movs	r0, #14
 8004940:	b2c9      	uxtb	r1, r1
 8004942:	f7fb fe3d 	bl	80005c0 <_test_assert>
 8004946:	2800      	cmp	r0, #0
 8004948:	d1d9      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800494a:	682b      	ldr	r3, [r5, #0]
 800494c:	68aa      	ldr	r2, [r5, #8]
 800494e:	300f      	adds	r0, #15
 8004950:	1a99      	subs	r1, r3, r2
 8004952:	424a      	negs	r2, r1
 8004954:	414a      	adcs	r2, r1
 8004956:	b2d1      	uxtb	r1, r2
 8004958:	f7fb fe32 	bl	80005c0 <_test_assert>
 800495c:	2800      	cmp	r0, #0
 800495e:	d1ce      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8004960:	682b      	ldr	r3, [r5, #0]
 8004962:	68ea      	ldr	r2, [r5, #12]
 8004964:	3010      	adds	r0, #16
 8004966:	1a99      	subs	r1, r3, r2
 8004968:	424a      	negs	r2, r1
 800496a:	414a      	adcs	r2, r1
 800496c:	b2d1      	uxtb	r1, r2
 800496e:	f7fb fe27 	bl	80005c0 <_test_assert>
 8004972:	2800      	cmp	r0, #0
 8004974:	d1c3      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 8004976:	2101      	movs	r1, #1
 8004978:	a801      	add	r0, sp, #4
 800497a:	f000 fe51 	bl	8005620 <chMBFetch.constprop.16>
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800497e:	1c41      	adds	r1, r0, #1
 8004980:	424b      	negs	r3, r1
 8004982:	414b      	adcs	r3, r1
 8004984:	2011      	movs	r0, #17
 8004986:	b2d9      	uxtb	r1, r3
 8004988:	f7fb fe1a 	bl	80005c0 <_test_assert>
 800498c:	2800      	cmp	r0, #0
 800498e:	d1b6      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004990:	b672      	cpsid	i
  chSysLock();
  msg1 = chMBFetchI(&mb1, &msg2);
 8004992:	a801      	add	r0, sp, #4
 8004994:	f000 fe64 	bl	8005660 <chMBFetchI.constprop.15>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004998:	b662      	cpsie	i
  chSysUnlock();
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800499a:	1c41      	adds	r1, r0, #1
 800499c:	424b      	negs	r3, r1
 800499e:	414b      	adcs	r3, r1
 80049a0:	2012      	movs	r0, #18
 80049a2:	b2d9      	uxtb	r1, r3
 80049a4:	f7fb fe0c 	bl	80005c0 <_test_assert>
 80049a8:	2800      	cmp	r0, #0
 80049aa:	d1a8      	bne.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049ac:	b672      	cpsid	i

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80049ae:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80049b0:	3013      	adds	r0, #19
 80049b2:	1f59      	subs	r1, r3, #5
 80049b4:	424a      	negs	r2, r1
 80049b6:	414a      	adcs	r2, r1
 80049b8:	b2d1      	uxtb	r1, r2
 80049ba:	f7fb fe01 	bl	80005c0 <_test_assert>
 80049be:	2800      	cmp	r0, #0
 80049c0:	d000      	beq.n	80049c4 <mbox1_execute.lto_priv.99+0x124>
 80049c2:	e176      	b.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80049c4:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049c6:	b672      	cpsid	i
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 80049c8:	69a9      	ldr	r1, [r5, #24]
 80049ca:	2014      	movs	r0, #20
 80049cc:	424b      	negs	r3, r1
 80049ce:	4159      	adcs	r1, r3
 80049d0:	b2c9      	uxtb	r1, r1
 80049d2:	f7fb fdf5 	bl	80005c0 <_test_assert>
 80049d6:	2800      	cmp	r0, #0
 80049d8:	d000      	beq.n	80049dc <mbox1_execute.lto_priv.99+0x13c>
 80049da:	e16a      	b.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80049dc:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049de:	b672      	cpsid	i
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 80049e0:	68eb      	ldr	r3, [r5, #12]
 80049e2:	68aa      	ldr	r2, [r5, #8]
 80049e4:	2015      	movs	r0, #21
 80049e6:	1a99      	subs	r1, r3, r2
 80049e8:	424a      	negs	r2, r1
 80049ea:	414a      	adcs	r2, r1
 80049ec:	b2d1      	uxtb	r1, r2
 80049ee:	f7fb fde7 	bl	80005c0 <_test_assert>
 80049f2:	2800      	cmp	r0, #0
 80049f4:	d000      	beq.n	80049f8 <mbox1_execute.lto_priv.99+0x158>
 80049f6:	e15c      	b.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80049f8:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049fa:	b672      	cpsid	i

  /*
   * Testing I-Class.
   */
  chSysLock();
  msg1 = chMBPostI(&mb1, 'A');
 80049fc:	2041      	movs	r0, #65	; 0x41
 80049fe:	f000 fdaf 	bl	8005560 <chMBPostI.constprop.19>
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 8004a02:	4241      	negs	r1, r0
 8004a04:	4141      	adcs	r1, r0
 8004a06:	2016      	movs	r0, #22
 8004a08:	b2c9      	uxtb	r1, r1
 8004a0a:	f7fb fdd9 	bl	80005c0 <_test_assert>
 8004a0e:	2800      	cmp	r0, #0
 8004a10:	d000      	beq.n	8004a14 <mbox1_execute.lto_priv.99+0x174>
 8004a12:	e774      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostI(&mb1, 'B');
 8004a14:	3042      	adds	r0, #66	; 0x42
 8004a16:	f000 fda3 	bl	8005560 <chMBPostI.constprop.19>
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 8004a1a:	4241      	negs	r1, r0
 8004a1c:	4141      	adcs	r1, r0
 8004a1e:	2017      	movs	r0, #23
 8004a20:	b2c9      	uxtb	r1, r1
 8004a22:	f7fb fdcd 	bl	80005c0 <_test_assert>
 8004a26:	2800      	cmp	r0, #0
 8004a28:	d000      	beq.n	8004a2c <mbox1_execute.lto_priv.99+0x18c>
 8004a2a:	e768      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostI(&mb1, 'C');
 8004a2c:	3043      	adds	r0, #67	; 0x43
 8004a2e:	f000 fd97 	bl	8005560 <chMBPostI.constprop.19>
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 8004a32:	4241      	negs	r1, r0
 8004a34:	4141      	adcs	r1, r0
 8004a36:	2018      	movs	r0, #24
 8004a38:	b2c9      	uxtb	r1, r1
 8004a3a:	f7fb fdc1 	bl	80005c0 <_test_assert>
 8004a3e:	2800      	cmp	r0, #0
 8004a40:	d000      	beq.n	8004a44 <mbox1_execute.lto_priv.99+0x1a4>
 8004a42:	e75c      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostI(&mb1, 'D');
 8004a44:	3044      	adds	r0, #68	; 0x44
 8004a46:	f000 fd8b 	bl	8005560 <chMBPostI.constprop.19>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 8004a4a:	4241      	negs	r1, r0
 8004a4c:	4141      	adcs	r1, r0
 8004a4e:	2019      	movs	r0, #25
 8004a50:	b2c9      	uxtb	r1, r1
 8004a52:	f7fb fdb5 	bl	80005c0 <_test_assert>
 8004a56:	2800      	cmp	r0, #0
 8004a58:	d000      	beq.n	8004a5c <mbox1_execute.lto_priv.99+0x1bc>
 8004a5a:	e750      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostI(&mb1, 'E');
 8004a5c:	3045      	adds	r0, #69	; 0x45
 8004a5e:	f000 fd7f 	bl	8005560 <chMBPostI.constprop.19>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004a62:	b662      	cpsie	i
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 8004a64:	4241      	negs	r1, r0
 8004a66:	4141      	adcs	r1, r0
 8004a68:	201a      	movs	r0, #26
 8004a6a:	b2c9      	uxtb	r1, r1
 8004a6c:	f7fb fda8 	bl	80005c0 <_test_assert>
 8004a70:	2800      	cmp	r0, #0
 8004a72:	d000      	beq.n	8004a76 <mbox1_execute.lto_priv.99+0x1d6>
 8004a74:	e743      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004a76:	68eb      	ldr	r3, [r5, #12]
 8004a78:	68aa      	ldr	r2, [r5, #8]
 8004a7a:	301b      	adds	r0, #27
 8004a7c:	1a99      	subs	r1, r3, r2
 8004a7e:	424a      	negs	r2, r1
 8004a80:	414a      	adcs	r2, r1
 8004a82:	b2d1      	uxtb	r1, r2
 8004a84:	f7fb fd9c 	bl	80005c0 <_test_assert>
 8004a88:	2800      	cmp	r0, #0
 8004a8a:	d000      	beq.n	8004a8e <mbox1_execute.lto_priv.99+0x1ee>
 8004a8c:	e737      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
 8004a8e:	2405      	movs	r4, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004a90:	b672      	cpsid	i
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8004a92:	a801      	add	r0, sp, #4
 8004a94:	f000 fde4 	bl	8005660 <chMBFetchI.constprop.15>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004a98:	b662      	cpsie	i
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 8004a9a:	4241      	negs	r1, r0
 8004a9c:	4141      	adcs	r1, r0
 8004a9e:	201c      	movs	r0, #28
 8004aa0:	b2c9      	uxtb	r1, r1
 8004aa2:	f7fb fd8d 	bl	80005c0 <_test_assert>
 8004aa6:	2800      	cmp	r0, #0
 8004aa8:	d000      	beq.n	8004aac <mbox1_execute.lto_priv.99+0x20c>
 8004aaa:	e728      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
    test_emit_token(msg2);
 8004aac:	9b01      	ldr	r3, [sp, #4]
 8004aae:	3c01      	subs	r4, #1
 8004ab0:	b2d8      	uxtb	r0, r3
 8004ab2:	f7fb fd9d 	bl	80005f0 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8004ab6:	2c00      	cmp	r4, #0
 8004ab8:	d1ea      	bne.n	8004a90 <mbox1_execute.lto_priv.99+0x1f0>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 8004aba:	0031      	movs	r1, r6
 8004abc:	201d      	movs	r0, #29
 8004abe:	f7fb fd4f 	bl	8000560 <_test_assert_sequence>
 8004ac2:	2800      	cmp	r0, #0
 8004ac4:	d000      	beq.n	8004ac8 <mbox1_execute.lto_priv.99+0x228>
 8004ac6:	e71a      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004ac8:	b672      	cpsid	i
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004aca:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004acc:	301e      	adds	r0, #30
 8004ace:	1f59      	subs	r1, r3, #5
 8004ad0:	424a      	negs	r2, r1
 8004ad2:	414a      	adcs	r2, r1
 8004ad4:	b2d1      	uxtb	r1, r2
 8004ad6:	f7fb fd73 	bl	80005c0 <_test_assert>
 8004ada:	2800      	cmp	r0, #0
 8004adc:	d000      	beq.n	8004ae0 <mbox1_execute.lto_priv.99+0x240>
 8004ade:	e0e8      	b.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004ae0:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004ae2:	b672      	cpsid	i
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 8004ae4:	69a9      	ldr	r1, [r5, #24]
 8004ae6:	201f      	movs	r0, #31
 8004ae8:	424b      	negs	r3, r1
 8004aea:	4159      	adcs	r1, r3
 8004aec:	b2c9      	uxtb	r1, r1
 8004aee:	f7fb fd67 	bl	80005c0 <_test_assert>
 8004af2:	2800      	cmp	r0, #0
 8004af4:	d000      	beq.n	8004af8 <mbox1_execute.lto_priv.99+0x258>
 8004af6:	e0dc      	b.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004af8:	b662      	cpsie	i
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004afa:	68eb      	ldr	r3, [r5, #12]
 8004afc:	68aa      	ldr	r2, [r5, #8]
 8004afe:	2020      	movs	r0, #32
 8004b00:	1a99      	subs	r1, r3, r2
 8004b02:	424a      	negs	r2, r1
 8004b04:	414a      	adcs	r2, r1
 8004b06:	b2d1      	uxtb	r1, r2
 8004b08:	f7fb fd5a 	bl	80005c0 <_test_assert>
 8004b0c:	2800      	cmp	r0, #0
 8004b0e:	d000      	beq.n	8004b12 <mbox1_execute.lto_priv.99+0x272>
 8004b10:	e6f5      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004b12:	b672      	cpsid	i

  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'E');
 8004b14:	3045      	adds	r0, #69	; 0x45
 8004b16:	f000 fd63 	bl	80055e0 <chMBPostAheadI.constprop.17>
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 8004b1a:	4241      	negs	r1, r0
 8004b1c:	4141      	adcs	r1, r0
 8004b1e:	2021      	movs	r0, #33	; 0x21
 8004b20:	b2c9      	uxtb	r1, r1
 8004b22:	f7fb fd4d 	bl	80005c0 <_test_assert>
 8004b26:	2800      	cmp	r0, #0
 8004b28:	d000      	beq.n	8004b2c <mbox1_execute.lto_priv.99+0x28c>
 8004b2a:	e6e8      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostAheadI(&mb1, 'D');
 8004b2c:	3044      	adds	r0, #68	; 0x44
 8004b2e:	f000 fd57 	bl	80055e0 <chMBPostAheadI.constprop.17>
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 8004b32:	4241      	negs	r1, r0
 8004b34:	4141      	adcs	r1, r0
 8004b36:	2022      	movs	r0, #34	; 0x22
 8004b38:	b2c9      	uxtb	r1, r1
 8004b3a:	f7fb fd41 	bl	80005c0 <_test_assert>
 8004b3e:	2800      	cmp	r0, #0
 8004b40:	d000      	beq.n	8004b44 <mbox1_execute.lto_priv.99+0x2a4>
 8004b42:	e6dc      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostAheadI(&mb1, 'C');
 8004b44:	3043      	adds	r0, #67	; 0x43
 8004b46:	f000 fd4b 	bl	80055e0 <chMBPostAheadI.constprop.17>
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 8004b4a:	4241      	negs	r1, r0
 8004b4c:	4141      	adcs	r1, r0
 8004b4e:	2023      	movs	r0, #35	; 0x23
 8004b50:	b2c9      	uxtb	r1, r1
 8004b52:	f7fb fd35 	bl	80005c0 <_test_assert>
 8004b56:	2800      	cmp	r0, #0
 8004b58:	d000      	beq.n	8004b5c <mbox1_execute.lto_priv.99+0x2bc>
 8004b5a:	e6d0      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostAheadI(&mb1, 'B');
 8004b5c:	3042      	adds	r0, #66	; 0x42
 8004b5e:	f000 fd3f 	bl	80055e0 <chMBPostAheadI.constprop.17>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 8004b62:	4241      	negs	r1, r0
 8004b64:	4141      	adcs	r1, r0
 8004b66:	2024      	movs	r0, #36	; 0x24
 8004b68:	b2c9      	uxtb	r1, r1
 8004b6a:	f7fb fd29 	bl	80005c0 <_test_assert>
 8004b6e:	2800      	cmp	r0, #0
 8004b70:	d000      	beq.n	8004b74 <mbox1_execute.lto_priv.99+0x2d4>
 8004b72:	e6c4      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostAheadI(&mb1, 'A');
 8004b74:	3041      	adds	r0, #65	; 0x41
 8004b76:	f000 fd33 	bl	80055e0 <chMBPostAheadI.constprop.17>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004b7a:	b662      	cpsie	i
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 8004b7c:	4241      	negs	r1, r0
 8004b7e:	4141      	adcs	r1, r0
 8004b80:	2025      	movs	r0, #37	; 0x25
 8004b82:	b2c9      	uxtb	r1, r1
 8004b84:	f7fb fd1c 	bl	80005c0 <_test_assert>
 8004b88:	2800      	cmp	r0, #0
 8004b8a:	d000      	beq.n	8004b8e <mbox1_execute.lto_priv.99+0x2ee>
 8004b8c:	e6b7      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004b8e:	68eb      	ldr	r3, [r5, #12]
 8004b90:	68aa      	ldr	r2, [r5, #8]
 8004b92:	3026      	adds	r0, #38	; 0x26
 8004b94:	1a99      	subs	r1, r3, r2
 8004b96:	424a      	negs	r2, r1
 8004b98:	414a      	adcs	r2, r1
 8004b9a:	b2d1      	uxtb	r1, r2
 8004b9c:	f7fb fd10 	bl	80005c0 <_test_assert>
 8004ba0:	2800      	cmp	r0, #0
 8004ba2:	d000      	beq.n	8004ba6 <mbox1_execute.lto_priv.99+0x306>
 8004ba4:	e6ab      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
 8004ba6:	2405      	movs	r4, #5
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004ba8:	b672      	cpsid	i
  for (i = 0; i < MB_SIZE; i++) {
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
 8004baa:	a801      	add	r0, sp, #4
 8004bac:	f000 fd58 	bl	8005660 <chMBFetchI.constprop.15>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004bb0:	b662      	cpsie	i
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 8004bb2:	4241      	negs	r1, r0
 8004bb4:	4141      	adcs	r1, r0
 8004bb6:	2027      	movs	r0, #39	; 0x27
 8004bb8:	b2c9      	uxtb	r1, r1
 8004bba:	f7fb fd01 	bl	80005c0 <_test_assert>
 8004bbe:	2800      	cmp	r0, #0
 8004bc0:	d000      	beq.n	8004bc4 <mbox1_execute.lto_priv.99+0x324>
 8004bc2:	e69c      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
    test_emit_token(msg2);
 8004bc4:	9b01      	ldr	r3, [sp, #4]
 8004bc6:	3c01      	subs	r4, #1
 8004bc8:	b2d8      	uxtb	r0, r3
 8004bca:	f7fb fd11 	bl	80005f0 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 8004bce:	2c00      	cmp	r4, #0
 8004bd0:	d1ea      	bne.n	8004ba8 <mbox1_execute.lto_priv.99+0x308>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 8004bd2:	0031      	movs	r1, r6
 8004bd4:	2028      	movs	r0, #40	; 0x28
 8004bd6:	f7fb fcc3 	bl	8000560 <_test_assert_sequence>
 8004bda:	2800      	cmp	r0, #0
 8004bdc:	d000      	beq.n	8004be0 <mbox1_execute.lto_priv.99+0x340>
 8004bde:	e68e      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004be0:	b672      	cpsid	i
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004be2:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004be4:	3029      	adds	r0, #41	; 0x29
 8004be6:	1f59      	subs	r1, r3, #5
 8004be8:	424a      	negs	r2, r1
 8004bea:	414a      	adcs	r2, r1
 8004bec:	b2d1      	uxtb	r1, r2
 8004bee:	f7fb fce7 	bl	80005c0 <_test_assert>
 8004bf2:	2800      	cmp	r0, #0
 8004bf4:	d15d      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004bf6:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004bf8:	b672      	cpsid	i
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 8004bfa:	69a9      	ldr	r1, [r5, #24]
 8004bfc:	202a      	movs	r0, #42	; 0x2a
 8004bfe:	424b      	negs	r3, r1
 8004c00:	4159      	adcs	r1, r3
 8004c02:	b2c9      	uxtb	r1, r1
 8004c04:	f7fb fcdc 	bl	80005c0 <_test_assert>
 8004c08:	2800      	cmp	r0, #0
 8004c0a:	d152      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004c0c:	b662      	cpsie	i
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004c0e:	68eb      	ldr	r3, [r5, #12]
 8004c10:	68aa      	ldr	r2, [r5, #8]
 8004c12:	202b      	movs	r0, #43	; 0x2b
 8004c14:	1a99      	subs	r1, r3, r2
 8004c16:	424a      	negs	r2, r1
 8004c18:	414a      	adcs	r2, r1
 8004c1a:	b2d1      	uxtb	r1, r2
 8004c1c:	f7fb fcd0 	bl	80005c0 <_test_assert>
 8004c20:	2800      	cmp	r0, #0
 8004c22:	d000      	beq.n	8004c26 <mbox1_execute.lto_priv.99+0x386>
 8004c24:	e66b      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004c26:	b672      	cpsid	i
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8004c28:	6829      	ldr	r1, [r5, #0]
  mbp->mb_rdptr = mbp->mb_buffer;
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8004c2a:	686b      	ldr	r3, [r5, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8004c2c:	60a9      	str	r1, [r5, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8004c2e:	60e9      	str	r1, [r5, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8004c30:	1a59      	subs	r1, r3, r1
 8004c32:	1089      	asrs	r1, r1, #2
 8004c34:	480b      	ldr	r0, [pc, #44]	; (8004c64 <mbox1_execute.lto_priv.99+0x3c4>)
 8004c36:	f7fc fa5b 	bl	80010f0 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8004c3a:	0021      	movs	r1, r4
 8004c3c:	480a      	ldr	r0, [pc, #40]	; (8004c68 <mbox1_execute.lto_priv.99+0x3c8>)
 8004c3e:	f7fc fa57 	bl	80010f0 <chSemResetI>
 */
void chMBReset(mailbox_t *mbp) {

  chSysLock();
  chMBResetI(mbp);
  chSchRescheduleS();
 8004c42:	f7fb fdfd 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004c46:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004c48:	b672      	cpsid	i
  chMBReset(&mb1);

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8004c4a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8004c4c:	202c      	movs	r0, #44	; 0x2c
 8004c4e:	1f59      	subs	r1, r3, #5
 8004c50:	424a      	negs	r2, r1
 8004c52:	414a      	adcs	r2, r1
 8004c54:	b2d1      	uxtb	r1, r2
 8004c56:	f7fb fcb3 	bl	80005c0 <_test_assert>
 8004c5a:	2800      	cmp	r0, #0
 8004c5c:	d129      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
 8004c5e:	e005      	b.n	8004c6c <mbox1_execute.lto_priv.99+0x3cc>
 8004c60:	080064e0 	.word	0x080064e0
 8004c64:	20000698 	.word	0x20000698
 8004c68:	2000068c 	.word	0x2000068c
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004c6c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004c6e:	b672      	cpsid	i
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 8004c70:	69a9      	ldr	r1, [r5, #24]
 8004c72:	202d      	movs	r0, #45	; 0x2d
 8004c74:	424b      	negs	r3, r1
 8004c76:	4159      	adcs	r1, r3
 8004c78:	b2c9      	uxtb	r1, r1
 8004c7a:	f7fb fca1 	bl	80005c0 <_test_assert>
 8004c7e:	2800      	cmp	r0, #0
 8004c80:	d117      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004c82:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004c84:	b672      	cpsid	i
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 8004c86:	682b      	ldr	r3, [r5, #0]
 8004c88:	68aa      	ldr	r2, [r5, #8]
 8004c8a:	202e      	movs	r0, #46	; 0x2e
 8004c8c:	1a99      	subs	r1, r3, r2
 8004c8e:	424a      	negs	r2, r1
 8004c90:	414a      	adcs	r2, r1
 8004c92:	b2d1      	uxtb	r1, r2
 8004c94:	f7fb fc94 	bl	80005c0 <_test_assert>
 8004c98:	2800      	cmp	r0, #0
 8004c9a:	d10a      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004c9c:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004c9e:	b672      	cpsid	i
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 8004ca0:	682b      	ldr	r3, [r5, #0]
 8004ca2:	68e9      	ldr	r1, [r5, #12]
 8004ca4:	202f      	movs	r0, #47	; 0x2f
 8004ca6:	1a59      	subs	r1, r3, r1
 8004ca8:	424a      	negs	r2, r1
 8004caa:	414a      	adcs	r2, r1
 8004cac:	b2d1      	uxtb	r1, r2
 8004cae:	f7fb fc87 	bl	80005c0 <_test_assert>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004cb2:	b662      	cpsie	i
 8004cb4:	e623      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 8004cb6:	2101      	movs	r1, #1
 8004cb8:	3058      	adds	r0, #88	; 0x58
 8004cba:	f000 fc31 	bl	8005520 <chMBPost.constprop.20>
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004cbe:	3001      	adds	r0, #1
 8004cc0:	4241      	negs	r1, r0
 8004cc2:	4141      	adcs	r1, r0
 8004cc4:	2004      	movs	r0, #4
 8004cc6:	b2c9      	uxtb	r1, r1
 8004cc8:	f7fb fc7a 	bl	80005c0 <_test_assert>
 8004ccc:	2800      	cmp	r0, #0
 8004cce:	d000      	beq.n	8004cd2 <mbox1_execute.lto_priv.99+0x432>
 8004cd0:	e615      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004cd2:	b672      	cpsid	i
  chSysLock();
  msg1 = chMBPostI(&mb1, 'X');
 8004cd4:	3058      	adds	r0, #88	; 0x58
 8004cd6:	f000 fc43 	bl	8005560 <chMBPostI.constprop.19>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004cda:	b662      	cpsie	i
  chSysUnlock();
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004cdc:	3001      	adds	r0, #1
 8004cde:	4241      	negs	r1, r0
 8004ce0:	4141      	adcs	r1, r0
 8004ce2:	2005      	movs	r0, #5
 8004ce4:	b2c9      	uxtb	r1, r1
 8004ce6:	f7fb fc6b 	bl	80005c0 <_test_assert>
 8004cea:	2800      	cmp	r0, #0
 8004cec:	d000      	beq.n	8004cf0 <mbox1_execute.lto_priv.99+0x450>
 8004cee:	e606      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 8004cf0:	2101      	movs	r1, #1
 8004cf2:	3058      	adds	r0, #88	; 0x58
 8004cf4:	f000 fc54 	bl	80055a0 <chMBPostAhead.constprop.18>
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004cf8:	1c41      	adds	r1, r0, #1
 8004cfa:	424b      	negs	r3, r1
 8004cfc:	414b      	adcs	r3, r1
 8004cfe:	2006      	movs	r0, #6
 8004d00:	b2d9      	uxtb	r1, r3
 8004d02:	f7fb fc5d 	bl	80005c0 <_test_assert>
 8004d06:	2800      	cmp	r0, #0
 8004d08:	d000      	beq.n	8004d0c <mbox1_execute.lto_priv.99+0x46c>
 8004d0a:	e5f8      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d0c:	b672      	cpsid	i
  chSysLock();
  msg1 = chMBPostAheadI(&mb1, 'X');
 8004d0e:	3058      	adds	r0, #88	; 0x58
 8004d10:	f000 fc66 	bl	80055e0 <chMBPostAheadI.constprop.17>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d14:	b662      	cpsie	i
  chSysUnlock();
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8004d16:	1c41      	adds	r1, r0, #1
 8004d18:	424b      	negs	r3, r1
 8004d1a:	414b      	adcs	r3, r1
 8004d1c:	2007      	movs	r0, #7
 8004d1e:	b2d9      	uxtb	r1, r3
 8004d20:	f7fb fc4e 	bl	80005c0 <_test_assert>
 8004d24:	2800      	cmp	r0, #0
 8004d26:	d000      	beq.n	8004d2a <mbox1_execute.lto_priv.99+0x48a>
 8004d28:	e5e9      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d2a:	b672      	cpsid	i

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 8004d2c:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8004d2e:	3008      	adds	r0, #8
 8004d30:	424b      	negs	r3, r1
 8004d32:	4159      	adcs	r1, r3
 8004d34:	b2c9      	uxtb	r1, r1
 8004d36:	f7fb fc43 	bl	80005c0 <_test_assert>
 8004d3a:	2800      	cmp	r0, #0
 8004d3c:	d1b9      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d3e:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d40:	b672      	cpsid	i
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 8004d42:	69ab      	ldr	r3, [r5, #24]
 8004d44:	2009      	movs	r0, #9
 8004d46:	1f59      	subs	r1, r3, #5
 8004d48:	424a      	negs	r2, r1
 8004d4a:	414a      	adcs	r2, r1
 8004d4c:	b2d1      	uxtb	r1, r2
 8004d4e:	f7fb fc37 	bl	80005c0 <_test_assert>
 8004d52:	2800      	cmp	r0, #0
 8004d54:	d1ad      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d56:	b662      	cpsie	i
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004d58:	b672      	cpsid	i
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 8004d5a:	68eb      	ldr	r3, [r5, #12]
 8004d5c:	68aa      	ldr	r2, [r5, #8]
 8004d5e:	200a      	movs	r0, #10
 8004d60:	1a99      	subs	r1, r3, r2
 8004d62:	424a      	negs	r2, r1
 8004d64:	414a      	adcs	r2, r1
 8004d66:	b2d1      	uxtb	r1, r2
 8004d68:	f7fb fc2a 	bl	80005c0 <_test_assert>
 8004d6c:	2800      	cmp	r0, #0
 8004d6e:	d1a0      	bne.n	8004cb2 <mbox1_execute.lto_priv.99+0x412>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004d70:	b662      	cpsie	i
 8004d72:	2405      	movs	r4, #5
 8004d74:	e007      	b.n	8004d86 <mbox1_execute.lto_priv.99+0x4e6>
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
 8004d76:	9b01      	ldr	r3, [sp, #4]
 8004d78:	3c01      	subs	r4, #1
 8004d7a:	b2d8      	uxtb	r0, r3
 8004d7c:	f7fb fc38 	bl	80005f0 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 8004d80:	2c00      	cmp	r4, #0
 8004d82:	d100      	bne.n	8004d86 <mbox1_execute.lto_priv.99+0x4e6>
 8004d84:	e5c0      	b.n	8004908 <mbox1_execute.lto_priv.99+0x68>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 8004d86:	2101      	movs	r1, #1
 8004d88:	a801      	add	r0, sp, #4
 8004d8a:	4249      	negs	r1, r1
 8004d8c:	f000 fc48 	bl	8005620 <chMBFetch.constprop.16>
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 8004d90:	4241      	negs	r1, r0
 8004d92:	4141      	adcs	r1, r0
 8004d94:	200b      	movs	r0, #11
 8004d96:	b2c9      	uxtb	r1, r1
 8004d98:	f7fb fc12 	bl	80005c0 <_test_assert>
 8004d9c:	2800      	cmp	r0, #0
 8004d9e:	d0ea      	beq.n	8004d76 <mbox1_execute.lto_priv.99+0x4d6>
 8004da0:	e5ad      	b.n	80048fe <mbox1_execute.lto_priv.99+0x5e>
 8004da2:	46c0      	nop			; (mov r8, r8)
	...

08004db0 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 8004db0:	b510      	push	{r4, lr}
 8004db2:	0004      	movs	r4, r0

  chMsgSend(p, 'A');
 8004db4:	2141      	movs	r1, #65	; 0x41
 8004db6:	f7fb fe93 	bl	8000ae0 <chMsgSend>
  chMsgSend(p, 'B');
 8004dba:	2142      	movs	r1, #66	; 0x42
 8004dbc:	0020      	movs	r0, r4
 8004dbe:	f7fb fe8f 	bl	8000ae0 <chMsgSend>
  chMsgSend(p, 'C');
 8004dc2:	2143      	movs	r1, #67	; 0x43
 8004dc4:	0020      	movs	r0, r4
 8004dc6:	f7fb fe8b 	bl	8000ae0 <chMsgSend>
}
 8004dca:	bd10      	pop	{r4, pc}
 8004dcc:	0000      	movs	r0, r0
	...

08004dd0 <msg1_execute.lto_priv.97>:
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004dd0:	21a4      	movs	r1, #164	; 0xa4
  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
}

static void msg1_execute(void) {
 8004dd2:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004dd4:	4b19      	ldr	r3, [pc, #100]	; (8004e3c <msg1_execute.lto_priv.97+0x6c>)
 8004dd6:	b082      	sub	sp, #8
 8004dd8:	699b      	ldr	r3, [r3, #24]
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004dda:	0049      	lsls	r1, r1, #1
 8004ddc:	689a      	ldr	r2, [r3, #8]
 8004dde:	4818      	ldr	r0, [pc, #96]	; (8004e40 <msg1_execute.lto_priv.97+0x70>)
 8004de0:	3201      	adds	r2, #1
 8004de2:	9300      	str	r3, [sp, #0]
 8004de4:	4b17      	ldr	r3, [pc, #92]	; (8004e44 <msg1_execute.lto_priv.97+0x74>)
 8004de6:	f7fb fd93 	bl	8000910 <chThdCreateStatic>
 8004dea:	4b17      	ldr	r3, [pc, #92]	; (8004e48 <msg1_execute.lto_priv.97+0x78>)
 8004dec:	6018      	str	r0, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 8004dee:	f7fb fdcf 	bl	8000990 <chMsgWait>
 8004df2:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004df4:	b672      	cpsid	i
 8004df6:	0021      	movs	r1, r4
 8004df8:	f7fb fd4a 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004dfc:	b662      	cpsie	i
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 8004dfe:	b2e0      	uxtb	r0, r4
 8004e00:	f7fb fbf6 	bl	80005f0 <test_emit_token>
  tp = chMsgWait();
 8004e04:	f7fb fdc4 	bl	8000990 <chMsgWait>
 8004e08:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004e0a:	b672      	cpsid	i
 8004e0c:	0021      	movs	r1, r4
 8004e0e:	f7fb fd3f 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004e12:	b662      	cpsie	i
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 8004e14:	b2e0      	uxtb	r0, r4
 8004e16:	f7fb fbeb 	bl	80005f0 <test_emit_token>
  tp = chMsgWait();
 8004e1a:	f7fb fdb9 	bl	8000990 <chMsgWait>
 8004e1e:	6b04      	ldr	r4, [r0, #48]	; 0x30
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004e20:	b672      	cpsid	i
 8004e22:	0021      	movs	r1, r4
 8004e24:	f7fb fd34 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004e28:	b662      	cpsie	i
  msg = chMsgGet(tp);
  chMsgRelease(tp, msg);
  test_emit_token(msg);
 8004e2a:	b2e0      	uxtb	r0, r4
 8004e2c:	f7fb fbe0 	bl	80005f0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 8004e30:	4906      	ldr	r1, [pc, #24]	; (8004e4c <msg1_execute.lto_priv.97+0x7c>)
 8004e32:	2001      	movs	r0, #1
 8004e34:	f7fb fb94 	bl	8000560 <_test_assert_sequence>
}
 8004e38:	b002      	add	sp, #8
 8004e3a:	bd10      	pop	{r4, pc}
 8004e3c:	20000ac0 	.word	0x20000ac0
 8004e40:	20000c58 	.word	0x20000c58
 8004e44:	08004db1 	.word	0x08004db1
 8004e48:	20000a28 	.word	0x20000a28
 8004e4c:	08006514 	.word	0x08006514

08004e50 <mtx8_execute.lto_priv.96>:
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 8004e50:	b5f0      	push	{r4, r5, r6, r7, lr}

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004e52:	27a4      	movs	r7, #164	; 0xa4
 8004e54:	4b17      	ldr	r3, [pc, #92]	; (8004eb4 <mtx8_execute.lto_priv.96+0x64>)
 8004e56:	4c18      	ldr	r4, [pc, #96]	; (8004eb8 <mtx8_execute.lto_priv.96+0x68>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8004e58:	699b      	ldr	r3, [r3, #24]
  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
}

static void mtx8_execute(void) {
 8004e5a:	b083      	sub	sp, #12
 8004e5c:	689d      	ldr	r5, [r3, #8]

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004e5e:	4b17      	ldr	r3, [pc, #92]	; (8004ebc <mtx8_execute.lto_priv.96+0x6c>)
 8004e60:	007f      	lsls	r7, r7, #1
 8004e62:	1c6a      	adds	r2, r5, #1
 8004e64:	9300      	str	r3, [sp, #0]
 8004e66:	0039      	movs	r1, r7
 8004e68:	4b15      	ldr	r3, [pc, #84]	; (8004ec0 <mtx8_execute.lto_priv.96+0x70>)
 8004e6a:	0020      	movs	r0, r4
 8004e6c:	f7fb fd50 	bl	8000910 <chThdCreateStatic>
 8004e70:	4e14      	ldr	r6, [pc, #80]	; (8004ec4 <mtx8_execute.lto_priv.96+0x74>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004e72:	4b15      	ldr	r3, [pc, #84]	; (8004ec8 <mtx8_execute.lto_priv.96+0x78>)
}

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 8004e74:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004e76:	1caa      	adds	r2, r5, #2
 8004e78:	9300      	str	r3, [sp, #0]
 8004e7a:	0039      	movs	r1, r7
 8004e7c:	19e0      	adds	r0, r4, r7
 8004e7e:	4b13      	ldr	r3, [pc, #76]	; (8004ecc <mtx8_execute.lto_priv.96+0x7c>)
 8004e80:	f7fb fd46 	bl	8000910 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8004e84:	23a4      	movs	r3, #164	; 0xa4
 8004e86:	009b      	lsls	r3, r3, #2

static void mtx8_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 8004e88:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 8004e8a:	18e0      	adds	r0, r4, r3
 8004e8c:	4b10      	ldr	r3, [pc, #64]	; (8004ed0 <mtx8_execute.lto_priv.96+0x80>)
 8004e8e:	1cea      	adds	r2, r5, #3
 8004e90:	0039      	movs	r1, r7
 8004e92:	9300      	str	r3, [sp, #0]
 8004e94:	4b0f      	ldr	r3, [pc, #60]	; (8004ed4 <mtx8_execute.lto_priv.96+0x84>)
 8004e96:	f7fb fd3b 	bl	8000910 <chThdCreateStatic>
 8004e9a:	60b0      	str	r0, [r6, #8]
  chCondSignal(&c1);
 8004e9c:	f000 fae0 	bl	8005460 <chCondSignal.constprop.44>
  chCondSignal(&c1);
 8004ea0:	f000 fade 	bl	8005460 <chCondSignal.constprop.44>
  test_wait_threads();
 8004ea4:	f7fc f8ac 	bl	8001000 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 8004ea8:	490b      	ldr	r1, [pc, #44]	; (8004ed8 <mtx8_execute.lto_priv.96+0x88>)
 8004eaa:	2001      	movs	r0, #1
 8004eac:	f7fb fb58 	bl	8000560 <_test_assert_sequence>
}
 8004eb0:	b003      	add	sp, #12
 8004eb2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004eb4:	20000ac0 	.word	0x20000ac0
 8004eb8:	20000c58 	.word	0x20000c58
 8004ebc:	080064d4 	.word	0x080064d4
 8004ec0:	08004f01 	.word	0x08004f01
 8004ec4:	20000a28 	.word	0x20000a28
 8004ec8:	080064dc 	.word	0x080064dc
 8004ecc:	08004f91 	.word	0x08004f91
 8004ed0:	080064d0 	.word	0x080064d0
 8004ed4:	08004ee1 	.word	0x08004ee1
 8004ed8:	08006514 	.word	0x08006514
 8004edc:	00000000 	.word	0x00000000

08004ee0 <thread12>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread12, p) {
 8004ee0:	b570      	push	{r4, r5, r6, lr}
 8004ee2:	0005      	movs	r5, r0

  chMtxLock(&m2);
 8004ee4:	4c05      	ldr	r4, [pc, #20]	; (8004efc <thread12+0x1c>)
 8004ee6:	0020      	movs	r0, r4
 8004ee8:	f7fb ffca 	bl	8000e80 <chMtxLock>
  test_emit_token(*(char *)p);
 8004eec:	7828      	ldrb	r0, [r5, #0]
 8004eee:	f7fb fb7f 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m2);
 8004ef2:	0020      	movs	r0, r4
 8004ef4:	f7fb ff2c 	bl	8000d50 <chMtxUnlock>
}
 8004ef8:	bd70      	pop	{r4, r5, r6, pc}
 8004efa:	46c0      	nop			; (mov r8, r8)
 8004efc:	2000065c 	.word	0x2000065c

08004f00 <thread11>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8004f00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004f02:	4647      	mov	r7, r8

  chMtxLock(&m2);
 8004f04:	4d1d      	ldr	r5, [pc, #116]	; (8004f7c <thread11+0x7c>)
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static THD_FUNCTION(thread11, p) {
 8004f06:	b480      	push	{r7}
 8004f08:	4680      	mov	r8, r0

  chMtxLock(&m2);
 8004f0a:	0028      	movs	r0, r5
 8004f0c:	f7fb ffb8 	bl	8000e80 <chMtxLock>
  chMtxLock(&m1);
 8004f10:	4e1b      	ldr	r6, [pc, #108]	; (8004f80 <thread11+0x80>)
 8004f12:	0030      	movs	r0, r6
 8004f14:	f7fb ffb4 	bl	8000e80 <chMtxLock>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004f18:	b672      	cpsid	i
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8004f1a:	4c1a      	ldr	r4, [pc, #104]	; (8004f84 <thread11+0x84>)
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->p_mtxlist;
 8004f1c:	69a3      	ldr	r3, [r4, #24]
 8004f1e:	6b9f      	ldr	r7, [r3, #56]	; 0x38
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8004f20:	0038      	movs	r0, r7
 8004f22:	f7fb feed 	bl	8000d00 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 8004f26:	4918      	ldr	r1, [pc, #96]	; (8004f88 <thread11+0x88>)
 8004f28:	69a2      	ldr	r2, [r4, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004f2a:	000b      	movs	r3, r1
 8004f2c:	6211      	str	r1, [r2, #32]
 8004f2e:	e004      	b.n	8004f3a <thread11+0x3a>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004f30:	6898      	ldr	r0, [r3, #8]
 8004f32:	4684      	mov	ip, r0
 8004f34:	6890      	ldr	r0, [r2, #8]
 8004f36:	4584      	cmp	ip, r0
 8004f38:	d302      	bcc.n	8004f40 <thread11+0x40>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8004f3a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004f3c:	428b      	cmp	r3, r1
 8004f3e:	d1f7      	bne.n	8004f30 <thread11+0x30>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8004f40:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8004f42:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 8004f44:	6051      	str	r1, [r2, #4]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004f46:	2007      	movs	r0, #7
  tp->p_prev->p_next = tp;
 8004f48:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 8004f4a:	605a      	str	r2, [r3, #4]
 8004f4c:	f7fb fd10 	bl	8000970 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8004f50:	69a3      	ldr	r3, [r4, #24]
  queue_prio_insert(currp, &cp->c_queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 8004f52:	6a1b      	ldr	r3, [r3, #32]
 8004f54:	3301      	adds	r3, #1
 8004f56:	d002      	beq.n	8004f5e <thread11+0x5e>
    chMtxLockS(mp);
 8004f58:	0038      	movs	r0, r7
 8004f5a:	f7fb ff29 	bl	8000db0 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004f5e:	b662      	cpsie	i
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8004f60:	4643      	mov	r3, r8
 8004f62:	7818      	ldrb	r0, [r3, #0]
 8004f64:	f7fb fb44 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m1);
 8004f68:	0030      	movs	r0, r6
 8004f6a:	f7fb fef1 	bl	8000d50 <chMtxUnlock>
  chMtxUnlock(&m2);
 8004f6e:	0028      	movs	r0, r5
 8004f70:	f7fb feee 	bl	8000d50 <chMtxUnlock>
}
 8004f74:	bc04      	pop	{r2}
 8004f76:	4690      	mov	r8, r2
 8004f78:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004f7a:	46c0      	nop			; (mov r8, r8)
 8004f7c:	2000065c 	.word	0x2000065c
 8004f80:	2000066c 	.word	0x2000066c
 8004f84:	20000ac0 	.word	0x20000ac0
 8004f88:	200006a4 	.word	0x200006a4
 8004f8c:	00000000 	.word	0x00000000

08004f90 <thread10>:

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 8004f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  chMtxLock(&m1);
 8004f92:	4d15      	ldr	r5, [pc, #84]	; (8004fe8 <thread10+0x58>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static THD_FUNCTION(thread10, p) {
 8004f94:	0007      	movs	r7, r0

  chMtxLock(&m1);
 8004f96:	0028      	movs	r0, r5
 8004f98:	f7fb ff72 	bl	8000e80 <chMtxLock>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004f9c:	b672      	cpsid	i
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8004f9e:	4b13      	ldr	r3, [pc, #76]	; (8004fec <thread10+0x5c>)
 8004fa0:	699c      	ldr	r4, [r3, #24]
 8004fa2:	6ba6      	ldr	r6, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8004fa4:	0030      	movs	r0, r6
 8004fa6:	f7fb feab 	bl	8000d00 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8004faa:	4a11      	ldr	r2, [pc, #68]	; (8004ff0 <thread10+0x60>)
 8004fac:	6222      	str	r2, [r4, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004fae:	0013      	movs	r3, r2
 8004fb0:	e003      	b.n	8004fba <thread10+0x2a>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004fb2:	6899      	ldr	r1, [r3, #8]
 8004fb4:	68a0      	ldr	r0, [r4, #8]
 8004fb6:	4281      	cmp	r1, r0
 8004fb8:	d302      	bcc.n	8004fc0 <thread10+0x30>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8004fba:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8004fbc:	4293      	cmp	r3, r2
 8004fbe:	d1f8      	bne.n	8004fb2 <thread10+0x22>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8004fc0:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8004fc2:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8004fc4:	6062      	str	r2, [r4, #4]
  queue_prio_insert(ctp, &cp->c_queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8004fc6:	2007      	movs	r0, #7
  tp->p_prev->p_next = tp;
 8004fc8:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8004fca:	605c      	str	r4, [r3, #4]
 8004fcc:	f7fb fcd0 	bl	8000970 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
  chMtxLockS(mp);
 8004fd0:	0030      	movs	r0, r6
 8004fd2:	f7fb feed 	bl	8000db0 <chMtxLockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004fd6:	b662      	cpsie	i
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 8004fd8:	7838      	ldrb	r0, [r7, #0]
 8004fda:	f7fb fb09 	bl	80005f0 <test_emit_token>
  chMtxUnlock(&m1);
 8004fde:	0028      	movs	r0, r5
 8004fe0:	f7fb feb6 	bl	8000d50 <chMtxUnlock>
}
 8004fe4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004fe6:	46c0      	nop			; (mov r8, r8)
 8004fe8:	2000066c 	.word	0x2000066c
 8004fec:	20000ac0 	.word	0x20000ac0
 8004ff0:	200006a4 	.word	0x200006a4
	...

08005000 <mtx7_execute.lto_priv.94>:
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8005000:	21a4      	movs	r1, #164	; 0xa4

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8005002:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005004:	4b2d      	ldr	r3, [pc, #180]	; (80050bc <mtx7_execute.lto_priv.94+0xbc>)

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8005006:	4f2e      	ldr	r7, [pc, #184]	; (80050c0 <mtx7_execute.lto_priv.94+0xc0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 8005008:	699b      	ldr	r3, [r3, #24]
 800500a:	4c2e      	ldr	r4, [pc, #184]	; (80050c4 <mtx7_execute.lto_priv.94+0xc4>)
 800500c:	689d      	ldr	r5, [r3, #8]
 800500e:	4b2e      	ldr	r3, [pc, #184]	; (80050c8 <mtx7_execute.lto_priv.94+0xc8>)

  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void mtx7_execute(void) {
 8005010:	b083      	sub	sp, #12

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8005012:	1c6a      	adds	r2, r5, #1
 8005014:	9300      	str	r3, [sp, #0]
 8005016:	0049      	lsls	r1, r1, #1
 8005018:	003b      	movs	r3, r7
 800501a:	0020      	movs	r0, r4
 800501c:	f7fb fc78 	bl	8000910 <chThdCreateStatic>
 8005020:	4e2a      	ldr	r6, [pc, #168]	; (80050cc <mtx7_execute.lto_priv.94+0xcc>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8005022:	21a4      	movs	r1, #164	; 0xa4
}

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8005024:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8005026:	0020      	movs	r0, r4
 8005028:	4b29      	ldr	r3, [pc, #164]	; (80050d0 <mtx7_execute.lto_priv.94+0xd0>)
 800502a:	3049      	adds	r0, #73	; 0x49
 800502c:	1caa      	adds	r2, r5, #2
 800502e:	9300      	str	r3, [sp, #0]
 8005030:	0049      	lsls	r1, r1, #1
 8005032:	003b      	movs	r3, r7
 8005034:	30ff      	adds	r0, #255	; 0xff
 8005036:	f7fb fc6b 	bl	8000910 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800503a:	23a4      	movs	r3, #164	; 0xa4
 800503c:	21a4      	movs	r1, #164	; 0xa4
 800503e:	009b      	lsls	r3, r3, #2

static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8005040:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8005042:	18e0      	adds	r0, r4, r3
 8005044:	4b23      	ldr	r3, [pc, #140]	; (80050d4 <mtx7_execute.lto_priv.94+0xd4>)
 8005046:	1cea      	adds	r2, r5, #3
 8005048:	9300      	str	r3, [sp, #0]
 800504a:	0049      	lsls	r1, r1, #1
 800504c:	003b      	movs	r3, r7
 800504e:	f7fb fc5f 	bl	8000910 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8005052:	23f6      	movs	r3, #246	; 0xf6
 8005054:	21a4      	movs	r1, #164	; 0xa4
 8005056:	009b      	lsls	r3, r3, #2
static void mtx7_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8005058:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800505a:	18e0      	adds	r0, r4, r3
 800505c:	4b1e      	ldr	r3, [pc, #120]	; (80050d8 <mtx7_execute.lto_priv.94+0xd8>)
 800505e:	1d2a      	adds	r2, r5, #4
 8005060:	9300      	str	r3, [sp, #0]
 8005062:	0049      	lsls	r1, r1, #1
 8005064:	003b      	movs	r3, r7
 8005066:	f7fb fc53 	bl	8000910 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800506a:	23a4      	movs	r3, #164	; 0xa4
 800506c:	21a4      	movs	r1, #164	; 0xa4
 800506e:	00db      	lsls	r3, r3, #3

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8005070:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8005072:	18e0      	adds	r0, r4, r3
 8005074:	4b19      	ldr	r3, [pc, #100]	; (80050dc <mtx7_execute.lto_priv.94+0xdc>)
 8005076:	1d6a      	adds	r2, r5, #5
 8005078:	9300      	str	r3, [sp, #0]
 800507a:	0049      	lsls	r1, r1, #1
 800507c:	003b      	movs	r3, r7
 800507e:	f7fb fc47 	bl	8000910 <chThdCreateStatic>
 8005082:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005084:	b672      	cpsid	i

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8005086:	2502      	movs	r5, #2
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8005088:	4c15      	ldr	r4, [pc, #84]	; (80050e0 <mtx7_execute.lto_priv.94+0xe0>)
 800508a:	426d      	negs	r5, r5
 800508c:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 800508e:	42a0      	cmp	r0, r4
 8005090:	d008      	beq.n	80050a4 <mtx7_execute.lto_priv.94+0xa4>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8005092:	6803      	ldr	r3, [r0, #0]
 8005094:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005096:	605c      	str	r4, [r3, #4]
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8005098:	f7fb fcba 	bl	8000a10 <chSchReadyI>
 800509c:	6205      	str	r5, [r0, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 800509e:	6820      	ldr	r0, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 80050a0:	42a0      	cmp	r0, r4
 80050a2:	d1f6      	bne.n	8005092 <mtx7_execute.lto_priv.94+0x92>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 80050a4:	f7fb fbcc 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80050a8:	b662      	cpsie	i
  chCondBroadcast(&c1);
  test_wait_threads();
 80050aa:	f7fb ffa9 	bl	8001000 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 80050ae:	490d      	ldr	r1, [pc, #52]	; (80050e4 <mtx7_execute.lto_priv.94+0xe4>)
 80050b0:	2001      	movs	r0, #1
 80050b2:	f7fb fa55 	bl	8000560 <_test_assert_sequence>
}
 80050b6:	b003      	add	sp, #12
 80050b8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80050ba:	46c0      	nop			; (mov r8, r8)
 80050bc:	20000ac0 	.word	0x20000ac0
 80050c0:	08004f91 	.word	0x08004f91
 80050c4:	20000c58 	.word	0x20000c58
 80050c8:	080064e4 	.word	0x080064e4
 80050cc:	20000a28 	.word	0x20000a28
 80050d0:	080064d8 	.word	0x080064d8
 80050d4:	080064dc 	.word	0x080064dc
 80050d8:	080064d0 	.word	0x080064d0
 80050dc:	080064d4 	.word	0x080064d4
 80050e0:	200006a4 	.word	0x200006a4
 80050e4:	080064e0 	.word	0x080064e0
	...

080050f0 <mtx6_execute.lto_priv.92>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 80050f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80050f2:	4647      	mov	r7, r8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80050f4:	4b2a      	ldr	r3, [pc, #168]	; (80051a0 <mtx6_execute.lto_priv.92+0xb0>)
 80050f6:	b480      	push	{r7}
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80050f8:	699b      	ldr	r3, [r3, #24]

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 80050fa:	27a4      	movs	r7, #164	; 0xa4
 80050fc:	689d      	ldr	r5, [r3, #8]
 80050fe:	4b29      	ldr	r3, [pc, #164]	; (80051a4 <mtx6_execute.lto_priv.92+0xb4>)
 8005100:	4c29      	ldr	r4, [pc, #164]	; (80051a8 <mtx6_execute.lto_priv.92+0xb8>)
 8005102:	4698      	mov	r8, r3
 8005104:	4b29      	ldr	r3, [pc, #164]	; (80051ac <mtx6_execute.lto_priv.92+0xbc>)
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static void mtx6_execute(void) {
 8005106:	b082      	sub	sp, #8

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 8005108:	007f      	lsls	r7, r7, #1
 800510a:	1c6a      	adds	r2, r5, #1
 800510c:	9300      	str	r3, [sp, #0]
 800510e:	0039      	movs	r1, r7
 8005110:	4643      	mov	r3, r8
 8005112:	0020      	movs	r0, r4
 8005114:	f7fb fbfc 	bl	8000910 <chThdCreateStatic>
 8005118:	4e25      	ldr	r6, [pc, #148]	; (80051b0 <mtx6_execute.lto_priv.92+0xc0>)
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800511a:	4b26      	ldr	r3, [pc, #152]	; (80051b4 <mtx6_execute.lto_priv.92+0xc4>)
}

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800511c:	6030      	str	r0, [r6, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800511e:	1caa      	adds	r2, r5, #2
 8005120:	9300      	str	r3, [sp, #0]
 8005122:	0039      	movs	r1, r7
 8005124:	4643      	mov	r3, r8
 8005126:	19e0      	adds	r0, r4, r7
 8005128:	f7fb fbf2 	bl	8000910 <chThdCreateStatic>
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800512c:	23a4      	movs	r3, #164	; 0xa4
 800512e:	009b      	lsls	r3, r3, #2

static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 8005130:	6070      	str	r0, [r6, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8005132:	18e0      	adds	r0, r4, r3
 8005134:	4b20      	ldr	r3, [pc, #128]	; (80051b8 <mtx6_execute.lto_priv.92+0xc8>)
 8005136:	1cea      	adds	r2, r5, #3
 8005138:	9300      	str	r3, [sp, #0]
 800513a:	0039      	movs	r1, r7
 800513c:	4643      	mov	r3, r8
 800513e:	f7fb fbe7 	bl	8000910 <chThdCreateStatic>
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8005142:	23f6      	movs	r3, #246	; 0xf6
 8005144:	009b      	lsls	r3, r3, #2
static void mtx6_execute(void) {

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 8005146:	60b0      	str	r0, [r6, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 8005148:	18e0      	adds	r0, r4, r3
 800514a:	4b1c      	ldr	r3, [pc, #112]	; (80051bc <mtx6_execute.lto_priv.92+0xcc>)
 800514c:	1d2a      	adds	r2, r5, #4
 800514e:	9300      	str	r3, [sp, #0]
 8005150:	0039      	movs	r1, r7
 8005152:	4643      	mov	r3, r8
 8005154:	f7fb fbdc 	bl	8000910 <chThdCreateStatic>
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 8005158:	23a4      	movs	r3, #164	; 0xa4
 800515a:	00db      	lsls	r3, r3, #3

  tprio_t prio = chThdGetPriorityX();
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800515c:	60f0      	str	r0, [r6, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800515e:	18e0      	adds	r0, r4, r3
 8005160:	4b17      	ldr	r3, [pc, #92]	; (80051c0 <mtx6_execute.lto_priv.92+0xd0>)
 8005162:	1d6a      	adds	r2, r5, #5
 8005164:	9300      	str	r3, [sp, #0]
 8005166:	0039      	movs	r1, r7
 8005168:	4643      	mov	r3, r8
 800516a:	f7fb fbd1 	bl	8000910 <chThdCreateStatic>
 800516e:	6130      	str	r0, [r6, #16]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005170:	b672      	cpsid	i
  chSysLock();
  chCondSignalI(&c1);
 8005172:	f000 f985 	bl	8005480 <chCondSignalI.constprop.43>
  chCondSignalI(&c1);
 8005176:	f000 f983 	bl	8005480 <chCondSignalI.constprop.43>
  chCondSignalI(&c1);
 800517a:	f000 f981 	bl	8005480 <chCondSignalI.constprop.43>
  chCondSignalI(&c1);
 800517e:	f000 f97f 	bl	8005480 <chCondSignalI.constprop.43>
  chCondSignalI(&c1);
 8005182:	f000 f97d 	bl	8005480 <chCondSignalI.constprop.43>
  chSchRescheduleS();
 8005186:	f7fb fb5b 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800518a:	b662      	cpsie	i
  chSysUnlock();
  test_wait_threads();
 800518c:	f7fb ff38 	bl	8001000 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 8005190:	490c      	ldr	r1, [pc, #48]	; (80051c4 <mtx6_execute.lto_priv.92+0xd4>)
 8005192:	2001      	movs	r0, #1
 8005194:	f7fb f9e4 	bl	8000560 <_test_assert_sequence>
}
 8005198:	b002      	add	sp, #8
 800519a:	bc04      	pop	{r2}
 800519c:	4690      	mov	r8, r2
 800519e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80051a0:	20000ac0 	.word	0x20000ac0
 80051a4:	08004f91 	.word	0x08004f91
 80051a8:	20000c58 	.word	0x20000c58
 80051ac:	080064e4 	.word	0x080064e4
 80051b0:	20000a28 	.word	0x20000a28
 80051b4:	080064d8 	.word	0x080064d8
 80051b8:	080064dc 	.word	0x080064dc
 80051bc:	080064d0 	.word	0x080064d0
 80051c0:	080064d4 	.word	0x080064d4
 80051c4:	080064e0 	.word	0x080064e0
	...

080051d0 <mtx5_execute.lto_priv.90>:
static void mtx5_setup(void) {

  chMtxObjectInit(&m1);
}

static void mtx5_execute(void) {
 80051d0:	b570      	push	{r4, r5, r6, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80051d2:	4d31      	ldr	r5, [pc, #196]	; (8005298 <mtx5_execute.lto_priv.90+0xc8>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->p_prio;
 80051d4:	69ab      	ldr	r3, [r5, #24]
 80051d6:	689e      	ldr	r6, [r3, #8]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80051d8:	b672      	cpsid	i
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 80051da:	4c30      	ldr	r4, [pc, #192]	; (800529c <mtx5_execute.lto_priv.90+0xcc>)
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 80051dc:	2100      	movs	r1, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 80051de:	68a3      	ldr	r3, [r4, #8]
 80051e0:	2b00      	cmp	r3, #0
 80051e2:	d04c      	beq.n	800527e <mtx5_execute.lto_priv.90+0xae>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80051e4:	b662      	cpsie	i
#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");
 80051e6:	2001      	movs	r0, #1
 80051e8:	f7fb f9ea 	bl	80005c0 <_test_assert>
 80051ec:	2800      	cmp	r0, #0
 80051ee:	d000      	beq.n	80051f2 <mtx5_execute.lto_priv.90+0x22>
  
  chMtxLock(&m1);
  chMtxUnlockAll();
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
  test_assert(7, m1.m_owner == NULL, "still owned");
}
 80051f0:	bd70      	pop	{r4, r5, r6, pc}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80051f2:	b672      	cpsid	i
 80051f4:	68a3      	ldr	r3, [r4, #8]
 80051f6:	2b00      	cmp	r3, #0
 80051f8:	d048      	beq.n	800528c <mtx5_execute.lto_priv.90+0xbc>
 80051fa:	2001      	movs	r0, #1
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80051fc:	b662      	cpsie	i

  b = chMtxTryLock(&m1);
  test_assert(1, b, "already locked");

  b = chMtxTryLock(&m1);
  test_assert(2, !b, "not locked");
 80051fe:	0001      	movs	r1, r0
 8005200:	2002      	movs	r0, #2
 8005202:	f7fb f9dd 	bl	80005c0 <_test_assert>
 8005206:	2800      	cmp	r0, #0
 8005208:	d1f2      	bne.n	80051f0 <mtx5_execute.lto_priv.90+0x20>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800520a:	b672      	cpsid	i

  chSysLock();
  chMtxUnlockS(&m1);
 800520c:	0020      	movs	r0, r4
 800520e:	f7fb fd77 	bl	8000d00 <chMtxUnlockS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005212:	b662      	cpsie	i
  chSysUnlock();

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 8005214:	6823      	ldr	r3, [r4, #0]
 8005216:	2003      	movs	r0, #3
 8005218:	1b19      	subs	r1, r3, r4
 800521a:	424a      	negs	r2, r1
 800521c:	414a      	adcs	r2, r1
 800521e:	b2d1      	uxtb	r1, r2
 8005220:	f7fb f9ce 	bl	80005c0 <_test_assert>
 8005224:	2800      	cmp	r0, #0
 8005226:	d1e3      	bne.n	80051f0 <mtx5_execute.lto_priv.90+0x20>
  test_assert(4, m1.m_owner == NULL, "still owned");
 8005228:	68a1      	ldr	r1, [r4, #8]
 800522a:	3004      	adds	r0, #4
 800522c:	424b      	negs	r3, r1
 800522e:	4159      	adcs	r1, r3
 8005230:	b2c9      	uxtb	r1, r1
 8005232:	f7fb f9c5 	bl	80005c0 <_test_assert>
 8005236:	2800      	cmp	r0, #0
 8005238:	d1da      	bne.n	80051f0 <mtx5_execute.lto_priv.90+0x20>
 800523a:	69ab      	ldr	r3, [r5, #24]
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800523c:	3005      	adds	r0, #5
 800523e:	6899      	ldr	r1, [r3, #8]
 8005240:	1b89      	subs	r1, r1, r6
 8005242:	424b      	negs	r3, r1
 8005244:	414b      	adcs	r3, r1
 8005246:	b2d9      	uxtb	r1, r3
 8005248:	f7fb f9ba 	bl	80005c0 <_test_assert>
 800524c:	2800      	cmp	r0, #0
 800524e:	d1cf      	bne.n	80051f0 <mtx5_execute.lto_priv.90+0x20>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 8005250:	0020      	movs	r0, r4
 8005252:	f7fb fe15 	bl	8000e80 <chMtxLock>
  chMtxUnlockAll();
 8005256:	f7fb fd2b 	bl	8000cb0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 800525a:	6823      	ldr	r3, [r4, #0]
 800525c:	2006      	movs	r0, #6
 800525e:	1b19      	subs	r1, r3, r4
 8005260:	424a      	negs	r2, r1
 8005262:	414a      	adcs	r2, r1
 8005264:	b2d1      	uxtb	r1, r2
 8005266:	f7fb f9ab 	bl	80005c0 <_test_assert>
 800526a:	2800      	cmp	r0, #0
 800526c:	d1c0      	bne.n	80051f0 <mtx5_execute.lto_priv.90+0x20>
  test_assert(7, m1.m_owner == NULL, "still owned");
 800526e:	68a3      	ldr	r3, [r4, #8]
 8005270:	3007      	adds	r0, #7
 8005272:	4259      	negs	r1, r3
 8005274:	4159      	adcs	r1, r3
 8005276:	b2c9      	uxtb	r1, r1
 8005278:	f7fb f9a2 	bl	80005c0 <_test_assert>
 800527c:	e7b8      	b.n	80051f0 <mtx5_execute.lto_priv.90+0x20>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 800527e:	69ab      	ldr	r3, [r5, #24]
  mp->m_next = currp->p_mtxlist;
  currp->p_mtxlist = mp;
 8005280:	3101      	adds	r1, #1
  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
  mp->m_next = currp->p_mtxlist;
 8005282:	6b9a      	ldr	r2, [r3, #56]	; 0x38

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8005284:	60a3      	str	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
 8005286:	60e2      	str	r2, [r4, #12]
  currp->p_mtxlist = mp;
 8005288:	639c      	str	r4, [r3, #56]	; 0x38
 800528a:	e7ab      	b.n	80051e4 <mtx5_execute.lto_priv.90+0x14>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 800528c:	69ab      	ldr	r3, [r5, #24]
  mp->m_next = currp->p_mtxlist;
 800528e:	6b9a      	ldr	r2, [r3, #56]	; 0x38

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8005290:	60a3      	str	r3, [r4, #8]
  mp->m_next = currp->p_mtxlist;
 8005292:	60e2      	str	r2, [r4, #12]
  currp->p_mtxlist = mp;
 8005294:	639c      	str	r4, [r3, #56]	; 0x38
 8005296:	e7b1      	b.n	80051fc <mtx5_execute.lto_priv.90+0x2c>
 8005298:	20000ac0 	.word	0x20000ac0
 800529c:	2000066c 	.word	0x2000066c

080052a0 <mtx5_setup.lto_priv.89>:
 80052a0:	b510      	push	{r4, lr}
 80052a2:	f7fd f8fd 	bl	80024a0 <mtx1_setup.lto_priv.85>
 80052a6:	bd10      	pop	{r4, pc}
	...

080052b0 <chThdCreateFromHeap.constprop.53>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80052b0:	b570      	push	{r4, r5, r6, lr}
 80052b2:	000e      	movs	r6, r1
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80052b4:	21a4      	movs	r1, #164	; 0xa4
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 80052b6:	0005      	movs	r5, r0
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 80052b8:	0049      	lsls	r1, r1, #1
 80052ba:	4816      	ldr	r0, [pc, #88]	; (8005314 <chThdCreateFromHeap.constprop.53+0x64>)
 80052bc:	f7fb feb8 	bl	8001030 <chHeapAlloc>
 80052c0:	1e04      	subs	r4, r0, #0
  if (wsp == NULL) {
 80052c2:	d024      	beq.n	800530e <chThdCreateFromHeap.constprop.53+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80052c4:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80052c6:	0003      	movs	r3, r0
 80052c8:	4a13      	ldr	r2, [pc, #76]	; (8005318 <chThdCreateFromHeap.constprop.53+0x68>)
 80052ca:	3325      	adds	r3, #37	; 0x25
 80052cc:	33ff      	adds	r3, #255	; 0xff
 80052ce:	60c3      	str	r3, [r0, #12]
 80052d0:	611a      	str	r2, [r3, #16]
 80052d2:	4a12      	ldr	r2, [pc, #72]	; (800531c <chThdCreateFromHeap.constprop.53+0x6c>)
 80052d4:	615e      	str	r6, [r3, #20]
 80052d6:	621a      	str	r2, [r3, #32]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80052d8:	2302      	movs	r3, #2
 80052da:	7703      	strb	r3, [r0, #28]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80052dc:	2300      	movs	r3, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80052de:	2201      	movs	r2, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80052e0:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80052e2:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80052e4:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 80052e6:	4b0e      	ldr	r3, [pc, #56]	; (8005320 <chThdCreateFromHeap.constprop.53+0x70>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80052e8:	6085      	str	r5, [r0, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80052ea:	6959      	ldr	r1, [r3, #20]
 80052ec:	6103      	str	r3, [r0, #16]
 80052ee:	6141      	str	r1, [r0, #20]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80052f0:	63c5      	str	r5, [r0, #60]	; 0x3c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80052f2:	7782      	strb	r2, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80052f4:	6108      	str	r0, [r1, #16]
 80052f6:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80052f8:	0003      	movs	r3, r0
 80052fa:	3324      	adds	r3, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80052fc:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80052fe:	3304      	adds	r3, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8005300:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8005302:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8005304:	7742      	strb	r2, [r0, #29]
  chSchWakeupS(tp, MSG_OK);
 8005306:	2100      	movs	r1, #0
 8005308:	f7fb fac2 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800530c:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800530e:	0020      	movs	r0, r4
 8005310:	bd70      	pop	{r4, r5, r6, pc}
 8005312:	46c0      	nop			; (mov r8, r8)
 8005314:	20000c38 	.word	0x20000c38
 8005318:	08004181 	.word	0x08004181
 800531c:	080001b1 	.word	0x080001b1
 8005320:	20000ac0 	.word	0x20000ac0
	...

08005330 <chThdCreateFromMemoryPool.constprop.52>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 8005330:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8005332:	4d18      	ldr	r5, [pc, #96]	; (8005394 <chThdCreateFromMemoryPool.constprop.52+0x64>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 8005334:	0006      	movs	r6, r0
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8005336:	0028      	movs	r0, r5
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
 8005338:	000f      	movs	r7, r1
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 800533a:	f7fb fa31 	bl	80007a0 <chPoolAlloc>
 800533e:	1e04      	subs	r4, r0, #0
  if (wsp == NULL) {
 8005340:	d025      	beq.n	800538e <chThdCreateFromMemoryPool.constprop.52+0x5e>
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005342:	b672      	cpsid	i

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8005344:	686b      	ldr	r3, [r5, #4]
 8005346:	4a14      	ldr	r2, [pc, #80]	; (8005398 <chThdCreateFromMemoryPool.constprop.52+0x68>)
 8005348:	3b24      	subs	r3, #36	; 0x24
 800534a:	18c3      	adds	r3, r0, r3
 800534c:	60c3      	str	r3, [r0, #12]
 800534e:	611a      	str	r2, [r3, #16]
 8005350:	4a12      	ldr	r2, [pc, #72]	; (800539c <chThdCreateFromMemoryPool.constprop.52+0x6c>)
 8005352:	615f      	str	r7, [r3, #20]
 8005354:	621a      	str	r2, [r3, #32]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8005356:	2300      	movs	r3, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8005358:	2101      	movs	r1, #1
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800535a:	2202      	movs	r2, #2
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800535c:	6383      	str	r3, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800535e:	6343      	str	r3, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8005360:	6183      	str	r3, [r0, #24]
  REG_INSERT(tp);
 8005362:	4b0f      	ldr	r3, [pc, #60]	; (80053a0 <chThdCreateFromMemoryPool.constprop.52+0x70>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8005364:	7781      	strb	r1, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8005366:	6959      	ldr	r1, [r3, #20]
 8005368:	6103      	str	r3, [r0, #16]
 800536a:	6141      	str	r1, [r0, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800536c:	6086      	str	r6, [r0, #8]
  tp->p_state = CH_STATE_WTSTART;
 800536e:	7702      	strb	r2, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8005370:	63c6      	str	r6, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8005372:	6108      	str	r0, [r1, #16]
 8005374:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8005376:	0003      	movs	r3, r0
 8005378:	3324      	adds	r3, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800537a:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800537c:	3304      	adds	r3, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800537e:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8005380:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 8005382:	7742      	strb	r2, [r0, #29]
  tp->p_mpool = mp;
 8005384:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 8005386:	2100      	movs	r1, #0
 8005388:	f7fb fa82 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800538c:	b662      	cpsie	i
  chSysUnlock();

  return tp;
}
 800538e:	0020      	movs	r0, r4
 8005390:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005392:	46c0      	nop			; (mov r8, r8)
 8005394:	20000c14 	.word	0x20000c14
 8005398:	08004181 	.word	0x08004181
 800539c:	080001b1 	.word	0x080001b1
 80053a0:	20000ac0 	.word	0x20000ac0
	...

080053b0 <chSemWaitTimeout.constprop.50>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 80053b0:	b510      	push	{r4, lr}
 80053b2:	0001      	movs	r1, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80053b4:	b672      	cpsid	i
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80053b6:	4b0d      	ldr	r3, [pc, #52]	; (80053ec <chSemWaitTimeout.constprop.50+0x3c>)
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 80053b8:	2000      	movs	r0, #0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 80053ba:	689c      	ldr	r4, [r3, #8]
 80053bc:	1e62      	subs	r2, r4, #1
 80053be:	609a      	str	r2, [r3, #8]
 80053c0:	2a00      	cmp	r2, #0
 80053c2:	db01      	blt.n	80053c8 <chSemWaitTimeout.constprop.50+0x18>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80053c4:	b662      	cpsie	i
  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
  chSysUnlock();

  return msg;
}
 80053c6:	bd10      	pop	{r4, pc}
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 80053c8:	2900      	cmp	r1, #0
 80053ca:	d00b      	beq.n	80053e4 <chSemWaitTimeout.constprop.50+0x34>
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 80053cc:	4a08      	ldr	r2, [pc, #32]	; (80053f0 <chSemWaitTimeout.constprop.50+0x40>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 80053ce:	6858      	ldr	r0, [r3, #4]
 80053d0:	6992      	ldr	r2, [r2, #24]
 80053d2:	6050      	str	r0, [r2, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 80053d4:	6013      	str	r3, [r2, #0]
 80053d6:	6213      	str	r3, [r2, #32]
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
 80053d8:	6002      	str	r2, [r0, #0]
  tqp->p_prev = tp;
 80053da:	605a      	str	r2, [r3, #4]
    sem_insert(currp, &sp->s_queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 80053dc:	2005      	movs	r0, #5
 80053de:	f7fb ff3f 	bl	8001260 <chSchGoSleepTimeoutS>
 80053e2:	e7ef      	b.n	80053c4 <chSemWaitTimeout.constprop.50+0x14>
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;
 80053e4:	609c      	str	r4, [r3, #8]

      return MSG_TIMEOUT;
 80053e6:	3801      	subs	r0, #1
 80053e8:	e7ec      	b.n	80053c4 <chSemWaitTimeout.constprop.50+0x14>
 80053ea:	46c0      	nop			; (mov r8, r8)
 80053ec:	200006ac 	.word	0x200006ac
 80053f0:	20000ac0 	.word	0x20000ac0
	...

08005400 <chSemSignalWait.constprop.48>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8005400:	b570      	push	{r4, r5, r6, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005402:	b672      	cpsid	i
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
 8005404:	4c12      	ldr	r4, [pc, #72]	; (8005450 <chSemSignalWait.constprop.48+0x50>)
 8005406:	68a3      	ldr	r3, [r4, #8]
 8005408:	3301      	adds	r3, #1
 800540a:	60a3      	str	r3, [r4, #8]
 800540c:	2b00      	cmp	r3, #0
 800540e:	dd15      	ble.n	800543c <chSemSignalWait.constprop.48+0x3c>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8005410:	3b01      	subs	r3, #1
 8005412:	60a3      	str	r3, [r4, #8]
 8005414:	2b00      	cmp	r3, #0
 8005416:	db04      	blt.n	8005422 <chSemSignalWait.constprop.48+0x22>
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->p_u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8005418:	f7fb fa12 	bl	8000840 <chSchRescheduleS>
    msg = MSG_OK;
 800541c:	2000      	movs	r0, #0
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800541e:	b662      	cpsie	i
  }
  chSysUnlock();

  return msg;
}
 8005420:	bd70      	pop	{r4, r5, r6, pc}
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8005422:	4b0c      	ldr	r3, [pc, #48]	; (8005454 <chSemSignalWait.constprop.48+0x54>)
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8005424:	2005      	movs	r0, #5
  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
  }
  if (--spw->s_cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8005426:	699d      	ldr	r5, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8005428:	6863      	ldr	r3, [r4, #4]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 800542a:	602c      	str	r4, [r5, #0]
  tp->p_prev = tqp->p_prev;
 800542c:	606b      	str	r3, [r5, #4]
  tp->p_prev->p_next = tp;
 800542e:	601d      	str	r5, [r3, #0]
  tqp->p_prev = tp;
 8005430:	6065      	str	r5, [r4, #4]
    sem_insert(ctp, &spw->s_queue);
    ctp->p_u.wtsemp = spw;
 8005432:	622c      	str	r4, [r5, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8005434:	f7fb fa9c 	bl	8000970 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8005438:	6a28      	ldr	r0, [r5, #32]
 800543a:	e7f0      	b.n	800541e <chSemSignalWait.constprop.48+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 800543c:	6820      	ldr	r0, [r4, #0]

  tqp->p_next = tp->p_next;
 800543e:	6803      	ldr	r3, [r0, #0]
 8005440:	6023      	str	r3, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005442:	605c      	str	r4, [r3, #4]
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->s_cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8005444:	f7fb fae4 	bl	8000a10 <chSchReadyI>
 8005448:	2300      	movs	r3, #0
 800544a:	6203      	str	r3, [r0, #32]
 800544c:	68a3      	ldr	r3, [r4, #8]
 800544e:	e7df      	b.n	8005410 <chSemSignalWait.constprop.48+0x10>
 8005450:	200006ac 	.word	0x200006ac
 8005454:	20000ac0 	.word	0x20000ac0
	...

08005460 <chCondSignal.constprop.44>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8005460:	b510      	push	{r4, lr}
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005462:	b672      	cpsid	i
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8005464:	4b05      	ldr	r3, [pc, #20]	; (800547c <chCondSignal.constprop.44+0x1c>)
 8005466:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->c_queue)) {
 8005468:	4298      	cmp	r0, r3
 800546a:	d005      	beq.n	8005478 <chCondSignal.constprop.44+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800546c:	6802      	ldr	r2, [r0, #0]
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 800546e:	2100      	movs	r1, #0
 8005470:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8005472:	6053      	str	r3, [r2, #4]
 8005474:	f7fb fa0c 	bl	8000890 <chSchWakeupS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005478:	b662      	cpsie	i
  }
  chSysUnlock();
}
 800547a:	bd10      	pop	{r4, pc}
 800547c:	200006a4 	.word	0x200006a4

08005480 <chCondSignalI.constprop.43>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8005480:	4b06      	ldr	r3, [pc, #24]	; (800549c <chCondSignalI.constprop.43+0x1c>)
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8005482:	b510      	push	{r4, lr}
 8005484:	6818      	ldr	r0, [r3, #0]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 8005486:	4298      	cmp	r0, r3
 8005488:	d006      	beq.n	8005498 <chCondSignalI.constprop.43+0x18>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800548a:	6802      	ldr	r2, [r0, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 800548c:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800548e:	601a      	str	r2, [r3, #0]
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
    tp->p_u.rdymsg = MSG_OK;
 8005490:	2300      	movs	r3, #0
 8005492:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8005494:	f7fb fabc 	bl	8000a10 <chSchReadyI>
  }
}
 8005498:	bd10      	pop	{r4, pc}
 800549a:	46c0      	nop			; (mov r8, r8)
 800549c:	200006a4 	.word	0x200006a4

080054a0 <chEvtGetAndClearEvents.constprop.36>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054a0:	b672      	cpsid	i
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
  currp->p_epending &= ~events;
 80054a2:	2200      	movs	r2, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->p_epending & events;
 80054a4:	4b02      	ldr	r3, [pc, #8]	; (80054b0 <chEvtGetAndClearEvents.constprop.36+0x10>)
 80054a6:	699b      	ldr	r3, [r3, #24]
 80054a8:	6b58      	ldr	r0, [r3, #52]	; 0x34
  currp->p_epending &= ~events;
 80054aa:	635a      	str	r2, [r3, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80054ac:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 80054ae:	4770      	bx	lr
 80054b0:	20000ac0 	.word	0x20000ac0
	...

080054c0 <chEvtWaitOne.constprop.32>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 80054c0:	4b09      	ldr	r3, [pc, #36]	; (80054e8 <chEvtWaitOne.constprop.32+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 80054c2:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 80054c4:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054c6:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80054c8:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80054ca:	2b00      	cmp	r3, #0
 80054cc:	d105      	bne.n	80054da <chEvtWaitOne.constprop.32+0x1a>
    ctp->p_u.ewmask = events;
 80054ce:	3b01      	subs	r3, #1
 80054d0:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80054d2:	200a      	movs	r0, #10
 80054d4:	f7fb fa4c 	bl	8000970 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80054d8:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80054da:	4258      	negs	r0, r3
 80054dc:	4018      	ands	r0, r3
  ctp->p_epending &= ~m;
 80054de:	4383      	bics	r3, r0
 80054e0:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80054e2:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 80054e4:	bd10      	pop	{r4, pc}
 80054e6:	46c0      	nop			; (mov r8, r8)
 80054e8:	20000ac0 	.word	0x20000ac0
 80054ec:	00000000 	.word	0x00000000

080054f0 <chEvtWaitAny.constprop.31>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 80054f0:	4b09      	ldr	r3, [pc, #36]	; (8005518 <chEvtWaitAny.constprop.31+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 80054f2:	b510      	push	{r4, lr}
  thread_t *ctp = currp;
 80054f4:	699c      	ldr	r4, [r3, #24]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80054f6:	b672      	cpsid	i
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
 80054f8:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80054fa:	2800      	cmp	r0, #0
 80054fc:	d106      	bne.n	800550c <chEvtWaitAny.constprop.31+0x1c>
    ctp->p_u.ewmask = events;
 80054fe:	2301      	movs	r3, #1
 8005500:	425b      	negs	r3, r3
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005502:	300a      	adds	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->p_epending & events;
  if (m == (eventmask_t)0) {
    ctp->p_u.ewmask = events;
 8005504:	6223      	str	r3, [r4, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005506:	f7fb fa33 	bl	8000970 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800550a:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->p_epending &= ~m;
 800550c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800550e:	4383      	bics	r3, r0
 8005510:	6363      	str	r3, [r4, #52]	; 0x34
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005512:	b662      	cpsie	i
  chSysUnlock();

  return m;
}
 8005514:	bd10      	pop	{r4, pc}
 8005516:	46c0      	nop			; (mov r8, r8)
 8005518:	20000ac0 	.word	0x20000ac0
 800551c:	00000000 	.word	0x00000000

08005520 <chMBPost.constprop.20>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8005520:	b570      	push	{r4, r5, r6, lr}
 8005522:	0006      	movs	r6, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005524:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8005526:	4c0d      	ldr	r4, [pc, #52]	; (800555c <chMBPost.constprop.20+0x3c>)
 8005528:	0020      	movs	r0, r4
 800552a:	301c      	adds	r0, #28
 800552c:	f7fb feb8 	bl	80012a0 <chSemWaitTimeoutS>
 8005530:	1e05      	subs	r5, r0, #0
  if (rdymsg == MSG_OK) {
 8005532:	d002      	beq.n	800553a <chMBPost.constprop.20+0x1a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005534:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005536:	0028      	movs	r0, r5
 8005538:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 800553a:	68a2      	ldr	r2, [r4, #8]
 800553c:	1d13      	adds	r3, r2, #4
 800553e:	60a3      	str	r3, [r4, #8]
 8005540:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8005542:	6862      	ldr	r2, [r4, #4]
 8005544:	4293      	cmp	r3, r2
 8005546:	d301      	bcc.n	800554c <chMBPost.constprop.20+0x2c>
      mbp->mb_wrptr = mbp->mb_buffer;
 8005548:	6823      	ldr	r3, [r4, #0]
 800554a:	60a3      	str	r3, [r4, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 800554c:	0020      	movs	r0, r4
 800554e:	3010      	adds	r0, #16
 8005550:	f7fb fdb6 	bl	80010c0 <chSemSignalI>
    chSchRescheduleS();
 8005554:	f7fb f974 	bl	8000840 <chSchRescheduleS>
 8005558:	e7ec      	b.n	8005534 <chMBPost.constprop.20+0x14>
 800555a:	46c0      	nop			; (mov r8, r8)
 800555c:	2000067c 	.word	0x2000067c

08005560 <chMBPostI.constprop.19>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8005560:	4b0c      	ldr	r3, [pc, #48]	; (8005594 <chMBPostI.constprop.19+0x34>)
 8005562:	b510      	push	{r4, lr}
 8005564:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8005566:	2a00      	cmp	r2, #0
 8005568:	dd11      	ble.n	800558e <chMBPostI.constprop.19+0x2e>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
 800556a:	6899      	ldr	r1, [r3, #8]
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt--;
 800556c:	3a01      	subs	r2, #1
 800556e:	625a      	str	r2, [r3, #36]	; 0x24
 8005570:	1d0a      	adds	r2, r1, #4
 8005572:	609a      	str	r2, [r3, #8]
 8005574:	6008      	str	r0, [r1, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8005576:	6859      	ldr	r1, [r3, #4]
 8005578:	428a      	cmp	r2, r1
 800557a:	d205      	bcs.n	8005588 <chMBPostI.constprop.19+0x28>
     mbp->mb_wrptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_fullsem);
 800557c:	3310      	adds	r3, #16
 800557e:	0018      	movs	r0, r3
 8005580:	f7fb fd9e 	bl	80010c0 <chSemSignalI>

  return MSG_OK;
 8005584:	2000      	movs	r0, #0
}
 8005586:	bd10      	pop	{r4, pc}
  }

  chSemFastWaitI(&mbp->mb_emptysem);
  *mbp->mb_wrptr++ = msg;
  if (mbp->mb_wrptr >= mbp->mb_top) {
     mbp->mb_wrptr = mbp->mb_buffer;
 8005588:	681a      	ldr	r2, [r3, #0]
 800558a:	609a      	str	r2, [r3, #8]
 800558c:	e7f6      	b.n	800557c <chMBPostI.constprop.19+0x1c>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 800558e:	2001      	movs	r0, #1
 8005590:	4240      	negs	r0, r0
 8005592:	e7f8      	b.n	8005586 <chMBPostI.constprop.19+0x26>
 8005594:	2000067c 	.word	0x2000067c
	...

080055a0 <chMBPostAhead.constprop.18>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80055a0:	b570      	push	{r4, r5, r6, lr}
 80055a2:	0006      	movs	r6, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80055a4:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 80055a6:	4c0d      	ldr	r4, [pc, #52]	; (80055dc <chMBPostAhead.constprop.18+0x3c>)
 80055a8:	0020      	movs	r0, r4
 80055aa:	301c      	adds	r0, #28
 80055ac:	f7fb fe78 	bl	80012a0 <chSemWaitTimeoutS>
 80055b0:	1e05      	subs	r5, r0, #0
  if (rdymsg == MSG_OK) {
 80055b2:	d002      	beq.n	80055ba <chMBPostAhead.constprop.18+0x1a>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80055b4:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 80055b6:	0028      	movs	r0, r5
 80055b8:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80055ba:	68e3      	ldr	r3, [r4, #12]
 80055bc:	6822      	ldr	r2, [r4, #0]
 80055be:	3b04      	subs	r3, #4
 80055c0:	60e3      	str	r3, [r4, #12]
 80055c2:	4293      	cmp	r3, r2
 80055c4:	d202      	bcs.n	80055cc <chMBPostAhead.constprop.18+0x2c>
      mbp->mb_rdptr = mbp->mb_top - 1;
 80055c6:	6863      	ldr	r3, [r4, #4]
 80055c8:	3b04      	subs	r3, #4
 80055ca:	60e3      	str	r3, [r4, #12]
    }
    *mbp->mb_rdptr = msg;
    chSemSignalI(&mbp->mb_fullsem);
 80055cc:	0020      	movs	r0, r4
  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
      mbp->mb_rdptr = mbp->mb_top - 1;
    }
    *mbp->mb_rdptr = msg;
 80055ce:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 80055d0:	3010      	adds	r0, #16
 80055d2:	f7fb fd75 	bl	80010c0 <chSemSignalI>
    chSchRescheduleS();
 80055d6:	f7fb f933 	bl	8000840 <chSchRescheduleS>
 80055da:	e7eb      	b.n	80055b4 <chMBPostAhead.constprop.18+0x14>
 80055dc:	2000067c 	.word	0x2000067c

080055e0 <chMBPostAheadI.constprop.17>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 80055e0:	4b0d      	ldr	r3, [pc, #52]	; (8005618 <chMBPostAheadI.constprop.17+0x38>)
 80055e2:	b510      	push	{r4, lr}
 80055e4:	6a5a      	ldr	r2, [r3, #36]	; 0x24

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 80055e6:	2a00      	cmp	r2, #0
 80055e8:	dd12      	ble.n	8005610 <chMBPostAheadI.constprop.17+0x30>
 80055ea:	3a01      	subs	r2, #1
 80055ec:	625a      	str	r2, [r3, #36]	; 0x24
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 80055ee:	68da      	ldr	r2, [r3, #12]
 80055f0:	6819      	ldr	r1, [r3, #0]
 80055f2:	3a04      	subs	r2, #4
 80055f4:	60da      	str	r2, [r3, #12]
 80055f6:	428a      	cmp	r2, r1
 80055f8:	d306      	bcc.n	8005608 <chMBPostAheadI.constprop.17+0x28>
    mbp->mb_rdptr = mbp->mb_top - 1;
  }
  *mbp->mb_rdptr = msg;
  chSemSignalI(&mbp->mb_fullsem);
 80055fa:	3310      	adds	r3, #16
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    mbp->mb_rdptr = mbp->mb_top - 1;
  }
  *mbp->mb_rdptr = msg;
 80055fc:	6010      	str	r0, [r2, #0]
  chSemSignalI(&mbp->mb_fullsem);
 80055fe:	0018      	movs	r0, r3
 8005600:	f7fb fd5e 	bl	80010c0 <chSemSignalI>

  return MSG_OK;
 8005604:	2000      	movs	r0, #0
}
 8005606:	bd10      	pop	{r4, pc}
  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_emptysem);
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
    mbp->mb_rdptr = mbp->mb_top - 1;
 8005608:	685a      	ldr	r2, [r3, #4]
 800560a:	3a04      	subs	r2, #4
 800560c:	60da      	str	r2, [r3, #12]
 800560e:	e7f4      	b.n	80055fa <chMBPostAheadI.constprop.17+0x1a>

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 8005610:	2001      	movs	r0, #1
 8005612:	4240      	negs	r0, r0
 8005614:	e7f7      	b.n	8005606 <chMBPostAheadI.constprop.17+0x26>
 8005616:	46c0      	nop			; (mov r8, r8)
 8005618:	2000067c 	.word	0x2000067c
 800561c:	00000000 	.word	0x00000000

08005620 <chMBFetch.constprop.16>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8005620:	b570      	push	{r4, r5, r6, lr}
 8005622:	0006      	movs	r6, r0
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005624:	b672      	cpsid	i
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8005626:	4c0d      	ldr	r4, [pc, #52]	; (800565c <chMBFetch.constprop.16+0x3c>)
 8005628:	0020      	movs	r0, r4
 800562a:	3010      	adds	r0, #16
 800562c:	f7fb fe38 	bl	80012a0 <chSemWaitTimeoutS>
 8005630:	0005      	movs	r5, r0
 8005632:	0020      	movs	r0, r4
  if (rdymsg == MSG_OK) {
 8005634:	2d00      	cmp	r5, #0
 8005636:	d10e      	bne.n	8005656 <chMBFetch.constprop.16+0x36>
    *msgp = *mbp->mb_rdptr++;
 8005638:	68e2      	ldr	r2, [r4, #12]
 800563a:	1d13      	adds	r3, r2, #4
 800563c:	6812      	ldr	r2, [r2, #0]
 800563e:	60e3      	str	r3, [r4, #12]
 8005640:	6032      	str	r2, [r6, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8005642:	6862      	ldr	r2, [r4, #4]
 8005644:	4293      	cmp	r3, r2
 8005646:	d301      	bcc.n	800564c <chMBFetch.constprop.16+0x2c>
      mbp->mb_rdptr = mbp->mb_buffer;
 8005648:	6823      	ldr	r3, [r4, #0]
 800564a:	60e3      	str	r3, [r4, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 800564c:	301c      	adds	r0, #28
 800564e:	f7fb fd37 	bl	80010c0 <chSemSignalI>
    chSchRescheduleS();
 8005652:	f7fb f8f5 	bl	8000840 <chSchRescheduleS>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005656:	b662      	cpsie	i
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005658:	0028      	movs	r0, r5
 800565a:	bd70      	pop	{r4, r5, r6, pc}
 800565c:	2000067c 	.word	0x2000067c

08005660 <chMBFetchI.constprop.15>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8005660:	4b0c      	ldr	r3, [pc, #48]	; (8005694 <chMBFetchI.constprop.15+0x34>)
 8005662:	b510      	push	{r4, lr}
 8005664:	699a      	ldr	r2, [r3, #24]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8005666:	2a00      	cmp	r2, #0
 8005668:	dd11      	ble.n	800568e <chMBFetchI.constprop.15+0x2e>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->mb_fullsem);
  *msgp = *mbp->mb_rdptr++;
 800566a:	68d9      	ldr	r1, [r3, #12]
 800566c:	3a01      	subs	r2, #1
 800566e:	619a      	str	r2, [r3, #24]
 8005670:	1d0a      	adds	r2, r1, #4
 8005672:	6809      	ldr	r1, [r1, #0]
 8005674:	60da      	str	r2, [r3, #12]
 8005676:	6001      	str	r1, [r0, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8005678:	6859      	ldr	r1, [r3, #4]
 800567a:	428a      	cmp	r2, r1
 800567c:	d301      	bcc.n	8005682 <chMBFetchI.constprop.15+0x22>
    mbp->mb_rdptr = mbp->mb_buffer;
 800567e:	681a      	ldr	r2, [r3, #0]
 8005680:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 8005682:	331c      	adds	r3, #28
 8005684:	0018      	movs	r0, r3
 8005686:	f7fb fd1b 	bl	80010c0 <chSemSignalI>

  return MSG_OK;
 800568a:	2000      	movs	r0, #0
 800568c:	e001      	b.n	8005692 <chMBFetchI.constprop.15+0x32>

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
 800568e:	2001      	movs	r0, #1
 8005690:	4240      	negs	r0, r0
    mbp->mb_rdptr = mbp->mb_buffer;
  }
  chSemSignalI(&mbp->mb_emptysem);

  return MSG_OK;
}
 8005692:	bd10      	pop	{r4, pc}
 8005694:	2000067c 	.word	0x2000067c
	...

080056a0 <_pal_lld_setgroupmode.constprop.5>:
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80056a0:	2307      	movs	r3, #7
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80056a2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80056a4:	464d      	mov	r5, r9
 80056a6:	4644      	mov	r4, r8
 80056a8:	4656      	mov	r6, sl
 80056aa:	465f      	mov	r7, fp
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80056ac:	2203      	movs	r2, #3
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80056ae:	4699      	mov	r9, r3
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80056b0:	3308      	adds	r3, #8
 80056b2:	4698      	mov	r8, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80056b4:	2390      	movs	r3, #144	; 0x90
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80056b6:	b4f0      	push	{r4, r5, r6, r7}
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80056b8:	4694      	mov	ip, r2
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80056ba:	3a01      	subs	r2, #1
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80056bc:	b083      	sub	sp, #12
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 80056be:	2100      	movs	r1, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80056c0:	2402      	movs	r4, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 80056c2:	2501      	movs	r5, #1

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80056c4:	05db      	lsls	r3, r3, #23
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80056c6:	4692      	mov	sl, r2
 80056c8:	e008      	b.n	80056dc <_pal_lld_setgroupmode.constprop.5+0x3c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80056ca:	6a1a      	ldr	r2, [r3, #32]
 80056cc:	43b2      	bics	r2, r6
 80056ce:	9e01      	ldr	r6, [sp, #4]
 80056d0:	4316      	orrs	r6, r2
 80056d2:	621e      	str	r6, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
 80056d4:	0840      	lsrs	r0, r0, #1
    if (!mask)
 80056d6:	d02d      	beq.n	8005734 <_pal_lld_setgroupmode.constprop.5+0x94>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 80056d8:	00a4      	lsls	r4, r4, #2
    bit++;
 80056da:	3101      	adds	r1, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 80056dc:	4205      	tst	r5, r0
 80056de:	d0f9      	beq.n	80056d4 <_pal_lld_setgroupmode.constprop.5+0x34>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80056e0:	464a      	mov	r2, r9
 80056e2:	002e      	movs	r6, r5
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80056e4:	4647      	mov	r7, r8
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80056e6:	400a      	ands	r2, r1
 80056e8:	0092      	lsls	r2, r2, #2
 80056ea:	4096      	lsls	r6, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80056ec:	4097      	lsls	r7, r2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80056ee:	9601      	str	r6, [sp, #4]
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80056f0:	003e      	movs	r6, r7
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80056f2:	002f      	movs	r7, r5
 80056f4:	408f      	lsls	r7, r1
 80056f6:	685a      	ldr	r2, [r3, #4]
 80056f8:	43ba      	bics	r2, r7
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80056fa:	4667      	mov	r7, ip

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80056fc:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80056fe:	689a      	ldr	r2, [r3, #8]
 8005700:	4693      	mov	fp, r2
 8005702:	004a      	lsls	r2, r1, #1
 8005704:	4097      	lsls	r7, r2
 8005706:	43fa      	mvns	r2, r7
 8005708:	465f      	mov	r7, fp
 800570a:	4017      	ands	r7, r2
 800570c:	609f      	str	r7, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800570e:	68df      	ldr	r7, [r3, #12]
 8005710:	4017      	ands	r7, r2
 8005712:	60df      	str	r7, [r3, #12]
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8005714:	2c02      	cmp	r4, #2
 8005716:	d014      	beq.n	8005742 <_pal_lld_setgroupmode.constprop.5+0xa2>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8005718:	681f      	ldr	r7, [r3, #0]
 800571a:	403a      	ands	r2, r7
 800571c:	4322      	orrs	r2, r4
 800571e:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8005720:	2907      	cmp	r1, #7
 8005722:	d9d2      	bls.n	80056ca <_pal_lld_setgroupmode.constprop.5+0x2a>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8005724:	6a5a      	ldr	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 8005726:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8005728:	43b2      	bics	r2, r6
 800572a:	9e01      	ldr	r6, [sp, #4]
 800572c:	4316      	orrs	r6, r2
 800572e:	625e      	str	r6, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8005730:	2800      	cmp	r0, #0
 8005732:	d1d1      	bne.n	80056d8 <_pal_lld_setgroupmode.constprop.5+0x38>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8005734:	b003      	add	sp, #12
 8005736:	bc3c      	pop	{r2, r3, r4, r5}
 8005738:	4690      	mov	r8, r2
 800573a:	4699      	mov	r9, r3
 800573c:	46a2      	mov	sl, r4
 800573e:	46ab      	mov	fp, r5
 8005740:	bdf0      	pop	{r4, r5, r6, r7, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8005742:	2907      	cmp	r1, #7
 8005744:	d80a      	bhi.n	800575c <_pal_lld_setgroupmode.constprop.5+0xbc>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8005746:	6a1f      	ldr	r7, [r3, #32]
 8005748:	43b7      	bics	r7, r6
 800574a:	9e01      	ldr	r6, [sp, #4]
 800574c:	433e      	orrs	r6, r7
 800574e:	621e      	str	r6, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8005750:	681e      	ldr	r6, [r3, #0]
 8005752:	4032      	ands	r2, r6
 8005754:	4656      	mov	r6, sl
 8005756:	4332      	orrs	r2, r6
 8005758:	601a      	str	r2, [r3, #0]
 800575a:	e7bb      	b.n	80056d4 <_pal_lld_setgroupmode.constprop.5+0x34>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800575c:	6a5f      	ldr	r7, [r3, #36]	; 0x24
 800575e:	43b7      	bics	r7, r6
 8005760:	9e01      	ldr	r6, [sp, #4]
 8005762:	433e      	orrs	r6, r7
 8005764:	625e      	str	r6, [r3, #36]	; 0x24
 8005766:	e7f3      	b.n	8005750 <_pal_lld_setgroupmode.constprop.5+0xb0>
	...

08005770 <test_start_timer.constprop.1>:
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 8005770:	2200      	movs	r2, #0
 8005772:	4b09      	ldr	r3, [pc, #36]	; (8005798 <test_start_timer.constprop.1+0x28>)
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 8005774:	b510      	push	{r4, lr}

  systime_t duration = MS2ST(ms);
  test_timer_done = FALSE;
 8005776:	701a      	strb	r2, [r3, #0]
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005778:	b672      	cpsid	i
 800577a:	4c08      	ldr	r4, [pc, #32]	; (800579c <test_start_timer.constprop.1+0x2c>)
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 800577c:	68e3      	ldr	r3, [r4, #12]
 800577e:	2b00      	cmp	r3, #0
 8005780:	d002      	beq.n	8005788 <test_start_timer.constprop.1+0x18>
    chVTDoResetI(vtp);
 8005782:	0020      	movs	r0, r4
 8005784:	f7fb fcec 	bl	8001160 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8005788:	2300      	movs	r3, #0
 800578a:	4a05      	ldr	r2, [pc, #20]	; (80057a0 <test_start_timer.constprop.1+0x30>)
 800578c:	4905      	ldr	r1, [pc, #20]	; (80057a4 <test_start_timer.constprop.1+0x34>)
 800578e:	0020      	movs	r0, r4
 8005790:	f7fb fd26 	bl	80011e0 <chVTDoSetI>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8005794:	b662      	cpsie	i
  chVTSet(&vt, duration, tmr, NULL);
}
 8005796:	bd10      	pop	{r4, pc}
 8005798:	20000c10 	.word	0x20000c10
 800579c:	20000c20 	.word	0x20000c20
 80057a0:	080024e1 	.word	0x080024e1
 80057a4:	00002710 	.word	0x00002710
	...
 80057b0:	080003d2 	.word	0x080003d2
 80057b4:	080003b2 	.word	0x080003b2
 80057b8:	080003b2 	.word	0x080003b2
 80057bc:	080003d6 	.word	0x080003d6
 80057c0:	080003a8 	.word	0x080003a8
 80057c4:	080003a0 	.word	0x080003a0
 80057c8:	080003b2 	.word	0x080003b2
 80057cc:	080003a8 	.word	0x080003a8
 80057d0:	00000a0d 	.word	0x00000a0d
	...

080057e0 <ram_areas>:
 80057e0:	080065e8 200012c0 200012c0 200012c0     .e..... ... ... 
 80057f0:	080065e8 00000000 00000000 00000000     .e..............
 8005800:	080065e8 00000000 00000000 00000000     .e..............
 8005810:	080065e8 00000000 00000000 00000000     .e..............
 8005820:	080065e8 00000000 00000000 00000000     .e..............
 8005830:	080065e8 00000000 00000000 00000000     .e..............
 8005840:	080065e8 00000000 00000000 00000000     .e..............
 8005850:	080065e8 00000000 00000000 00000000     .e..............

08005860 <testmtx4>:
 8005860:	0800634c 08002481 00000000 080024f1     Lc...$.......$..

08005870 <testmtx5>:
 8005870:	0800633c 080052a1 00000000 080051d1     <c...R.......Q..

08005880 <testmtx6>:
 8005880:	08006324 08004861 00000000 080050f1     $c..aH.......P..

08005890 <testmtx7>:
 8005890:	0800630c 08004881 00000000 08005001     .c...H.......P..

080058a0 <testmtx8>:
 80058a0:	080062f8 08004831 00000000 08004e51     .b..1H......QN..

080058b0 <patternmsg>:
 80058b0:	080058c0 00000000 00000000 00000000     .X..............

080058c0 <testmsg1>:
 80058c0:	080062e8 00000000 00000000 08004dd1     .b...........M..

080058d0 <patternbmk>:
 80058d0:	08005a20 08005a30 08005a40 08005a50      Z..0Z..@Z..PZ..
 80058e0:	08005a60 08005a70 080059e0 08005a90     `Z..pZ...Y...Z..
 80058f0:	08005aa0 080059f0 08005910 08005a00     .Z...Y...Y...Z..
 8005900:	08005a10 00000000 00000000 00000000     .Z..............

08005910 <testbmk11>:
 8005910:	08006018 080016c1 00000000 08001951     .`..........Q...

08005920 <ch_debug>:
 8005920:	6e69616d 18441600 08440404 1814100c     main..D...D.....
 8005930:	1e1d1c00 00000000 00000000 00000000     ................

08005940 <testsys3>:
 8005940:	08006460 00000000 00000000 080035a1     `d...........5..

08005950 <testevt2>:
 8005950:	08006288 080043a1 00000000 08004491     .b...C.......D..

08005960 <patterndyn>:
 8005960:	08005af0 08005b00 08005b10 00000000     .Z...[...[......

08005970 <vmt>:
 8005970:	080013a1 080014a1 08001411 08001501     ................
 8005980:	08001401 080014f1 08001391 08001491     ................

08005990 <testsem1>:
 8005990:	080063e4 080024b1 00000000 08002d31     .c...$......1-..

080059a0 <testsem2>:
 80059a0:	080063d0 080024d1 00000000 08002be1     .c...$.......+..

080059b0 <testsem3>:
 80059b0:	080063b0 080024c1 00000000 08002b31     .c...$......1+..

080059c0 <testsys1>:
 80059c0:	08006490 00000000 00000000 08003611     .d...........6..

080059d0 <testsys2>:
 80059d0:	08006474 00000000 00000000 08003221     td..........!2..

080059e0 <testbmk7>:
 80059e0:	080060b0 080016e1 00000000 08001c41     .`..........A...

080059f0 <testbmk10>:
 80059f0:	0800603c 00000000 00000000 080019f1     <`..............

08005a00 <testbmk12>:
 8005a00:	08005ff8 080016b1 00000000 08001861     ._..........a...

08005a10 <testbmk13>:
 8005a10:	08005fdc 00000000 00000000 08001771     ._..........q...

08005a20 <testbmk1>:
 8005a20:	08006164 00000000 00000000 08003531     da..........15..

08005a30 <testbmk2>:
 8005a30:	0800614c 00000000 00000000 080034c1     La...........4..

08005a40 <testbmk3>:
 8005a40:	08006134 00000000 00000000 080033d1     4a...........3..

08005a50 <testbmk4>:
 8005a50:	08006118 00000000 00000000 080032c1     .a...........2..

08005a60 <testbmk5>:
 8005a60:	080060f8 00000000 00000000 08001d71     .`..........q...

08005a70 <testbmk6>:
 8005a70:	080060d8 00000000 00000000 080018d1     .`..............

08005a80 <patternsys>:
 8005a80:	080059c0 080059d0 08005940 00000000     .Y...Y..@Y......

08005a90 <testbmk8>:
 8005a90:	08006084 00000000 00000000 08001b21     .`..........!...

08005aa0 <testbmk9>:
 8005aa0:	08006060 00000000 00000000 08001a71     ``..........q...

08005ab0 <patterns>:
 8005ab0:	08005a80 08005b70 08005c00 08005c80     .Z..p[...\...\..
 8005ac0:	080058b0 08005bb0 08005c40 08005b30     .X...[..@\..0[..
 8005ad0:	08005b60 08005960 08005b40 080058d0     `[..`Y..@[...X..
	...

08005af0 <testdyn1>:
 8005af0:	08006204 08003dc1 00000000 08003e51     .b...=......Q>..

08005b00 <testdyn2>:
 8005b00:	080061d4 080032a1 00000000 08003cb1     .a...2.......<..

08005b10 <testdyn3>:
 8005b10:	080061ac 08003ca1 00000000 08003b81     .a...<.......;..

08005b20 <testmbox1>:
 8005b20:	080062c8 08004801 00000000 080048a1     .b...H.......H..

08005b30 <patternheap>:
 8005b30:	08005c60 00000000 00000000 00000000     `\..............

08005b40 <patternqueues>:
 8005b40:	08005b90 08005ba0 00000000 00000000     .[...[..........

08005b50 <testpools1>:
 8005b50:	08006230 08003e01 00000000 08004191     0b...>.......A..

08005b60 <patternpools>:
 8005b60:	08005b50 00000000 00000000 00000000     P[..............

08005b70 <patternthd>:
 8005b70:	08005bc0 08005bd0 08005be0 08005c20     .[...[...[.. \..
	...

08005b90 <testqueues1>:
 8005b90:	08006194 08003271 00000000 08003911     .a..q2.......9..

08005ba0 <testqueues2>:
 8005ba0:	0800617c 08003241 00000000 080036e1     |a..A2.......6..

08005bb0 <patternmbox>:
 8005bb0:	08005b20 00000000 00000000 00000000      [..............

08005bc0 <testthd1>:
 8005bc0:	08006444 00000000 00000000 080028b1     Dd...........(..

08005bd0 <testthd2>:
 8005bd0:	08006428 00000000 00000000 08002eb1     (d..............

08005be0 <testthd3>:
 8005be0:	0800640c 00000000 00000000 080030c1     .d...........0..

08005bf0 <testsem4>:
 8005bf0:	0800638c 00000000 00000000 08002a21     .c..........!*..

08005c00 <patternsem>:
 8005c00:	08005990 080059a0 080059b0 08005bf0     .Y...Y...Y...[..
	...

08005c20 <testthd4>:
 8005c20:	080063fc 00000000 00000000 08003011     .c...........0..

08005c30 <testmtx1>:
 8005c30:	08006368 080024a1 00000000 080027b1     hc...$.......'..

08005c40 <patternevt>:
 8005c40:	08005c50 08005950 08005c70 00000000     P\..PY..p\......

08005c50 <testevt1>:
 8005c50:	080062a4 08004891 00000000 080043b1     .b...H.......C..

08005c60 <testheap1>:
 8005c60:	0800624c 08003e21 00000000 08003f31     Lb..!>......1?..

08005c70 <testevt3>:
 8005c70:	08006274 08004391 00000000 08004261     tb...C......aB..

08005c80 <patternmtx>:
 8005c80:	08005c30 08005860 08005870 08005880     0\..`X..pX...X..
 8005c90:	08005890 080058a0 00000000 00000000     .X...X..........
 8005ca0:	6e696c62 3172656b 00000000 6e696c62     blinker1....blin
 8005cb0:	3272656b 00000000 202d2d2d 74737953     ker2....--- Syst
 8005cc0:	203a6d65 00000000 74796220 00007365     em: .... bytes..
 8005cd0:	202d2d2d 65726854 203a6461 00000000     --- Thread: ....
 8005ce0:	202d2d2d 656d6954 203a2072 00000000     --- Timer : ....
 8005cf0:	202d2d2d 616d6553 203a6870 00000000     --- Semaph: ....
 8005d00:	202d2d2d 6e657645 203a5374 00000000     --- EventS: ....
 8005d10:	202d2d2d 6e657645 203a4c74 00000000     --- EventL: ....
 8005d20:	202d2d2d 6574754d 203a2078 00000000     --- Mutex : ....
 8005d30:	202d2d2d 646e6f43 203a2e56 00000000     --- CondV.: ....
 8005d40:	202d2d2d 75657551 203a2065 00000000     --- Queue : ....
 8005d50:	202d2d2d 6c69614d 203a2e42 00000000     --- MailB.: ....
 8005d60:	202d2d2d 726f6353 203a2065 00000000     --- Score : ....
 8005d70:	636f6c20 6e752b6b 6b636f6c 0000532f      lock+unlock/S..
 8005d80:	72687420 73646165 0000532f 69617720      threads/S.. wai
 8005d90:	69732b74 6c616e67 0000532f 6d697420     t+signal/S.. tim
 8005da0:	2f737265 00000053 74796220 532f7365     ers/S... bytes/S
 8005db0:	00000000 78746320 2f637773 00000053     .... ctxswc/S...
 8005dc0:	73657220 64656863 73656c75 202c532f      reschedules/S, 
 8005dd0:	00000000 202a2a2a 6e72654b 203a6c65     ....*** Kernel: 
 8005de0:	20202020 00002020 202a2a2a 706d6f43           ..*** Comp
 8005df0:	64656c69 2020203a 00002020 202a2a2a     iled:     ..*** 
 8005e00:	706d6f43 72656c69 2020203a 00002020     Compiler:     ..
 8005e10:	202a2a2a 68637241 63657469 65727574     *** Architecture
 8005e20:	0000203a 202a2a2a 65726f43 72615620     : ..*** Core Var
 8005e30:	746e6169 0000203a 202a2a2a 74726f50     iant: ..*** Port
 8005e40:	666e4920 20203a6f 00002020 202a2a2a      Info:    ..*** 
 8005e50:	74616c50 6d726f66 2020203a 00002020     Platform:     ..
 8005e60:	202a2a2a 74736554 616f4220 203a6472     *** Test Board: 
 8005e70:	00002020 202d2d2d 74736554 73614320       ..--- Test Cas
 8005e80:	00002065 00002820 202d2d2d 75736552     e .. (..--- Resu
 8005e90:	203a746c 4c494146 20455255 00002328     lt: FAILURE (#..
 8005ea0:	00005b20 616e6946 6572206c 746c7573      [..Final result
 8005eb0:	0000203a 656c6469 00000000 202a2a2a     : ..idle....*** 
 8005ec0:	62696843 2f534f69 74205452 20747365     ChibiOS/RT test 
 8005ed0:	74697573 00000065 002a2a2a 00000029     suite...***.)...
 8005ee0:	0000295d 202d2d2d 75736552 203a746c     ])..--- Result: 
 8005ef0:	43435553 00535345 4c494146 00455255     SUCCESS.FAILURE.
 8005f00:	2e312e33 00000034 206c754a 32203332     3.1.4...Jul 23 2
 8005f10:	20363130 3032202d 3a31333a 00003731     016 - 20:31:17..
 8005f20:	20434347 2e342e35 30322031 36303631     GCC 5.4.1 201606
 8005f30:	28203930 656c6572 29657361 52415b20     09 (release) [AR
 8005f40:	6d652f4d 64646562 352d6465 6172622d     M/embedded-5-bra
 8005f50:	2068636e 69766572 6e6f6973 37333220     nch revision 237
 8005f60:	5d353137 00000000 764d5241 004d2d36     715]....ARMv6-M.
 8005f70:	74726f43 4d2d7865 00000030 65657250     Cortex-M0...Pree
 8005f80:	6974706d 74206e6f 756f7268 4e206867     mption through N
 8005f90:	0000494d 334d5453 35304632 20387831     MI..STM32F051x8 
 8005fa0:	72746e45 654c2079 206c6576 6964654d     Entry Level Medi
 8005fb0:	44206d75 69736e65 64207974 63697665     um Density devic
 8005fc0:	00007365 53205453 32334d54 442d3046     es..ST STM32F0-D
 8005fd0:	6f637369 79726576 00000000 636e6542     iscovery....Benc
 8005fe0:	72616d68 52202c6b 66204d41 70746f6f     hmark, RAM footp
 8005ff0:	746e6972 00000000 636e6542 72616d68     rint....Benchmar
 8006000:	6d202c6b 78657475 6c207365 2f6b636f     k, mutexes lock/
 8006010:	6f6c6e75 00006b63 636e6542 72616d68     unlock..Benchmar
 8006020:	73202c6b 70616d65 65726f68 61772073     k, semaphores wa
 8006030:	732f7469 616e6769 0000006c 636e6542     it/signal...Benc
 8006040:	72616d68 76202c6b 75747269 74206c61     hmark, virtual t
 8006050:	72656d69 65732073 65722f74 00746573     imers set/reset.
 8006060:	636e6542 72616d68 49202c6b 51204f2f     Benchmark, I/O Q
 8006070:	65756575 68742073 67756f72 74757068     ueues throughput
 8006080:	00000000 636e6542 72616d68 72202c6b     ....Benchmark, r
 8006090:	646e756f 626f7220 63206e69 65746e6f     ound robin conte
 80060a0:	73207478 63746977 676e6968 00000000     xt switching....
 80060b0:	636e6542 72616d68 6d202c6b 20737361     Benchmark, mass 
 80060c0:	63736572 75646568 202c656c 68742035     reschedule, 5 th
 80060d0:	64616572 00000073 636e6542 72616d68     reads...Benchmar
 80060e0:	74202c6b 61657268 202c7364 61657263     k, threads, crea
 80060f0:	6f206574 00796c6e 636e6542 72616d68     te only.Benchmar
 8006100:	74202c6b 61657268 202c7364 6c6c7566     k, threads, full
 8006110:	63796320 0000656c 636e6542 72616d68      cycle..Benchmar
 8006120:	63202c6b 65746e6f 73207478 63746977     k, context switc
 8006130:	00000068 636e6542 72616d68 6d202c6b     h...Benchmark, m
 8006140:	61737365 20736567 00003323 636e6542     essages #3..Benc
 8006150:	72616d68 6d202c6b 61737365 20736567     hmark, messages 
 8006160:	00003223 636e6542 72616d68 6d202c6b     #2..Benchmark, m
 8006170:	61737365 20736567 00003123 75657551     essages #1..Queu
 8006180:	202c7365 7074756f 71207475 65756575     es, output queue
 8006190:	00000073 75657551 202c7365 75706e69     s...Queues, inpu
 80061a0:	75712074 73657565 00000000 616e7944     t queues....Dyna
 80061b0:	2063696d 73495041 6572202c 74736967     mic APIs, regist
 80061c0:	61207972 7220646e 72656665 65636e65     ry and reference
 80061d0:	00000073 616e7944 2063696d 73495041     s...Dynamic APIs
 80061e0:	6874202c 64616572 72632073 69746165     , threads creati
 80061f0:	66206e6f 206d6f72 6f6d656d 70207972     on from memory p
 8006200:	006c6f6f 616e7944 2063696d 73495041     ool.Dynamic APIs
 8006210:	6874202c 64616572 72632073 69746165     , threads creati
 8006220:	66206e6f 206d6f72 70616568 00000000     on from heap....
 8006230:	6f6d654d 50207972 736c6f6f 7571202c     Memory Pools, qu
 8006240:	2f657565 75716564 00657565 70616548     eue/dequeue.Heap
 8006250:	6c61202c 61636f6c 6e6f6974 646e6120     , allocation and
 8006260:	61726620 6e656d67 69746174 74206e6f      fragmentation t
 8006270:	00747365 6e657645 202c7374 656d6974     est.Events, time
 8006280:	7374756f 00000000 6e657645 202c7374     outs....Events, 
 8006290:	74696177 646e6120 6f726220 61636461     wait and broadca
 80062a0:	00007473 6e657645 202c7374 69676572     st..Events, regi
 80062b0:	61727473 6e6f6974 646e6120 73696420     stration and dis
 80062c0:	63746170 00000068 6c69614d 65786f62     patch...Mailboxe
 80062d0:	71202c73 69756575 6120676e 7420646e     s, queuing and t
 80062e0:	6f656d69 00737475 7373654d 73656761     imeouts.Messages
 80062f0:	6f6c202c 0000706f 646e6f43 2c726156     , loop..CondVar,
 8006300:	6f6f6220 74207473 00747365 646e6f43      boost test.Cond
 8006310:	2c726156 6f726220 61636461 74207473     Var, broadcast t
 8006320:	00747365 646e6f43 2c726156 67697320     est.CondVar, sig
 8006330:	206c616e 74736574 00000000 6574754d     nal test....Mute
 8006340:	2c736578 61747320 00737574 6574754d     xes, status.Mute
 8006350:	2c736578 69727020 7469726f 65722079     xes, priority re
 8006360:	6e727574 00000000 6574754d 2c736578     turn....Mutexes,
 8006370:	69727020 7469726f 6e652079 75657571      priority enqueu
 8006380:	20676e69 74736574 00000000 616e6942     ing test....Bina
 8006390:	53207972 70616d65 65726f68 66202c73     ry Semaphores, f
 80063a0:	74636e75 616e6f69 7974696c 00000000     unctionality....
 80063b0:	616d6553 726f6870 202c7365 6d6f7461     Semaphores, atom
 80063c0:	73206369 616e6769 61772d6c 00007469     ic signal-wait..
 80063d0:	616d6553 726f6870 202c7365 656d6974     Semaphores, time
 80063e0:	0074756f 616d6553 726f6870 202c7365     out.Semaphores, 
 80063f0:	75716e65 6e697565 00000067 65726854     enqueuing...Thre
 8006400:	2c736461 6c656420 00737961 65726854     ads, delays.Thre
 8006410:	2c736461 69727020 7469726f 68632079     ads, priority ch
 8006420:	65676e61 00000000 65726854 2c736461     ange....Threads,
 8006430:	716e6520 69756575 7420676e 20747365      enqueuing test 
 8006440:	00003223 65726854 2c736461 716e6520     #2..Threads, enq
 8006450:	69756575 7420676e 20747365 00003123     ueuing test #1..
 8006460:	74737953 202c6d65 65746e69 74697267     System, integrit
 8006470:	00000079 74737953 202c6d65 65746e69     y...System, inte
 8006480:	70757272 68207374 6c646e61 00676e69     rrupts handling.
 8006490:	74737953 202c6d65 74697263 6c616369     System, critical
 80064a0:	6e6f7a20 00007365 00000000 00000000      zones..........

080064b0 <wa>:
 80064b0:	20000c58 20000da0 20000ee8 20001030     X.. ... ... 0.. 
 80064c0:	20001178 00000000 00000000 00000000     x.. ............
 80064d0:	00000042 00000041 00000044 00000043     B...A...D...C...
 80064e0:	44434241 00000045 00000000 00000000     ABCDE...........
 80064f0:	67736d20 2c532f73 00000020 44434241      msgs/S, ...ABCD
	...
 8006510:	00004241 00434241 00000000 00000000     AB..ABC.........

08006520 <evhndl>:
 8006520:	080047f1 080047e1 080047d1              .G...G...G..
